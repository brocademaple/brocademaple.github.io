<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>CS186 SQL6 B+ Trees |  私の宝庫です</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/ayer.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-CS_Notes/Database/CS186 SQL6 B+ Trees"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  CS186 SQL6 B+ Trees
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/08/27/CS_Notes/Database/CS186%20SQL6%20B+%20Trees/" class="article-date">
  <time datetime="2024-08-26T16:00:00.000Z" itemprop="datePublished">2024-08-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/SQL-notes/">SQL notes</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">17 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<ul>
<li>目前看到：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=NcuORWy48Qk&amp;list=PLYp4IGUhNFmw8USiYMJvCUjZe79fvyYge&amp;index=44">(3) Lec 6 Part 1 Intro to Indexes - YouTube</a></p>
<h3 id="Reminder-on-Heap-Files"><a class="header-anchor" href="#Reminder-on-Heap-Files">¶</a>Reminder on Heap Files</h3>
<ul>
<li>
<p>Two access APIs:</p>
<blockquote>
<p>两种从堆文件中查找记录的方式</p>
</blockquote>
<ul>
<li>
<p>fetch by <strong>recordId (pageId, slotId)</strong></p>
<blockquote>
<p>直接通过给定的记录ID来检索特定的记录</p>
<p>适合快速定位单个记录，尤其是已知道记录的确切位置时</p>
</blockquote>
</li>
<li>
<p>scan (starting from some page)</p>
<blockquote>
<p>从文件中的某一页开始，顺序地读取所有记录的过程</p>
<p>通常用于全表扫描或当查询条件不支持更高效的索引访问时</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Data structures in RAM:</p>
<blockquote>
<p>内存中的数据结构</p>
</blockquote>
<ul>
<li>
<p>Search trees (Binary, AVL, Red-Black, …)</p>
<blockquote>
<p>可以在不扫描整个数据集的情况下进行查找记录的数据结构：</p>
<p>搜索树（如二叉搜索树(Binary Search Trees)，AVL树，红黑树(Red-Black Trees)，等等）</p>
<p><strong>二叉搜索树(Binary Search Trees)</strong>：每个节点最多有两个子节点，左子树上的所有节点值小于根节点值，右子树上的所有节点值大于根节点值</p>
<p><strong>AVL树</strong>：一种自平衡的二叉搜索树，任何节点的两个子树的高度最大差别为1</p>
<p><strong>红黑树(Red-Black Trees)</strong>：也是一种自平衡二叉搜索树，通过对树进行染色并在插入和删除时调整树来保持平衡</p>
</blockquote>
</li>
<li>
<p>Hash Tables</p>
<blockquote>
<p><strong>散列表(Hash Tables)</strong>：通过使用哈希函数将键映射到数组的一个位置上，从而实现快速的数据访问。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Needed: disk-based data structures</p>
<ul>
<li>
<p>“paginated”: made up of disk pages</p>
<blockquote>
<p>由于磁盘访问的时间成本比内存访问高得多，因此磁盘上的数据结构设计通常需要考虑如何最小化磁盘I/O操作。分页技术是将数据划分为固定大小的块（称为页面），以便有效地管理和检索数据</p>
<p>分页的数据结构使得数据库管理系统能够在磁盘上高效地存储和检索数据，同时尽量减少每次磁盘访问时读取的数据量</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="Index"><a class="header-anchor" href="#Index">¶</a>Index</h3>
<ul>
<li>
<p>An <strong>index</strong> is data structure that enables fast <strong>lookup</strong> and <strong>modification</strong> of <strong>data entries</strong> by <strong>search key</strong></p>
<blockquote>
<p><strong>索引</strong>是一种数据结构，它使通过<strong>搜索键</strong>快速<strong>查找</strong>和修改\数据条目成为可能</p>
</blockquote>
<ul>
<li>
<p><strong>Lookup</strong>: may support many different operations</p>
<ul>
<li>
<p><strong>Equality</strong>, 1-d range, 2-d region, …</p>
<blockquote>
<p><strong>等值查询</strong>，一维范围查询，二维区域查询等</p>
<p><strong>等值查询</strong>：比如查找某个特定值的所有记录</p>
<p><strong>一维范围查询</strong>：查找在一个特定范围内的记录</p>
<p><strong>二维区域查询</strong>：在地理信息系统中，可能会用到这样的查询来查找落在某个矩形区域内的记录</p>
</blockquote>
</li>
<li>
<p><strong>Search Key</strong>: any subset of columns in the relation</p>
<blockquote>
<p><strong>搜索键</strong>：关系中的任何子集列</p>
<p><strong>搜索键(Search Key)</strong>：这是用来创建索引的一组列</p>
<p>可以是一个单一的列，也可以是多个列的组合</p>
<p>搜索键不需要是唯一的，这意味着同一个键值可以在表中有多个匹配项</p>
</blockquote>
<ul>
<li>do not need to be unique
<ul>
<li>e.g.:(firstname) or (first name, lastname)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Index-Part-2"><a class="header-anchor" href="#Index-Part-2">¶</a>Index Part 2</h3>
<ul>
<li>
<p><strong>Data Entries</strong>: items stored in the index</p>
<blockquote>
<p><strong>数据条目(Data Entries)</strong>：存储在索引中的项目</p>
</blockquote>
<ul>
<li>
<p>Assume for today: a pair (<strong>k</strong>, recordId)</p>
<blockquote>
<p>假设一个对(<strong>k</strong>, recordId)的配对</p>
<p>键值(<em>k</em>)对应于搜索键，而<em>recordId</em>则是指向实际数据行的指针</p>
<p><em>recordId</em>可以帮助快速定位到堆文件中的具体记录</p>
</blockquote>
<ul>
<li>
<p>Pointers to records in Heap Files</p>
<blockquote>
<p>指向堆文件中记录的指针</p>
</blockquote>
</li>
<li>
<p>Easy to generalize later</p>
<blockquote>
<p>后续容易扩展</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Modification</strong>: want to support fast insert and delete</p>
<blockquote>
<p><strong>修改(Modification)</strong>：希望支持快速插入和删除</p>
<p>索引的设计需要考虑到如何高效地进行这插入和删除等操作而不影响整体性能</p>
<p>例如，B+树在插入和删除时可以通过分裂或合并节点来维持树的平衡</p>
</blockquote>
</li>
<li>
<p>Many Types of indexes exist: B± Tree, Hash, R-Tree, GiST, …</p>
<blockquote>
<p>存在多种类型的索引：B+树、哈希索引、R树、GiST（通用搜索树）等</p>
<p><strong>B+树(B±Tree)</strong>：主要用于支持范围查询和排序。B+树的叶节点包含实际的数据指针，并且叶节点之间互相链接，便于顺序访问</p>
<p><strong>哈希索引(Hash Index)</strong>：适用于等值查询，通过哈希函数直接计算出键值的位置</p>
<p><strong>R树(R-Tree)</strong>：用于空间索引，支持多维数据的范围查询，常见于地理信息系统(GIS)</p>
<p><strong>GiST（Generalized Search Tree）</strong>：这是一个框架，用于构建多种类型的索引，支持复杂的数据结构和查询类型</p>
<p>选择哪种类型的索引取决于数据的特性和预期的查询模式</p>
</blockquote>
</li>
</ul>
<h3 id="Simple-example"><a class="header-anchor" href="#Simple-example">¶</a>Simple example</h3>
<ul>
<li>
<p><strong>Step 1</strong>: Sort heap file &amp; leave some space</p>
<blockquote>
<p>对堆文件进行排序并留出一些空闲空间</p>
<p>在创建索引之前，首先需要对堆文件中的记录进行排序</p>
<p>排序的目的是让具有相似键值的记录彼此靠近，从而提高基于键值的查找效率</p>
<p>排序时需要预留一些空闲空间，以便将来插入新记录时不需要频繁地重新组织数据</p>
</blockquote>
</li>
<li>
<p><strong>Step 2</strong>: Build the index data structure over this</p>
<blockquote>
<p>建立索引数据结构</p>
<p>索引结构的选择通常取决于数据的特性以及查询的需求</p>
</blockquote>
<ul>
<li>
<p>why not use binary search in this heap file</p>
<blockquote>
<p>why not 使用二分搜索</p>
</blockquote>
<ul>
<li>
<p>Fan-out of 2 → deep tree → lots of I/Os</p>
<blockquote>
<p>扇出度(fan-out)为2 → 树太深 → 大量的I/O操作</p>
<p>因为每次都需要访问磁盘来获取下一部分数据。这会导致效率低下，尤其是在处理大量数据时</p>
</blockquote>
</li>
<li>
<p>Examine entire records just to read key during search</p>
<blockquote>
<p>效率低→在查找过程中为了读取键而遍历所有记录</p>
<p>使用二分查找，即使只访问记录中的某个特定字段（如搜索键），也需要读取整个记录</p>
<p>因为记录在磁盘上是以连续的方式存储的，无法直接访问某个字段。这不仅浪费了带宽，也增加了不必要的磁盘I/O操作</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Build-a-high-fan-out-search-tree"><a class="header-anchor" href="#Build-a-high-fan-out-search-tree">¶</a>Build a high fan-out search tree</h3>
<blockquote>
<p>构建高扇出度的搜索树</p>
</blockquote>
<ul>
<li>
<p>Start example: <em>Sorted (key, page id) file</em></p>
<blockquote>
<p>起始示例：<em>已排序的(key, page id)文件</em></p>
<p>为要搜索的记录文件（堆）构建一个线性的索引文件</p>
<p>键值和对应的页面ID已经被排序</p>
<p>意味着，如果有一个键值，我们可以快速定位到相应的页面ID</p>
</blockquote>
<ul>
<li>
<p>No record data</p>
<blockquote>
<p>不包含记录数据</p>
<p>索引文件通常不包含完整的记录数据，而是仅包含用于快速查找的键值和指向实际数据所在页面的ID</p>
</blockquote>
</li>
<li>
<p>Binary search in the key file. Better.</p>
<blockquote>
<p>在键文件中使用二分查找效率更高</p>
<p>查找操作只需要关注键值和页面ID，减少了数据传输量，查找效率↑↑</p>
<p>二分查找对于已排序的文件分成有效，查找速度↑↑↑  ∵每次比较都可排除一半候选范围</p>
</blockquote>
</li>
<li>
<p><strong>Forgot</strong>: Need to break across pages</p>
<blockquote>
<p><strong>忽略的问题</strong>：需要跨越页面进行分割</p>
<p>在实际的磁盘文件中，数据是分页存储的</p>
<p>如果一个页面的容量有限，那么一个大的键值范围可能需要分布在多个页面上</p>
<p>要求索引结构能够有效地处理跨页面的数据</p>
</blockquote>
</li>
<li>
<p>**Complexity: ** Still binary search, just a constant factor smaller input</p>
<blockquote>
<p><strong>复杂度</strong>：仍然是二分查找，只是输入规模减小了一个常数因子</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>**<u>B+树</u>**是一种专门为磁盘存储设计的树形数据结构</p>
<ul>
<li>
<p><strong>高扇出度</strong></p>
<blockquote>
<p>每个节点可以存储多个键值对和指针，树的深度较浅，则每次查找需要访问的磁盘页面较少。</p>
</blockquote>
</li>
<li>
<p><strong>跨页面分割</strong></p>
<blockquote>
<p>B+树可以很好地处理跨页面的数据分割，因为它的设计允许在插入或删除数据时通过节点的分裂和合并来保持树的平衡。</p>
</blockquote>
</li>
<li>
<p><strong>高效的磁盘访问</strong></p>
<blockquote>
<p>B+树的节点通常存储在磁盘的单个页面中，这样可以减少磁盘I/O操作的数量，提高查找效率。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="Status-Check"><a class="header-anchor" href="#Status-Check">¶</a>Status Check</h3>
<ul>
<li>
<p>Some design goals</p>
<ul>
<li>
<p>Fast sequential scan</p>
<blockquote>
<p>快速顺序扫描</p>
<p>可采取方法：</p>
<p><strong>链式结构</strong>：将记录链接起来，使能够按顺序访问。</p>
<p>例如，在B+树中，所有叶节点都是通过指针相连的，这样可以支持顺序扫描</p>
<p><strong>预读机制</strong>：在磁盘I/O操作中，预读机制可以提前加载后续的数据页，从而减少磁盘访问延迟</p>
</blockquote>
</li>
<li>
<p>High Fan-out</p>
<blockquote>
<p><strong>高扇出度</strong>：</p>
<p>指的是每个节点可包含更多的子节点 / 键值对。</p>
<p>这样减少树的深度，从而减少查找所需的磁盘I/O操作次数</p>
<p>可采取方法：</p>
<p><strong>增加节点容量</strong>：每个节点存储更多的键值对，减少树的整体深度。</p>
<p><strong>优化页面布局</strong>：合理安排页面中数据，使能够容纳更多的信息，提高扇出度</p>
</blockquote>
</li>
<li>
<p>Support insertion</p>
<blockquote>
<p>支持插入数据</p>
<p>可采取方法：</p>
<p><strong>动态调整</strong>：插入新记录时，如果某个节点已满，则进行节点分裂，即将节点中的部分数据移动到新的节点中</p>
<p><strong>自平衡机制</strong>：例如，在B+树中，当节点分裂时，分裂产生的新节点会被正确地插入到父节点中，以保持树的平衡。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>ISAM (Indexed Sequential Access Method)</p>
<ul>
<li>致命弱点：越来越多的溢出页面和链接列表可能占用大部分文件，最终搜索降级为线性搜索，跟没有索引的堆文件没啥两样</li>
</ul>
</li>
</ul>
<h3 id="Recap-ISAM（老idea）"><a class="header-anchor" href="#Recap-ISAM（老idea）">¶</a>Recap: ISAM（老idea）</h3>
<ul>
<li>
<p>Data entries in sorted heap file</p>
<blockquote>
<h4 id="数据条目在排序的堆文件中"><a class="header-anchor" href="#数据条目在排序的堆文件中">¶</a>数据条目在排序的堆文件中</h4>
</blockquote>
</li>
<li>
<p>High fan-out static tree index</p>
<blockquote>
<p>高扇出度的静态树索引</p>
</blockquote>
</li>
<li>
<p>Fast search + good locality</p>
<blockquote>
<p>快速搜索和良好的局部性</p>
</blockquote>
<ul>
<li>
<p>Assuming nothing changes</p>
<blockquote>
<p>假设不变性</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Insert into overflow pages</p>
<blockquote>
<p>插入到溢出页面</p>
<p>向已排序的堆文件中插入新记录时，如果当前位置的空间不足，ISAM会将新记录插入到溢出页面中</p>
<p>溢出页面用于存储那些无法立即插入到主文件中的记录。这样做可以避免频繁的页面分裂和重组，从而降低维护成本</p>
</blockquote>
</li>
</ul>
<h3 id="A-Note-of-Caution"><a class="header-anchor" href="#A-Note-of-Caution">¶</a>A Note of Caution</h3>
<ul>
<li>
<p>ISAM is an old-fashioned idea</p>
<blockquote>
<p>ISAM是一种经典的文件组织和访问方法，主要用于在磁盘上高效地存储和检索数据</p>
<p>ISAM最初设计用于那些数据相对稳定、更新频率较低的应用场景</p>
</blockquote>
<ul>
<li>
<p>Introduced by IBM in 1960s</p>
</li>
<li>
<p>B+ Trees are usually better</p>
<blockquote>
<p>B+树的优势：</p>
<p><strong>更好的动态适应性</strong>：B+树能够更好地处理数据的动态变化，包括插入和删除操作</p>
<p><strong>更高的扇出度</strong>：每个节点可以存储更多的键值对，从而减少树的深度</p>
<p><strong>更高效的磁盘访问</strong>：B+树的设计考虑了磁盘I/O的优化，能够减少磁盘访问次数</p>
</blockquote>
<ul>
<li>
<p>Though not always</p>
<blockquote>
<p>B+树good， 但不是所有情况都这样</p>
<p>对于简单应用程序或小型数据库，ISAM够用</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>But it’s a good place to start</p>
<ul>
<li>
<p>Simpler than B+ Tree, many of the same ideas</p>
<blockquote>
<p>比B+树简单， 很多概念相似</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Upshot</p>
<ul>
<li>
<p>Don’t brag about ISAM on resume</p>
<blockquote>
<p>老技术别写简历</p>
</blockquote>
</li>
<li>
<p>Do understand ISAM, and tradeoffs with B+ trees</p>
<blockquote>
<p>但理解ISAM，了解其与B+树之间的权衡（？</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="❤❤B±-Tree❤❤"><a class="header-anchor" href="#❤❤B±-Tree❤❤">¶</a>❤❤B± Tree❤❤</h2>
<h3 id="Enter-the-B-Tree"><a class="header-anchor" href="#Enter-the-B-Tree">¶</a>Enter the B+ Tree</h3>
<ul>
<li>
<p>Similar to ISAM</p>
<ul>
<li>
<p>Same interior node structure</p>
<blockquote>
<p>与ISAM相同的内部节点结构</p>
</blockquote>
<ul>
<li>
<p><code>&lt;Key, Page Ptr&gt;</code> pairs with same key invariant</p>
<blockquote>
<p><code>&lt;Key, Page Ptr&gt;</code>对，具有相同的键不变性</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Same search routine as before</p>
<blockquote>
<p>与ISAM相同的搜索程序</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>Dynamic Tree Index</strong></p>
<blockquote>
<p>B+ 树是一种动态树索引</p>
</blockquote>
<ul>
<li>
<p>Always Balanced</p>
<blockquote>
<p>B+ Tree面对插入和删除操作也始终保持平衡</p>
</blockquote>
</li>
<li>
<p>Support efficient insertion &amp; deletion</p>
<blockquote>
<p>B+ 树支持高效的插入删除操作</p>
<p>B+树在插入和删除时会自动调整节点，以保持树的平衡</p>
<p>插入：分裂后的节点会被插入父节点</p>
<p>删除：删除记录时，若某节点过于稀疏，则可能进行节点合并；合并后节点同样插入父节点，保持树的平衡</p>
</blockquote>
<ul>
<li>
<p>Grows at root not leaves</p>
<blockquote>
<p><strong>在根部分裂而不是叶节点</strong>：</p>
<p>B+树在插入或删除操作时，通常会在根节点处进行分</p>
<p>树的高度增长从根节点而不是从叶节点开始</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>“+”? B- Tree that stores data entries in leaves only</p>
<blockquote>
<p>B+树是一种特殊的B树，在叶节点中只存储数据条目</p>
<p>所有的数据记录都存储在叶节点中，而非叶节点仅存储键值对和指向其他节点的指针</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>缺图：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=xeyE8tiVzbw&amp;list=PLYp4IGUhNFmw8USiYMJvCUjZe79fvyYge&amp;index=47">(12) Lecture 6 Part 4 B+ Tree Intro - YouTube</a>   1:13</p>
</li>
<li>
<p>Occupancy Invariant</p>
<blockquote>
<p>B+树有占用不变量→保持B+树的平衡性和高效性</p>
</blockquote>
<ul>
<li>
<p>Each interior node is at least partially full:</p>
<blockquote>
<p>每个内部节点</p>
</blockquote>
<ul>
<li>
<p><strong>d &lt;= #entries &lt;= 2d</strong></p>
<blockquote>
<p>内部节点的键值数量必须在 <code>d</code> 到 <code>2d</code> 之间</p>
</blockquote>
</li>
<li>
<p><strong>d: order of the tree (max fan-out = 2d + 1)</strong></p>
<blockquote>
<p><strong>d: 树的阶数</strong></p>
<p>阶数为d的树的最大扇出度 = 2d + 1</p>
<p>每个键值后面都有一个指针指向下一个节点，加上最后一个指针，总共可以有 <code>2d + 1</code> 个子节点。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Data pages at bottom need not to be stored in logical order</p>
<blockquote>
<p>B+树底层的数据页面不必按逻辑顺序存储</p>
</blockquote>
<ul>
<li>
<p>Next and prev pointers</p>
<blockquote>
<p>前后指针</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>缺图：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=xeyE8tiVzbw&amp;list=PLYp4IGUhNFmw8USiYMJvCUjZe79fvyYge&amp;index=47">(12) Lecture 6 Part 4 B+ Tree Intro - YouTube</a>   2:46  4:00</p>
</li>
</ul>
<h3 id="B-Tree-in-Practice"><a class="header-anchor" href="#B-Tree-in-Practice">¶</a>B+ Tree in Practice</h3>
<blockquote>
<p>B+ Tree在实践中的应用</p>
</blockquote>
<ul>
<li>
<p>Typical order: 1600. Typical fill-factor: 67%</p>
<blockquote>
<p>典型的阶数(order)：1600**。**典型的填充率(fill-factor)：67%</p>
</blockquote>
<ul>
<li>
<p>average fan-out = 2144</p>
<blockquote>
<p>平均扇出度(fan-out) = 2144</p>
</blockquote>
</li>
<li>
<p>(assuming 128 Kbytes pages at 40Bytes per record)</p>
<blockquote>
<p>（假设页面大小为128 KB，每条记录占用40字节）</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>At typical capacities</p>
<blockquote>
<p>在典型容量下的高度</p>
</blockquote>
<ul>
<li>Height 1:2144^2 = 4,596,736 records</li>
<li>Height 2:2144^3 = 9,855,401,984 records</li>
</ul>
</li>
<li>
<p>B+树的高度低，但数据量大</p>
</li>
</ul>
<h3 id="Searching-the-B-Tree"><a class="header-anchor" href="#Searching-the-B-Tree">¶</a>Searching the B+ Tree</h3>
<ul>
<li>Same as ISAM</li>
<li>Find key = 27
<ul>
<li>Find split on each node (Binary Search)</li>
<li>Follow pointer to next node</li>
</ul>
</li>
<li>索引：&lt;键key, 指向记录的指针pointer&gt;</li>
</ul>
<h3 id="Insert-x-into-a-B-Tree"><a class="header-anchor" href="#Insert-x-into-a-B-Tree">¶</a>Insert x into a B+ Tree</h3>
<ul>
<li>
<p>Find the correct leaf</p>
<blockquote>
<p>找到正确的叶子结点</p>
</blockquote>
</li>
<li>
<p>If there is room in the leaf just add the entry</p>
<ul>
<li>Sort the leaf page by key</li>
</ul>
</li>
</ul>
<h3 id="Inserting-x-into-a-B-Tree-Insert"><a class="header-anchor" href="#Inserting-x-into-a-B-Tree-Insert">¶</a>Inserting x into a B+ Tree: Insert</h3>
<ul>
<li>
<p>Find the correct leaf</p>
<blockquote>
<p>找到正确的叶子结点</p>
</blockquote>
<ul>
<li>
<p>Split leaf if there is not enough room</p>
<blockquote>
<p>没有足够的空间，就分割叶子结点</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Redistribute entries evenly</p>
</li>
</ul>
<blockquote>
<p>重新分配旧的叶子节点</p>
</blockquote>
<ul>
<li>
<p>Fix next / prev pointers</p>
<blockquote>
<p>找到下一个 / 上一个指针，分割旧的叶子节点</p>
</blockquote>
</li>
<li>
<p><strong>Copy up from leaf</strong> the middle key</p>
<blockquote>
<p>创建一个父节点，其将成为一个新的索引条目；该索引条目将指向该节点，并作为分割键</p>
<p>索引的值取节点内最小值</p>
<p>然后将新的索引放入原始节点的父节点中</p>
</blockquote>
</li>
<li>
<p>recursively split index nodes</p>
<blockquote>
<p>递归地将父节点拆分为两半</p>
</blockquote>
<ul>
<li>
<p>redistribute the rightmost d keys</p>
<blockquote>
<p>重新分配最右边的d</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>push up from interior node</strong> the middle key</p>
<blockquote>
<p>把分到右拆分结点的最左边的key取出，成为新的根节点</p>
<p>缺图   <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=iQ1lmTnZOT8&amp;list=PLYp4IGUhNFmw8USiYMJvCUjZe79fvyYge&amp;index=49">(12) Lecture 6 Part 6 - YouTube</a>   3:23</p>
</blockquote>
<ul>
<li>
<p>Now the last key on left</p>
<blockquote>
<p>原父节点最后一个key就是左拆分结点最左边的key</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>分割父节点时，必须实际分配一个新节点root分裂右侧的父节点；分配一个新的根，树就会增长一级</p>
</li>
</ul>
<h3 id="Copy-up-vs-Push-up"><a class="header-anchor" href="#Copy-up-vs-Push-up">¶</a>Copy up vs Push up</h3>
<ul>
<li>
<p>Notice：</p>
<blockquote>
<p>在B+树中，当进行插入操作时，可能会导致节点分裂。分裂后，需要将某些条目向上移动到父节点</p>
<p>具体来说，有两种不同的方式来处理这些条目：<strong>复制</strong>和<strong>推</strong></p>
<ol>
<li><strong>复制（Copy up）</strong>：
<ul>
<li>当一个叶节点分裂时，其中一个条目会被复制到父节点中。这个条目通常是最小或最大的键值。</li>
<li>例如，如果叶节点分裂后产生了两个新的叶节点，其中一个叶节点的第一个条目会被复制到父节点中。</li>
</ul>
</li>
<li><strong>推（Push up）</strong>：
<ul>
<li>当一个内部节点分裂时，中间的键值会被推到父节点中。这个键值用于区分两个新的子节点。</li>
<li>例如，如果内部节点分裂后产生了两个新的内部节点，中间的键值会被推到父节点中，用于区分这两个新的子节点</li>
</ul>
</li>
</ol>
</blockquote>
<ul>
<li>
<p>The <strong>leaf</strong> entry (5) was <strong>copied</strong> up</p>
<blockquote>
<p><strong>叶节点</strong>条目 (5) 被<strong>复制</strong>到上层</p>
</blockquote>
</li>
<li>
<p>The <strong>index</strong> entry (17) was <strong>pushed</strong> up</p>
<blockquote>
<p><strong>索引</strong>条目 (17) 被<strong>推</strong>到上层</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="Inserting-x-into-a-B-Tree-Final"><a class="header-anchor" href="#Inserting-x-into-a-B-Tree-Final">¶</a>Inserting x into a B+ Tree: Final</h3>
<ul>
<li>
<p>Check invariants</p>
<blockquote>
<p>检查不变量</p>
</blockquote>
</li>
<li>
<p><strong>Key Invariant</strong>:</p>
<blockquote>
<p>键不变量</p>
<p><strong>键不变量</strong>：每个内部节点的键值用于区分其子节点。具体来说，对于每个内部节点 <code>[..., (Kl, Pl), ...]</code>，其中 <code>(Kl, Pl)</code> 表示键值 <code>Kl</code> 和指向子节点 <code>Pl</code> 的指针，必须满足 <code>Kl ≤ K</code> 对于 <code>Pl</code> 子树中的所有键值 <code>K</code></p>
</blockquote>
<ul>
<li>Node[…, (Kl, Pl), …] → Kl &lt;= K for all K in Pl Sub-tree</li>
</ul>
</li>
<li>
<p><strong>Occupancy Invariant</strong></p>
<blockquote>
<p>占用不变量</p>
<p><strong>占用不变量</strong>：每个节点（无论是内部节点还是叶节点）的条目数量必须在 <code>d</code> 和 <code>2d</code> 之间。</p>
<ul>
<li><code>d</code> 是树的阶数，表示每个节点至少包含 <code>d</code> 个条目。</li>
<li><code>2d</code> 是每个节点最多可以包含的条目数量</li>
</ul>
</blockquote>
<ul>
<li>d &lt;= # entries &lt;= 2d</li>
</ul>
</li>
</ul>
<h2 id="B-Tree-Insert-Algorithm-Sketch"><a class="header-anchor" href="#B-Tree-Insert-Algorithm-Sketch">¶</a>B+ Tree Insert: Algorithm Sketch</h2>
<ul>
<li>
<p>Find the correct leaf L</p>
<blockquote>
<p>找到正确的要插入的叶子节点</p>
<p>通过典型的搜索算法来完成</p>
</blockquote>
</li>
<li>
<p>Put data entry onto L</p>
<blockquote>
<p>将数据条目放到叶子节点 L 上</p>
</blockquote>
<ul>
<li>
<p>If L has enough space, done</p>
<blockquote>
<p>如果叶子节点 L 有足够的空间（即条目数量不超过 <code>2d</code>），直接将新的条目插入到 L 中</p>
</blockquote>
</li>
<li>
<p>Else, must split L (into L and a new node L2)</p>
<blockquote>
<p>如果叶子节点 L 没有足够的空间（即条目数量超过 <code>2d</code>），则需要分裂 L</p>
</blockquote>
<ul>
<li>
<p>Redistribute entries evenly, copy up middle key</p>
<blockquote>
<p><strong>均匀重新分配条目</strong>：将 L 中的条目均匀地重新分配到两个新的节点中，即 L 和新的节点 L2。</p>
<p><strong>复制中间键</strong>：将中间的键值复制到父节点中。这个中间键值用于区分两个新的子节点。</p>
</blockquote>
</li>
<li>
<p>Insert index entry pointing to L2 into parent of L</p>
<blockquote>
<p><strong>插入索引条目</strong>：在 L 的父节点中插入一个新的索引条目，该条目指向新的节点 L2</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        share
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://brocademaple.github.io/2024/08/27/CS_Notes/Database/CS186%20SQL6%20B+%20Trees/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CS-Notes/" rel="tag">CS Notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Database/" rel="tag">Database</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/08/27/CS_Notes/Database/CS186%20SQL5%20Disks,%20Files%20and%20Buffers%20II/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            CS186 SQL5 Berkeley
          
        </div>
      </a>
    
    
      <a href="/2024/08/26/CS_Notes/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/%E3%80%90%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0%E3%80%91%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">【课内】软件工程导论</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2024
        <i class="ri-heart-fill heart_icon"></i> brocademaple
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer.png" alt="私の宝庫です"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/aboutMe">自分</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1983763439&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>