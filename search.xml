<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CS186 SQL1 Berkeley</title>
    <url>/2024/07/04/CS186%20SQL1/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>Berkeley CS186 Intro to DB Systems</p>
<p><a href="https://www.youtube.com/watch?v=Q-dxGaR3fH0&amp;list=PLYp4IGUhNFmw8USiYMJvCUjZe79fvyYge&amp;index=6">视频地址</a>  课程记录</p>
<h2 id="SQL-1"><a class="header-anchor" href="#SQL-1">¶</a>SQL 1</h2>
<h3 id="what-is-database"><a class="header-anchor" href="#what-is-database">¶</a>what is database</h3>
<h4 id="一些术语"><a class="header-anchor" href="#一些术语">¶</a>一些术语</h4>
<p><code>Relation/Table</code></p>
<ul>
<li><code>Schema: description(&quot;metadata&quot;)</code></li>
<li><code>Instance: set of data satisfying the schema</code></li>
</ul>
<p><code>Attribute/Column/Field</code></p>
<p><code>Tuple/Record/Row</code></p>
<h4 id="一些注意事项"><a class="header-anchor" href="#一些注意事项">¶</a>一些注意事项</h4>
<ol>
<li>每列的类型都是<code>原子类型(无法再细分的)</code>,因此不会是<code>list</code>或者<code>map</code>那种类型的数据</li>
<li><code>saddress</code> 每一行都要<code>fit the schema</code>  简单说就是三行三列的表中不能插入四列的数据行</li>
<li><code>baddress</code>  每一列的名字不能相同</li>
<li><code>maddress</code>  数据类型只能是原子类型</li>
</ol>
<h3 id="SQL-Language"><a class="header-anchor" href="#SQL-Language">¶</a>SQL Language</h3>
<h4 id="Two-sublanguages"><a class="header-anchor" href="#Two-sublanguages">¶</a>Two sublanguages</h4>
<p><code>DDL</code>-Data Definition Language-Define and modify schema   用于定义和修改数据库架构</p>
<p><code>DML</code>-Data Manipulation Language-Queries can be written intuitively  用于操作实际数据</p>
<h4 id="The-SQL-DDL-Sailors"><a class="header-anchor" href="#The-SQL-DDL-Sailors">¶</a>The SQL DDL: Sailors</h4>
<p>以Sailors为例子，来创建数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Sailors (</span><br><span class="line">	sid <span class="type">INTEGER</span>,</span><br><span class="line">	sname <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">	rating <span class="type">INTEGER</span>,</span><br><span class="line">	age <span class="type">FLOAT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (sid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>sid</th>
<th>SNAME</th>
<th>RATING</th>
<th>AGE</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Fred</td>
<td>7</td>
<td>22</td>
</tr>
<tr>
<td>2</td>
<td>Jim</td>
<td>2</td>
<td>39</td>
</tr>
<tr>
<td>3</td>
<td>Nancy</td>
<td>8</td>
<td>27</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Boats (</span><br><span class="line">	bid <span class="type">INTEGER</span>,</span><br><span class="line">	bname <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">	color <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (Bid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>BID</th>
<th>BNAME</th>
<th>COLOR</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>Nina</td>
<td>red</td>
</tr>
<tr>
<td>102</td>
<td>Pinta</td>
<td>blue</td>
</tr>
<tr>
<td>103</td>
<td>Santa Maria</td>
<td>red</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Reserves (</span><br><span class="line">	sid <span class="type">INTEGER</span>,</span><br><span class="line">	bid <span class="type">INTEGER</span>,</span><br><span class="line">	<span class="keyword">day</span> <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (sid, bid, <span class="keyword">day</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (sid)  <span class="keyword">REFERENCES</span> Sailors;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>sid</th>
<th>bid</th>
<th>day</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>102</td>
<td>9/12</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>9/13</td>
</tr>
</tbody>
</table>
<h5 id="Primary-Key-column-s"><a class="header-anchor" href="#Primary-Key-column-s">¶</a>Primary Key column(s)</h5>
<ul>
<li>provide a unique “lookup key” for the relation   提供关系的唯一查找键    sid对于这些键值是唯一的</li>
<li>cannot have any duplicate values  不能有重复的值，主键的值在表中必须是唯一的</li>
<li>can be made up of &gt; 1 column  主键可以由多列组成   由多列组成的话就叫做复合主键（kimi给的例子：如果一个表中存储了多个部门的员工信息，可能需要使用部门ID和员工ID的组合作为主键来确保唯一性 ）</li>
</ul>
<h5 id="Foreign-Key-column-s"><a class="header-anchor" href="#Foreign-Key-column-s">¶</a>Foreign Key column(s)</h5>
<p>Foreign Key column(s)  外键</p>
<p>外键应用另一个表的主键或唯一键</p>
<p>上述外键是<code>Sailors</code>表的指针，即<code>Reserves</code>的<code>sid</code>指向<code>Sailors</code>的<code>sid</code></p>
<ul>
<li>Foreign Key references a table via the primary key of that table  外键通过另一个表的主键来引用另一个表</li>
<li>need not share the name of the referenced primary key    不一定和被引用的主键同名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Reserves (</span><br><span class="line">	sid <span class="type">INTEGER</span>,</span><br><span class="line">	bid <span class="type">INTEGER</span>,</span><br><span class="line">	<span class="keyword">day</span> <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (sid, bid, <span class="keyword">day</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (sid)  <span class="keyword">REFERENCES</span> Sailors,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (bid)  <span class="keyword">REFERENCES</span> Boats;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="The-SQL-DML"><a class="header-anchor" href="#The-SQL-DML">¶</a>The SQL DML</h4>
<h5 id="Basic-Single-Table-Queries"><a class="header-anchor" href="#Basic-Single-Table-Queries">¶</a>Basic Single-Table Queries</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span><span class="keyword">column</span> expression list<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>single <span class="keyword">table</span><span class="operator">&gt;</span> [<span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure>
<h5 id="SELECT-DISTINCT"><a class="header-anchor" href="#SELECT-DISTINCT">¶</a>SELECT DISTINCT</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> S.name, S.gpa</span><br><span class="line"><span class="keyword">FROM</span> students (<span class="keyword">AS</span>) S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>DISTINCT specifies removal of duplicate rows before output  DISTINCT 在输出前会移除重复行，如果查询结果有多行相同数据，DISTINCT 会保证这些重复行只被显示一次</li>
<li>Can refer to the students table as “S”, this is called an alias   把学生列表记作S，S是其别名，可以简化查询，提高可读性  定义别名的AS可省略</li>
</ul>
<h5 id="ORDER-BY"><a class="header-anchor" href="#ORDER-BY">¶</a>ORDER BY</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.name, S.gpa, S.age <span class="operator">*</span> <span class="number">2</span> <span class="keyword">AS</span> A2</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> S.gpa, S.name, A2</span><br></pre></td></tr></table></figure>
<ul>
<li>将两倍年龄别名为A2</li>
<li>ORDER BY clause specifies output to be sorted-Lexicographic ordering   按照字典序排序输出</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.name, S.gpa, S.age <span class="operator">*</span> <span class="number">2</span> <span class="keyword">AS</span> A2</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> S.gpa <span class="keyword">DESC</span>, S.name <span class="keyword">ASC</span>, A2</span><br></pre></td></tr></table></figure>
<ul>
<li>DESC  降序  ASC  升序  默认是升序</li>
</ul>
<h5 id="LIMIT"><a class="header-anchor" href="#LIMIT">¶</a>LIMIT</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.name, S.gpa, S.age <span class="operator">*</span> <span class="number">2</span> <span class="keyword">AS</span> A2</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> S.gpa <span class="keyword">DESC</span>, S.name <span class="keyword">ASC</span>, a2;</span><br><span class="line">LIMIT <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>限制输出为几行</li>
</ul>
<h5 id="Aggregates"><a class="header-anchor" href="#Aggregates">¶</a>Aggregates</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="built_in">AVG</span>(S.gpa)</span><br><span class="line"><span class="keyword">FROM</span> students S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>AVG()：计算平均值</p>
</li>
<li>
<p>Before producing output, compute a summary(a.k.a. an aggregate) of some arithmetic expression</p>
</li>
<li>
<p>produce 1 row of output -with one column in this case</p>
</li>
<li>
<p>other aggregates: SUM, COUNT, MAX, MIN</p>
</li>
</ul>
<h5 id="GROUP-BY"><a class="header-anchor" href="#GROUP-BY">¶</a>GROUP BY</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="built_in">AVG</span>(S.gpa), S.dept</span><br><span class="line"><span class="keyword">FROM</span> students S</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.dept</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>GROUP BY：按照GROUP BY后面列出的列，进行分组</p>
</li>
<li>
<p>Partition table into groups with same GROUP BY column values - Can group by a list of columns    将表按照具有相同GROUP BY列值的组进行分区，可以根据一列或多列进行分组</p>
</li>
<li>
<p>Produce an aggregate result per group -Cardinality of output = # of distinct group values   为每个组生成一个聚合结果，输出的基数等于不同组值的数量</p>
</li>
<li>
<p>Note: can put grouping columns in SELECT list   可以将分组放入SELECT列表</p>
</li>
</ul>
<h5 id="HAVING"><a class="header-anchor" href="#HAVING">¶</a>HAVING</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="built_in">AVG</span>(S.gpa), S.dept</span><br><span class="line"><span class="keyword">FROM</span> students S</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.dept</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>The HAVING predicate filters groups  用于过滤分组后的结果</li>
<li>HAVING is applied after grouping and aggregation    HAVING子句在分组和聚合计算完成后应用       -Hence can contain anything that could go in the SELECT list  因此可以包含选择列表中的任何内容</li>
<li>HAVING can only be used in aggregate queries   HAVING只能用在聚合查询中</li>
<li>it’s an optional clause    可选非必须</li>
</ul>
<h5 id="Putting-it-all-together"><a class="header-anchor" href="#Putting-it-all-together">¶</a>Putting it all together</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.dept, <span class="built_in">AVG</span>(S.gpa), <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> students S</span><br><span class="line"><span class="keyword">WHERE</span> S.gender <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.dept</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> S.dept</span><br></pre></td></tr></table></figure>
<h5 id="DISTINCT-Aggregates"><a class="header-anchor" href="#DISTINCT-Aggregates">¶</a>DISTINCT Aggregates</h5>
<p>DISTINCT can be used inside or outside of aggregate function, but have different meanings</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> S.name)</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="built_in">COUNT</span>(S.name)</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一个：在计数之前先把所有重复项移除   相当于只计算有多少中不同项</li>
<li>第二个：先计数，再移除重复项   相当于计算所有项</li>
</ul>
<h5 id="What-Is-This-Asking-For"><a class="header-anchor" href="#What-Is-This-Asking-For">¶</a>What Is This Asking For?</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.name, <span class="built_in">AVG</span>(S.gpa)</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.dept</span><br></pre></td></tr></table></figure>
<ul>
<li><code>illegal query</code>   因为<code>S.name</code>没有被包含在<code>GROUP BY</code> 子句中，也没有被用在聚合函数中。数据库不知道应该选择哪个学生的姓名来显示，因为可能有多个学生具有相同的系别（<code>S.dept</code>）。</li>
</ul>
<h5 id="SQL-DML-General-Basic-Single-Table-Queries"><a class="header-anchor" href="#SQL-DML-General-Basic-Single-Table-Queries">¶</a>SQL DML: General Basic Single-Table Queries</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span><span class="keyword">column</span> expression list<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>single <span class="keyword">table</span><span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>predictable<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">column</span> list<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">HAVING</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">column</span> list<span class="operator">&gt;</span>]</span><br><span class="line">[LIMIT <span class="operator">&lt;</span><span class="type">integer</span><span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>notes</category>
        <category>SQL notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>CS186 SQL2 Berkeley</title>
    <url>/2024/07/05/CS186%20SQL2/</url>
    <content><![CDATA[<h2 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h2>
<p>Berkeley CS186 Intro to DB Systems</p>
<p><a href="https://www.youtube.com/watch?v=Q-dxGaR3fH0&amp;list=PLYp4IGUhNFmw8USiYMJvCUjZe79fvyYge&amp;index=6">视频地址</a>  课程记录</p>
<h2 id="SQL-2"><a class="header-anchor" href="#SQL-2">¶</a>SQL 2</h2>
<h3 id="Conceptual-SQL-Evaluation"><a class="header-anchor" href="#Conceptual-SQL-Evaluation">¶</a>Conceptual SQL Evaluation</h3>
<p>SQL查询从原始数据表提取和转换数据的执行顺序</p>
<ol>
<li>
<p><code>FROM</code> Identify table  确定表</p>
</li>
<li>
<p><code>WHERE</code>  Apply selections(eliminate rows)   应用选择条件（筛选行）</p>
</li>
<li>
<p><code>SELECT</code>  Project away columns(keep only those used in SELECT, GBY, HAVING)   SELECT子句指定了需要返回哪些列，或通过聚合函数进行计算</p>
</li>
<li>
<p><code>GROUP BY</code>  Form groups &amp; aggregate   用GROUP BY将数据分组，并对每个组应用聚合函数</p>
</li>
<li>
<p><code>HAVING</code>  Eliminate groups   过滤不满足条件的组</p>
</li>
<li>
<p><code>DISTINCT</code>  Eliminate duplicates   在最终结果中去除重复的行</p>
</li>
<li>
<p>(Optinal) <code>ORDER BY</code> <code>LIMIT</code> applied at end, to “format” output  格式化输出    <code>ORDER BY</code> 用于控制升序/降序输出, <code>LIMIT</code> 用于获取特定数量的排序后结果，通常与<code>ORDER BY</code>一起使用</p>
</li>
</ol>
<h4 id="Putting-it-all-together"><a class="header-anchor" href="#Putting-it-all-together">¶</a>Putting it all together</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.dept, <span class="built_in">AVG</span>(S.gpa), <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">WHERE</span> S.gender <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.dept</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> S.dept</span><br></pre></td></tr></table></figure>
<p>解释：从别名为S的Students学生表中，筛选出性别为Female的学生，按照所在部门分组，并输出符合条件的学生的部门信息、平均GPA和学生总数，至少有两名女性学生的部门才会被输出，最终结果按照部门字典序排列</p>
<h3 id="Join-Queries"><a class="header-anchor" href="#Join-Queries">¶</a>Join Queries</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span><span class="keyword">column</span> expression list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table1 [<span class="keyword">AS</span> t1], ..., tableN [<span class="keyword">AS</span> tn]<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">column</span> list<span class="operator">&gt;</span> [<span class="keyword">HAVING</span>  <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>] ]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">column</span> list<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>
<p><code>多表查询</code></p>
<p>区别就是FROM那里有多个表</p>
<h4 id="Cross-Cartesian-Product"><a class="header-anchor" href="#Cross-Cartesian-Product">¶</a>Cross(Cartesian) Product</h4>
<ul>
<li>All pairs of tuples, concentrated</li>
</ul>
<h4 id="Example-Sailors-who-have-reserved-a-boat"><a class="header-anchor" href="#Example-Sailors-who-have-reserved-a-boat">¶</a>Example: Sailors who have reserved a boat</h4>
<p><code>Sailors</code>表</p>
<table>
<thead>
<tr>
<th>sid</th>
<th>sname</th>
<th>rating</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Popeye</td>
<td>10</td>
<td>22</td>
</tr>
<tr>
<td>2</td>
<td>OliveOyl</td>
<td>11</td>
<td>39</td>
</tr>
<tr>
<td>3</td>
<td>Garfield</td>
<td>1</td>
<td>27</td>
</tr>
<tr>
<td>4</td>
<td>Bob</td>
<td>5</td>
<td>19</td>
</tr>
</tbody>
</table>
<p><code>Reserveds</code> 表</p>
<table>
<thead>
<tr>
<th>SID</th>
<th>BID</th>
<th>DAY</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>102</td>
<td>9//12</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>9/13</td>
</tr>
<tr>
<td>1</td>
<td>101</td>
<td>10/01</td>
</tr>
</tbody>
</table>
<p>有效合并表的SQL语句 “预订了船的水手”</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sailors.sid, Sailors.sname, Reserves.bid</span><br><span class="line"><span class="keyword">FROM</span> Sailors, Reserves</span><br><span class="line"><span class="keyword">WHERE</span> Sailors.sid <span class="operator">=</span> Reserves.sid</span><br></pre></td></tr></table></figure>
<p>合并后的表—— “预订了船的水手”</p>
<table>
<thead>
<tr>
<th>sid</th>
<th>BID</th>
<th>day</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>102</td>
<td>9/12</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>9/13</td>
</tr>
<tr>
<td>1</td>
<td>101</td>
<td>10/01</td>
</tr>
</tbody>
</table>
<h3 id="Column-Names-and-Table-Aliases"><a class="header-anchor" href="#Column-Names-and-Table-Aliases">¶</a>Column Names and Table Aliases</h3>
<p>原来的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sailors.sid, Sailors.sname, Reserve.bid</span><br><span class="line"><span class="keyword">FROM</span> Sailors, Reserves</span><br><span class="line"><span class="keyword">WHERE</span> Sailors.sid <span class="operator">=</span> Reserve.sid</span><br></pre></td></tr></table></figure>
<p>改进之后：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sailors.sid, sname, bid</span><br><span class="line"><span class="keyword">FROM</span> Sailors <span class="keyword">AS</span> S, Reserves <span class="keyword">AS</span> R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid</span><br></pre></td></tr></table></figure>
<p>因为<code>sname</code>只有<code>Sailors</code>里面有，<code>bid</code>只有<code>Reserves</code>里面有，所以可以省略前缀，但是<code>sid</code>是两个表都有，所以需要加前缀来区分是哪个表的</p>
<p>然后给表名取别名，有助于代码精简+可读性↑</p>
<h4 id="More-Aliases"><a class="header-anchor" href="#More-Aliases">¶</a>More Aliases</h4>
<p>别名也可以在输出中使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> x.sname, x.age, y.sname <span class="keyword">AS</span> sname2, y.age <span class="keyword">AS</span> age2</span><br><span class="line"><span class="keyword">FROM</span> Sailors <span class="keyword">AS</span> x, Sailors <span class="keyword">AS</span> y</span><br><span class="line"><span class="keyword">WHERE</span> x.age <span class="operator">&gt;</span> y.age</span><br></pre></td></tr></table></figure>
<p>给同一个表两个别名，把一个表分成两个表，其中左表的年龄比右表大</p>
<ul>
<li>Table aliases in the FROM clause   - Needed when the same table used multiple times (“self-join”)    当同一个表被多次使用（“自连接”）的时候需要使用表别名来区分</li>
<li>Column aliases in the SELECT clause  为列指定别名，以便在查询结果中使用更有意义的列名</li>
</ul>
<h3 id="Arithmetic-Expressions"><a class="header-anchor" href="#Arithmetic-Expressions">¶</a>Arithmetic Expressions</h3>
<p>可以在``SELECT`语句中指定算术运算符和表达式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.age, S.age <span class="operator">-</span> <span class="number">5</span> <span class="keyword">AS</span> age1, <span class="number">2</span> <span class="operator">*</span> S.ages <span class="keyword">AS</span> age2</span><br><span class="line"><span class="keyword">FROM</span> Sailors <span class="keyword">AS</span> S</span><br><span class="line"><span class="keyword">WHERE</span> S.sname <span class="operator">=</span> <span class="string">&#x27;Popeye&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在``WHERE`语句中也可以使用算术运算符和表达式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S1.sname <span class="keyword">AS</span> name1, S2.sname <span class="keyword">AS</span> name2</span><br><span class="line"><span class="keyword">FROM</span> Sailors <span class="keyword">AS</span> S1, Sailors <span class="keyword">AS</span> S2</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">2</span><span class="operator">*</span>S1.rating <span class="operator">=</span> S2.rating<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="SQL-Calculator"><a class="header-anchor" href="#SQL-Calculator">¶</a>SQL Calculator!</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">log</span>(<span class="number">1000</span>) <span class="keyword">as</span> three,</span><br><span class="line">	<span class="built_in">exp</span>(<span class="built_in">ln</span>(<span class="number">2</span>)) <span class="keyword">as</span> two,</span><br><span class="line">	<span class="built_in">cos</span>(<span class="number">0</span>) <span class="keyword">as</span> <span class="keyword">one</span>,</span><br><span class="line">	<span class="built_in">ln</span>(<span class="number">2</span><span class="operator">*</span><span class="number">3</span>) <span class="operator">=</span> <span class="built_in">ln</span>(<span class="number">2</span>) <span class="operator">+</span> <span class="built_in">ln</span>(<span class="number">3</span>) <span class="keyword">as</span> sanity;</span><br></pre></td></tr></table></figure>
<p>没有FROM语句，且只返回一行。也可以吧SQL语言当作计算器</p>
<p>以上语句会输出一行四列的表</p>
<h3 id="String-Comparisons"><a class="header-anchor" href="#String-Comparisons">¶</a>String Comparisons</h3>
<p>SQL还支持字符串函数，特别是WHERE子句中的字符串比较函数，以下是两种不同的方式来查找格式为以B开头、且有任意数量其他字符的字符串：</p>
<ul>
<li>Old-school SQL</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.sname <span class="keyword">like</span> <span class="string">&#x27;B_%&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Standard Regular Expressions</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.sname <span class="operator">~</span> <span class="string">&#x27;B.*&#x27;</span></span><br></pre></td></tr></table></figure>
<p>好像用的是正则表达式   ~代表的是正则式匹配</p>
<h3 id="Combining-Predicates"><a class="header-anchor" href="#Combining-Predicates">¶</a>Combining Predicates</h3>
<p>使用布尔逻辑来组合多个谓词</p>
<ul>
<li>Subtle connections between:
<ul>
<li>Boolean logic in WHERE(i.e., AND, OR)</li>
<li>Traditional Set operations(i.e., INTERSECT, UNION)  传统集合操作</li>
</ul>
</li>
</ul>
<h4 id="Example1-Sid’s-of-sailors-who-reserved-a-red-or-green-boat"><a class="header-anchor" href="#Example1-Sid’s-of-sailors-who-reserved-a-red-or-green-boat">¶</a>Example1: Sid’s of sailors who reserved a red or green boat</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> R.sid</span><br><span class="line"><span class="keyword">FROM</span> Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> (B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span> <span class="keyword">OR</span> B.color <span class="operator">=</span> <span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>另一种方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> R.sid</span><br><span class="line"><span class="keyword">FROM</span> Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> R.sid</span><br><span class="line"><span class="keyword">FROM</span> Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;green&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>UNION ALL</code>    不移除重复项，相当于取并集，红or绿</p>
<h4 id="Example2-Sid’s-of-sailors-who-reserved-a-red-and-green-boat"><a class="header-anchor" href="#Example2-Sid’s-of-sailors-who-reserved-a-red-and-green-boat">¶</a>Example2: Sid’s of sailors who reserved a red and green boat</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> R.sid</span><br><span class="line"><span class="keyword">FROM</span> Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> (B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span> <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>但是此处第一种方式将不会返回任何东西，因为<code>color</code>不可能同时<code>='red'</code> 且<code>='green'</code></p>
<p>所以此处只能使用另一种方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> R.sid</span><br><span class="line"><span class="keyword">FROM</span> Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> R.sid</span><br><span class="line"><span class="keyword">FROM</span> Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;green&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>INTERSECT</code>   相当于取交集，红and绿</p>
<h3 id="Set-Semantics"><a class="header-anchor" href="#Set-Semantics">¶</a>Set Semantics</h3>
<ul>
<li>Set: a collection of distinct elements    集合是由不同元素组成的集合</li>
<li>Standard ways of manipulating / combining sets
<ul>
<li>Union  并集</li>
<li>Intersect   交集</li>
<li>Except   差集</li>
</ul>
</li>
<li>Treat tuples within a relation as elements of a set   将关系中的元组视为集合中的元素</li>
</ul>
<h4 id="Default-Set-Semantics"><a class="header-anchor" href="#Default-Set-Semantics">¶</a>Default: Set Semantics</h4>
<p><code>R = &#123;A, A, A, A, B, B, C, D&#125;</code></p>
<p><code>S = &#123;A, A, B, B, B, C, E&#125;</code></p>
<ul>
<li><code>UNION &#123;A, B, C, D, E&#125;</code></li>
<li><code>INTERSECT &#123;A, B, C&#125;</code></li>
<li><code>EXCEPT &#123;D&#125;</code></li>
</ul>
<p>Note: Think of each other as being a tuple in relation</p>
<h4 id="“ALL”-Multiset-Semantics"><a class="header-anchor" href="#“ALL”-Multiset-Semantics">¶</a>“ALL”: Multiset Semantics</h4>
<p><code>R = &#123;A, A, A, A, B, B, C, D&#125; = &#123;A(4), B(2), C(1), D(1)&#125;</code></p>
<p><code>S = &#123;A, A, B, B, B, C, E&#125; = &#123;A(2), B(3), C(1), E(1)&#125;</code></p>
<ul>
<li><code>UNION ALL: sum of cardinalities</code>    <code>&#123;A(4+2), B(2+3), C(1+1), D(1+0), E(0+1)&#125; = &#123;A, A, A, A, A, A, B, B, B, B, B, C, C, D, E&#125;</code></li>
<li><code>INTERSECT ALL: min of cardinalities</code>   <code>&#123;A(min(4, 2)), B(min(2, 3)), C(min(1, 1)), D(min(1, 0)), E(min(0, 1))&#125; = &#123;A, A, B, B, C&#125;</code></li>
<li><code>EXCEPT ALL: difference of cardinalities</code>   <code>&#123;A(4-2), B(2-3), C(1-1), D(1-0), E(0-1)&#125; = &#123;A, A, D&#125;</code></li>
</ul>
<h3 id="Nested-Queries"><a class="header-anchor" href="#Nested-Queries">¶</a>Nested Queries</h3>
<ul>
<li><code>嵌套查找</code></li>
</ul>
<h4 id="Nested-Queries-IN"><a class="header-anchor" href="#Nested-Queries-IN">¶</a>Nested Queries: IN</h4>
<ul>
<li>Example: Names of sailors who’ve reserved boat #102:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="keyword">IN</span></span><br><span class="line">	(<span class="keyword">SELECT</span> R.sid</span><br><span class="line">     <span class="keyword">FROM</span> Reserves R</span><br><span class="line">    <span class="keyword">WHERE</span> R.bid <span class="operator">=</span> <span class="number">102</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>括号里的是<code>subquery</code></li>
</ul>
<h4 id="Nested-Queries-NOT-IN"><a class="header-anchor" href="#Nested-Queries-NOT-IN">¶</a>Nested Queries: NOT IN</h4>
<ul>
<li>Example: Names of sailors who’ve not reserved boat #103:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">	(<span class="keyword">SELECT</span> R.sid</span><br><span class="line">     <span class="keyword">FROM</span> Reserves R</span><br><span class="line">    <span class="keyword">WHERE</span> R.bid <span class="operator">=</span> <span class="number">103</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Nested-Queries-EXISTS"><a class="header-anchor" href="#Nested-Queries-EXISTS">¶</a>Nested Queries: EXISTS</h4>
<ul>
<li>This is a bit odd, but it is legal:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">	(<span class="keyword">SELECT</span> R.sid</span><br><span class="line">    <span class="keyword">FROM</span> Reserves R</span><br><span class="line">    <span class="keyword">WHERE</span> R.bid <span class="operator">=</span> <span class="number">103</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果subquery有东西返回，就输出其中所有的sname，如果subquery返回为空，则query输出也为空</li>
</ul>
<h4 id="Nested-Queries-with-Correlation"><a class="header-anchor" href="#Nested-Queries-with-Correlation">¶</a>Nested Queries with Correlation</h4>
<ul>
<li>相关子查询</li>
<li>Names of sailors who 've reserved boat #102:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">	(<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> Reserves R</span><br><span class="line">    <span class="keyword">WHERE</span> R.bid <span class="operator">=</span> <span class="number">102</span> <span class="keyword">AND</span> S.sid <span class="operator">=</span> R.sid)</span><br></pre></td></tr></table></figure>
<ul>
<li>Correlated subquery is recomputed for each Sailors tuple   相关子查询针对每个Sailors元组（元组代表表中的一行 记录）重新计算</li>
<li>这个相关子查询有点像函数</li>
</ul>
<h4 id="More-on-Set-Comparison-Operators"><a class="header-anchor" href="#More-on-Set-Comparison-Operators">¶</a>More on Set-Comparison Operators</h4>
<ul>
<li>We 've seen: <code>IN</code>  <code>EXISTS</code></li>
<li>Can also have: <code>NOT</code>  <code>IN</code>  <code>NOT EXISTS</code></li>
<li>Other forms: <code>op ANY</code>  <code>op ALL</code></li>
</ul>
<h5 id="Example-Find-sailors-whose-rating-is-greater-than-that-of-some-sailor-called-Popeye"><a class="header-anchor" href="#Example-Find-sailors-whose-rating-is-greater-than-that-of-some-sailor-called-Popeye">¶</a>Example: Find sailors whose rating is greater than that of some sailor called Popeye</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.rating <span class="operator">&gt;</span> <span class="keyword">ANY</span></span><br><span class="line">	(<span class="keyword">SELECT</span> S2.rating</span><br><span class="line">    <span class="keyword">FROM</span> Sailors S2</span><br><span class="line">    <span class="keyword">WHERE</span> S2.sname <span class="operator">=</span> <span class="string">&#x27;Popeye&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>从Sailors表中，找出比Popeye的rating更高的人，输出其所有信息</li>
</ul>
<h3 id="A-Tough-One-“Division”——Relational-Division"><a class="header-anchor" href="#A-Tough-One-“Division”——Relational-Division">¶</a>A Tough One: “Division”——Relational Division</h3>
<ul>
<li>Relational Division: “Find sailors who 've reserved all boats.”     Said differently: “sailors with no counterexample missing boats”      关系除法：“找出预订了所有船只的水手。”      以下有点像双重否定之后输出了正确的结果</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">	(<span class="keyword">SELECT</span> B.bid</span><br><span class="line">    <span class="keyword">FROM</span> Boats B</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> R.bid</span><br><span class="line">                     <span class="keyword">FROM</span> Reserves R</span><br><span class="line">                     <span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid</span><br><span class="line">                     <span class="keyword">AND</span> R.sid <span class="operator">=</span> S.sid))</span><br></pre></td></tr></table></figure>
<h3 id="ARGMAX？"><a class="header-anchor" href="#ARGMAX？">¶</a>ARGMAX？</h3>
<h4 id="Pt-1"><a class="header-anchor" href="#Pt-1">¶</a>Pt 1</h4>
<ul>
<li>The sailor with the highest rating</li>
<li>Correct or Incorrect?</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(S.rating)</span><br><span class="line"><span class="keyword">FROM</span> Sailors S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> S.<span class="operator">*</span>, <span class="built_in">MAX</span>(S.rating)</span><br><span class="line"><span class="keyword">FROM</span> Sailors S;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个写法不对，因为只输出的最大值，而没有输出最大值对应的水手的姓名等信息</li>
<li>第二个写法有S.* ，包含了S的所有列，包括姓名、ID、最大值等。但是第二个写法是非法的，该查询会被拒绝。因为不知道该输出哪个水手的信息</li>
<li>MAX是一个聚合函数，必须与GROUP NY子句一起使用，或者在子查询中使用，而不能直接与单个记录的列一起选择（？</li>
</ul>
<h4 id="Pt-2"><a class="header-anchor" href="#Pt-2">¶</a>Pt 2</h4>
<p>以下两个query的结果一致，都是输出rating最大值的水手的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.rating <span class="operator">&gt;=</span> <span class="keyword">ALL</span></span><br><span class="line">	(<span class="keyword">SELECT</span> S2.rating</span><br><span class="line">    <span class="keyword">FROM</span> Sailors S2)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rating <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>第一种写法可能会返回一大堆评级为最高级的水手信息，相比之下第二种写法只会返回一种水手信息</p>
<p>累了，先写到这里  目前进度SQL II 41 46</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>SQL notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo初始指南</title>
    <url>/2024/07/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2>
<h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;hello world!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>《罗生门》读书摘记</title>
    <url>/2024/07/04/%E3%80%8A%E7%BD%97%E7%94%9F%E9%97%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>这本书好像是芥川龙之介的作品集，只是以最出门的《罗生门》命名，其中包含了《罗生门》《鼻》《手帕》《地狱变》《蛛丝》《橘》《舞会》《密林中》《矿车》《阿富的贞操》《一篇爱情小说》《单相思》《侏儒警语》等文章。</p>
<p>目前看到的部分是《地狱变》 读起来感觉是跟《罗生门》一样印象深刻的作品。</p>
<p>本文是以上作品的一些句子摘录以及一些可能对自分の文学创作（？有益的批注</p>
<h3 id="摘录始于此"><a class="header-anchor" href="#摘录始于此">¶</a>摘录始于此</h3>
<h4 id="译本序"><a class="header-anchor" href="#译本序">¶</a>译本序</h4>
<p>书山稗（bai四）海，文史苑囿（you四），于中沉潜含玩，钩沉抉隐，一旦发而为文，自是信手拈来。随机生发，纵横捭（bai三）阖，不可抑勒。从王侯衙役到市井小民，从寺院高僧到天主教徒，从紫宸之深到江湖之远，在其笔下无不呼之即来，腾跃纸上。</p>
<ul>
<li>
<p>钩沉抉隐：“钩沉”与“抉隐”意思相近，都有“探索深奥的道理或散失的内容”的意思</p>
</li>
<li>
<p>沉潜：①在水里潜伏、沉没。②思想感情深沉，不外露。③集中精神；潜心</p>
</li>
</ul>
<p>值得注意的是，芥川的历史题材小说并非为了演绎历史典故和翻拍历史人物，而是身披历史戏装的“现代小说”，目的在于借古喻今，针砭时弊，臧否人物，传达现代人的生命窘态和灵魂质地。……原典出入自如，布局浑然天成，主题独出机杼，笔致摇曳生姿。</p>
<ul>
<li>臧否：①褒贬，评论   ②善恶</li>
</ul>
<p>芥川生性敏感，纵然一件司空见惯的小事，也往往使其脆弱的神经震颤良久。一般来说，他不重描绘而意在发觉，疏于叙述而工于点化。少的是轻灵与潇洒，多的是沉郁与悲凉。</p>
<p>无论得于史料之作，还是拾于现实之篇，其一以贯之者，大约是以下两条主线。一是对人性中“恶”的暴露、揶揄和鞭挞。第二条主线便是对人对人生的幻灭感亦即厌世主义倾向所导致的对艺术的执着与痴迷，这或许也是出于对前者的一种补偿心理。</p>
<p>尤为可贵的是，“他有意识地创造了文体——不是陈陈相因（的文体，而是一扫庸俗气味的艺术文体”（中村真一郎语），堪称典型的艺术至上者。</p>
<ul>
<li>陈陈相因：粮仓里的米谷一年接一年地堆积起来。比喻沿袭老一套，没有改进。</li>
</ul>
<p>可以说，对中国古典的向往和对中国现实的鄙视是芥川“中国认识”的一对矛盾。前者使之怀有文化上的自卑，后者催生其现实中的傲慢（“日本优越论”）。这其实也是日本近现代主流知识分子或精英阶层共同的基本倾向，纵令夏目漱石亦不例外。愈到后来，自卑愈见其轻而傲慢愈见其烈，在结果上成为日本对外扩张和侵华战争所以顺利推进的重要思想舆论资源和社会基础。</p>
<ul>
<li>
<p>纵令：即使——用在偏正复句的偏句，表示假设的让步，即退一步提出某种情况。  例句：纵令失败，我们也要继续实验。</p>
</li>
<li>
<p>黄钟大吕：形容音乐或言辞庄严、正大、高妙、和谐。  例句：①这首乐曲饱含一种黄钟大吕的气势。  ②他的这篇短文十分朴素，却如黄钟大吕，震撼人心。  ③堪称黄钟大吕的鸿篇巨制</p>
</li>
</ul>
<h4 id="鼻"><a class="header-anchor" href="#鼻">¶</a>鼻</h4>
<p>人的内心存在两种相互矛盾的情感。无疑，没有人不同情他人的不幸。可是，一旦对方好歹从不幸中挣扎出来，却又因此产生若有所失的怅惘。说得夸张一点，甚至出现一种想使之重新陷入不幸的心理。于是，不觉之间开始对其怀有某种敌意，尽管是消极的敌意。不知个中缘由的内供之所以怏怏不快，无非是因为他从池尾僧俗的态度中，隐隐觉察出了这些旁观者的利己主义。</p>
<h4 id="地狱变"><a class="header-anchor" href="#地狱变">¶</a>地狱变</h4>
<p>这是因为，良秀笔下的众多罪人，上至三公九卿下至乞丐贱民，网罗了各色人等。有峨冠博带的庙堂高官，有花枝招展的年轻宫女，有颈挂麻纸的诵经僧，有高底木屐的书童，有长裙飘飘的豆蔻侍女，有手持供钱的阴阳先生，无暇一一列举。总之，如此形形色色的诸多男女，无不惨遭牛头马面的摧残，在上下翻腾的浓烟烈火中如风吹败叶般四下狼狈逃窜。</p>
<p>那被烟呛得白惨惨的面庞，那随火乱舞的长飘飘的秀发，那转瞬化为火焰的美艳艳的樱花盛装——所有这些是何等惨不忍睹啊！尤其每当夜风向下盘旋而烟随风披靡之时，金星乱坠的红通通的火焰中便闪现出少女咬着堵嘴物而始终拼命挣脱锁链时那痛苦扭动的情形，令人觉得地狱的大苦大难活生生展现于眼前。</p>
<p>刚才还在为地狱的惨烈场面惊恐困惑的良秀，此刻那满是皱纹的脸上浮现出无可名状的光辉——一种近乎恍惚状态的由衷喜悦之情。</p>
]]></content>
      <categories>
        <category>文史哲</category>
        <category>外国文学</category>
        <category>日本文学</category>
      </categories>
      <tags>
        <tag>reading</tag>
        <tag>外国文学</tag>
        <tag>日本文学</tag>
      </tags>
  </entry>
  <entry>
    <title>【艺术史】来世与王权的艺术——古埃及艺术</title>
    <url>/2024/07/04/%E3%80%90%E8%89%BA%E6%9C%AF%E5%8F%B2%E3%80%91%E6%9D%A5%E4%B8%96%E4%B8%8E%E7%8E%8B%E6%9D%83%E7%9A%84%E8%89%BA%E6%9C%AF%E2%80%94%E2%80%94%E5%8F%A4%E5%9F%83%E5%8F%8A%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p><a href="https://www.bilibili.com/video/BV1Dg411t7nz/?spm_id_from=333.999.0.0">视频的地址</a>  是偶然发现的一个up主，自分作为埃及历史文化爱好者=不能错过！</p>
<p>当时所有的自行记录都在幕布，所以整理起来发现都是一些凌乱的句子集（捂脸） 后面有心思了可能会完善吧！（？</p>
<p>而且是视频看了一半才想起来记录的，所以这个markdown只有后面一半部分！前半部分有机会补上吧！（？</p>
<h3 id="摘录始于此"><a class="header-anchor" href="#摘录始于此">¶</a>摘录始于此</h3>
<p>艺术是一面镜子，我们能够从中看到的东西取决于我们的知识储备和受教育水平。</p>
<p>古王国时期是艺术发展的黄金时代，这一时期的艺术风格恢弘、稳重、自信，大多数的艺术形式和艺术程式已经确定下来，形成了传统。</p>
<p>五个世纪以来，王权制度慢慢侵蚀了埃及的经济活力，使其再也无法支撑一个庞大的中央集权政府。</p>
<p>（在第一中间期）尽管从在着各种困难，但由于总督们摆脱了法老获得了独立，各个地方的艺术创造力得到了激发，古埃及进入了一个文化多元发展的时期。</p>
<p>总的来说，中王国时期的艺术在细部上有所创新，但在大体上还是遵循了古王国时期的传统。</p>
<p>不论是对于一个王朝也好，还是对于一个个人也好，对于其成长和发展来说必不可少的一件事就是回溯历史。</p>
<p>法老是一位女性，这对于埃及传统来说是一次巨大的挑战，但这件事却并非是无源之水，无本之木，而是有其现实基础的。</p>
<p>有一个普遍规律，就是女性能够成为统治者的前提，是这一时期该地区对于女性的地位是有普遍认知的，并且女性的权益是可以得到保障的。</p>
<p>而根据古埃及的法律，社会成员所拥有的权利取决于他所处的社会地位而非性别。</p>
<p>在古代的社会当中，古埃及的妇女地位相对较高。女性在几乎所有领域都与男性平等，她们享有拥有、继承和遗嘱自己财产的权利。</p>
<p>而“法老”是埃及统治者的称呼，它无关性别。</p>
<p>即使如此，一位女性成为法老还是很罕见的，她必然面临着来自传统的压力和质疑，而这必然会对她的执政合法性构成挑战。</p>
<h4 id="哈特谢普苏特"><a class="header-anchor" href="#哈特谢普苏特">¶</a>哈特谢普苏特</h4>
<p>她在自己的女性身份和传统之间找到了一个平衡点。而在这个过程当中，艺术起到了关键的作用。</p>
<h5 id="哈特谢普苏特的“三板斧”"><a class="header-anchor" href="#哈特谢普苏特的“三板斧”">¶</a>哈特谢普苏特的“三板斧”</h5>
<p>首先是在对外政策方面，在她掌权期间埃及停止了对外战争，转而大力发展和邻国之间的贸易往来，这使得国内的经济迅速繁荣，财富迅速增长；然后是在宗教方面，她宣称自己是阿蒙神之女，这样她的统治就不需要经由和图特摩斯二世的婚姻，而是完全来自于宗教；最后，她通过在埃及大规模的兴建纪念性建筑和雕像来对民众施加影响力，其目的是在于塑造自己的形象，推广自己的成就。</p>
<p>这些建筑和雕像可以迫使民众习惯于看到一个女性统治者的形象，并且接受相应的宗教叙事。这样可以确保当她（哈特谢普苏特）宣称自己为法老的时候，埃及社会不会产生太大的震动。</p>
<p>埃及艺术程式“概念性”的特点再次体现了出来：表现法老的艺术程式不是为了塑造某个具体的人，而是塑造一个概念化的形象，一个符合传统要求的形象。这里也能看出埃及人对于传统的重视。</p>
<p>埃赫那顿的统治不仅见证了一个新首都的建立和一个新宗教的兴起，它也导致了这一时期传统艺术程式的彻底改变，产生了一种新的“阿玛纳风格”（阿玛纳艺术）。</p>
<p>阿玛纳风格自然、生动、充满个性，这是古埃及艺术史上一次出现比较大的风格变化，可能也是唯一的一次。</p>
<p>后世对于这种风格的评价呈现出两极分化的趋势。</p>
<p>这种新的艺术风格就如同他的宗教改革一样极具争议。</p>
<h5 id="视频作者的一些观点"><a class="header-anchor" href="#视频作者的一些观点">¶</a>视频作者的一些观点</h5>
<p>我认为这场宗教改革改变了埃及文化的核心价值，这个特别的法老形象（指埃赫那顿）和阿玛纳风格所反映出的正是这一时期埃及的主流价值。</p>
<p>前面提到，埃及传统文化的核心价值是玛亚特。在这种价值之下，传统的艺术程式所强调的事永恒与秩序，永恒与秩序在法老雕像上面体现出的就是一种“阳刚之美”，甚至很多女性雕像也体现出了男性的特质。</p>
<p>而宗教改革所造成的结果就是传统价值——玛亚特缺失了，或者至少可以说是玛亚特被削弱了。</p>
<p>这种价值的改变可能就造成了埃及人不再追求来世的永恒，而是转而追求现世的美好。</p>
<p>于是，自然、生动、世俗、柔软、充满个性的新艺术风格随之出现，而这种新的艺术风格在法老雕像上面所呈现出的就是女性化的“阴柔之美”。</p>
<p>究其原因，这是由于宗教改革改变了文化的核心价值。</p>
<p>在埃及社会，宗教要比政治重要得多；相比于政治，宗教对艺术产生的影响也要深刻得多。</p>
<p>可能可以佐证这一观点的事实：这一时期所留存下来的墓葬浮雕当中不再有关于来世和死亡的描写。</p>
<p>主流学术界和艺术通史书籍对于埃赫那顿巨像的评价普遍偏负面，他们认为这个雕像是难看的，是不讨人喜欢的。</p>
<p>而他们对于阿玛纳风格的态度则褒贬不一，原因在于阿玛纳艺术自然、轻松的风格在古埃及程式化的艺术当中独树一帜，让人印象深刻。</p>
<p>奈菲尔提提半身像在德国辗转的这85年也是德国风云变幻的85年。</p>
<p>对于德国来说，这件作品的意义早已经超越了艺术范畴，它已经和德国的民族认同和柏林文化联系在了一起。</p>
<p>到这里也就不难理解为什么德国当局对于这件作品的态度如此坚决。</p>
<p>在古埃及艺术充满“象征性”和“正确性”的大环境当中，阿玛纳风格对于具体的人的关怀是很罕见的。</p>
<p>以上小结：阿玛纳时期的艺术相较于传统艺术咋风格上有较大的差异，其原因可能在于埃赫那顿的宗教改革造成了文化核心价值的改变。</p>
<h4 id="阿玛纳风格"><a class="header-anchor" href="#阿玛纳风格">¶</a>阿玛纳风格</h4>
<p>相比之前“静态”的传统风格，阿玛纳风格是“动态的”，其特点是放松、自然、充满“运动感”和“活动感”。</p>
<p>浮雕的主要表现方式为柔和的曲线而非僵硬的直线，所表现的神只有阿顿，没有其他的神。也没有关于死亡和来世的描写。</p>
<p>神庙通常是露天的，没有顶部</p>
<p>人物特征为细长的头部，摇摆的姿态，修长的四肢和突出的肚子。</p>
<p>在构图上相较于传统对于“秩序”的强调，阿玛纳风格显得较为“混乱”。</p>
<p>相较于传统雕像所体现出的“永恒感”和“力量感”（肌肉感），阿玛纳风格的雕像缺乏力量感，而且具有明显的女性化特征，体现出的是一种“阴柔美”。</p>
<p>相较于传统艺术程式对人物所进行的“概念化”描绘，阿玛纳风格侧重于对人物进行“个性化”的表现。</p>
<p>通过对比可以发现，哈特谢普苏特时期的艺术变革是发生在表层的，而阿玛纳时期的艺术变革是发生在深层的。</p>
<p>相比于政治，宗教对艺术的影响要深刻得多。</p>
<h5 id="视频作者的理解"><a class="header-anchor" href="#视频作者的理解">¶</a>视频作者的理解</h5>
<p>世界是一个全面的、联系的、发展的整体，历史是求变的，不论是埃及传统还是艺术程式，它发展到一定程度必然会发生一次突变。</p>
<h4 id="埃赫那顿-宗教改革"><a class="header-anchor" href="#埃赫那顿-宗教改革">¶</a>埃赫那顿&amp;宗教改革</h4>
<p>埃赫那顿和他的宗教改革就是埃及这个文化系统当中的一次突变。</p>
<p>而这次突变会给这个系统注入新的元素，让它继续发展。在后面的作品当中我们仍然能够看到一些阿玛纳风格的影子</p>
<p>在古埃及的陵墓当中，真正的诅咒其实非常罕见，这些“诅咒”通常和墓葬文书当中的咒语相混淆。</p>
<p>然而这些“诅咒”的确有科学上可以解释的原因，例如细菌或者辐射；</p>
<p>后来这些说法和历史结合在了一起，再加上能够让人信服的证据就构成了故事的传播基础，而这些故事后来又随着纪录片和相关的书籍广为流传</p>
<p>但近些年来“法老的诅咒”更多的是作为一种文化元素存在，为各种电影和游戏提供灵感和素材</p>
<p>祭司和抄写员会将来世之旅的过程记录在一个莎草纸卷轴上，然后将这些卷轴和死者一同下葬，这样他们就不会在冥界迷路了。</p>
<p>后来，学者们就将这种图文并茂的古埃及卷轴称为“亡灵书”。</p>
<p>人在第一次死亡之后灵魂会进入冥界，但每个灵魂通过冥界的方式各有不同，方式的选择取决于他们的地位。</p>
<p>通往来世的道路十分艰难，路上会有可怕的生物阻拦灵魂的前行。这时就需要灵魂吟唱亡灵书当中适当的咒语来安抚他们。</p>
<p>当灵魂经历重重险阻穿越冥界之后，他们会到达玛亚特大厅。这里是来世旅程当中最重要的部分，灵魂要在这里接受审判。</p>
<p>每个人的结局都各有不同，而灵魂的纯洁性将是他们能否被允许进入奥西里斯天国的决定性因素。</p>
<p>来世信仰，或者说古埃及文明就是一场永恒的“接力赛”。埃及人将人的死亡与重生和太阳的升起与落下联系在一起，生者的世界和亡者的世界是一个联系的整体，它们都是玛亚特这个更广泛秩序的一部分。</p>
<p>“如果没有来世信仰，埃及社会将失去凝聚力”。从这个角度来说，我们可以将古埃及文明称为“来世的文明”。</p>
<p>古埃及人所渴望的永恒就蕴藏在自己的生活当中，透过“轮回、秩序与永恒”这些在艺术作品当中反复出现的主题，所体现出的其实是埃及人对于生命的渴望和对于死亡的敬畏。</p>
<p>用佛教的话来说，人生是一场修行。</p>
<p>以上小结：亡灵书的形式感很重，它所体现出的是传统的秩序感和永恒感。</p>
<p>除了实用性和故事性，亡灵书也是埃及少见的具有明确道德内容的作品。</p>
<p>亡灵书当中的每一个“我没有…”都蕴含着一个“你不应该”的潜在含义。</p>
<p>拉美西斯二世既满足了人们对于一个曾经存在过的、无限辉煌的文明的想象，同时他也满足了人们对于一个拥有不世功绩，却又自命不凡的帝王的想象。</p>
<p>宗教、语言和文字是一个文明的重要载体，其重要性不言而喻。而随着宗教的衰落，虽然当地的居民仍然说着他们的语言，但随着神庙作用的降低和掌握着文字的祭司的减少，人们阅读和书写象形文字的能力慢慢也就消失了。</p>
<h4 id="罗塞塔石碑与现代埃及学"><a class="header-anchor" href="#罗塞塔石碑与现代埃及学">¶</a>罗塞塔石碑与现代埃及学</h4>
<p>石碑上刻有三种文字，上面的为埃及的正式书写文字，象形文字，也被称为“圣书体”；中间是另一种古埃及文字，被称为“世俗体”；而最下方则是古希腊文字。</p>
<p>欧洲的学者对于古希腊文字相对熟悉，如果他们可以将三种文字对应起来的话应该就能破译象形文字。</p>
<p>石碑的破译工作以古希腊文字为起点，很多学者都参与了进来。</p>
<p>英国的学者托马斯·杨为破译象形文字做出了重要贡献，不过他更为著名的是建立了光的波动理论和进行了杨氏双缝干涉实验。</p>
<p>最后，成功破译象形文字的是法国学者商博良，而他也因此成为了埃及学的奠基人。</p>
<p>罗塞塔石碑的破译成为了现代埃及学的开端，自此人们终于找到了打开古埃及文明这座宝库的钥匙，让我们有机会了解这个辉煌的古老文明</p>
<h4 id="雪莱《奥兹曼迪亚斯》（拉美西斯二世）"><a class="header-anchor" href="#雪莱《奥兹曼迪亚斯》（拉美西斯二世）">¶</a>雪莱《奥兹曼迪亚斯》（拉美西斯二世）</h4>
<p>讽刺诗歌《Ozymandias/奥兹曼迪亚斯》中英文对照[波西·比希.雪莱]</p>
<p>Ozymandias（奥兹曼迪亚斯）被古代希腊称作埃及的Ramses II是一位威武的法老（国王），英国诗人雪莱有写了一首关于他的傲慢与灭亡来暗喻警示当时当权者的傲慢的诗。</p>
<p>诗歌是文学艺术最为凝练的表现形式。波西·比希.雪莱（Percy.Bysshe.Shelley）是19世纪英国<a href="http://www.timeface.cn/aiqing/lmqs">浪漫主义伟大诗人</a>的代表之一，其诗风古朴自然，极富韵律，而内容上也是极富个性，既有对自己情感的强烈表达，又有对大自然的欣赏和热爱，同时还有对封建权威、强权统治的反抗。雪莱笔下的“奥兹曼迪亚斯”（Ozymandias）就是这样一首承载了诗人对权威、传统的反抗的传世之作。对这首诗的诗歌主题进行分析研究的大有人在，然而，诗歌不仅是表意最凝练的方式，它更多地是一种文字艺术，因而，其形式本身也是一种艺术。本题拟将从表词达意（meaning）、意象（imagery）以及修辞手法（figure of speech）对“奥兹曼迪亚斯”进行梳理分析。</p>
<ul>
<li>
<p>《奥兹曼迪亚斯》中英文对照</p>
</li>
<li>
<p>英文原文</p>
</li>
<li>
<p>Ozymandias</p>
</li>
<li>
<p>I met a traveller from an antique land</p>
</li>
<li>
<p>Who said: &quot;Two vast and trunkless legs of stone</p>
</li>
<li>
<p>Stand in the desert. Near them on the sand,</p>
</li>
<li>
<p>Half sunk, a shattered visage lies, whose frown</p>
</li>
<li>
<p>And wrinkled lip and sneer of cold command</p>
</li>
<li>
<p>Tell that its sculptor well those passions read</p>
</li>
<li>
<p>Which yet survive, stamped on these lifeless things,</p>
</li>
<li>
<p>The hand that mocked them and the heart that fed.</p>
</li>
<li>
<p>And on the pedestal these words appear:</p>
</li>
<li>
<p>'My name is Ozymandias, King of Kings:</p>
</li>
<li>
<p>Look on my works, ye mighty, and despair!’</p>
</li>
<li>
<p>Nothing beside remains. Round the decay</p>
</li>
<li>
<p>Of that colossal wreck, boundless and bare,</p>
</li>
<li>
<p>The lone and level sands stretch far away.</p>
</li>
<li>
<p>中文翻译　　1. 奥兹曼迪亚斯（杨绛 译）</p>
</li>
<li>
<p>我遇见一位来自古国的旅人</p>
</li>
<li>
<p>他说：有两条巨大的石腿</p>
</li>
<li>
<p>半掩于沙漠之间</p>
</li>
<li>
<p>近旁的沙土中，有一张破碎的石脸</p>
</li>
<li>
<p>抿着嘴，蹙着眉，面孔依旧威严</p>
</li>
<li>
<p>想那雕刻者，必定深谙其人情感</p>
</li>
<li>
<p>那神态还留在石头上</p>
</li>
<li>
<p>而斯人已逝，化作尘烟</p>
</li>
<li>
<p>看那石座上刻着字句：</p>
</li>
<li>
<p>“我是万王之王,奥兹曼斯迪亚斯</p>
</li>
<li>
<p>功业盖物,强者折服”</p>
</li>
<li>
<p>此外，荡然无物</p>
</li>
<li>
<p>废墟四周，唯余黄沙莽莽</p>
</li>
<li>
<p>寂寞荒凉，伸展四方。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>文史哲</category>
        <category>世界史</category>
        <category>埃及史</category>
      </categories>
      <tags>
        <tag>reading</tag>
        <tag>世界史</tag>
        <tag>埃及史</tag>
      </tags>
  </entry>
</search>
